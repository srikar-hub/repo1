/**
 * @license
 * Video.js 8.5.0 <http://tm_videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/tm_videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).tm_videojs = t() }(this, function () {
  "use strict"; var R = "8.5.0"; const U = {}, B = function (e, t) { return U[e] = U[e] || [], t && (U[e] = U[e].concat(t)), U[e] }; function F(e, t) { return !((t = B(e).indexOf(t)) <= -1 || (U[e] = U[e].slice(), U[e].splice(t, 1), 0)) } const j = { prefixed: !0 }; var H = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"]], V = H[0]; let q; for (let e = 0; e < H.length; e++)if (H[e][1] in document) { q = H[e]; break } if (q) { for (let e = 0; e < q.length; e++)j[V[e]] = q[e]; j.prefixed = q[0] !== V[0] } let l = []; function z(e) { return K(e) ? Object.keys(e) : [] } const d = function t(i) { let s = "info", n; function r(...e) { n("log", s, e) } var a, o; return n = (a = i, (t, i, s) => { var e, i = o.levels[i], n = new RegExp(`^(${i})$`); if ("log" !== t && s.unshift(t.toUpperCase() + ":"), s.unshift(a + ":"), l && (l.push([].concat(s)), e = l.length - 1e3, l.splice(0, 0 < e ? e : 0)), window.console) { let e = window.console[t]; (e = e || "debug" !== t ? e : window.console.info || window.console.log) && i && n.test(t) && e[Array.isArray(s) ? "apply" : "call"](window.console, s) } }), (o = r).createLogger = e => t(i + ": " + e), r.levels = { all: "debug|log|warn|error", off: "", debug: "debug|log|warn|error", info: "log|warn|error", warn: "warn|error", error: "error", DEFAULT: s }, r.level = e => { if ("string" == typeof e) { if (!r.levels.hasOwnProperty(e)) throw new Error(`"${e}" in not a valid log level`); s = e } return s }, r.history = () => l ? [].concat(l) : [], r.history.filter = t => (l || []).filter(e => new RegExp(`.*${t}.*`).test(e[0])), r.history.clear = () => { l && (l.length = 0) }, r.history.disable = () => { null !== l && (l.length = 0, l = null) }, r.history.enable = () => { null === l && (l = []) }, r.error = (...e) => n("error", s, e), r.warn = (...e) => n("warn", s, e), r.debug = (...e) => n("debug", s, e), r }("TM_VIDEOJS"), $ = d.createLogger, W = Object.prototype.toString; function G(t, i) { z(t).forEach(e => i(t[e], e)) } function X(i, s, e = 0) { return z(i).reduce((e, t) => s(e, i[t], t), e) } function K(e) { return !!e && "object" == typeof e } function Y(e) { return K(e) && "[object Object]" === W.call(e) && e.constructor === Object } function h(...e) { const i = {}; return e.forEach(e => { e && G(e, (e, t) => { Y(e) ? (Y(i[t]) || (i[t] = {}), i[t] = h(i[t], e)) : i[t] = e }) }), i } function Q(e = {}) { var t, i = []; for (const s in e) e.hasOwnProperty(s) && (t = e[s], i.push(t)); return i } function J(t, i, s, e = !0) { const n = e => Object.defineProperty(t, i, { value: e, enumerable: !0, writable: !0 }); var r = { configurable: !0, enumerable: !0, get() { var e = s(); return n(e), e } }; return e && (r.set = n), Object.defineProperty(t, i, r) } var Z = Object.freeze({ __proto__: null, each: G, reduce: X, isObject: K, isPlain: Y, merge: h, values: Q, defineLazyProperty: J }); let ee = !1, te = null, ie = !1, se, ne = !1, re = !1, ae = !1, oe = !1, le = null, de = null, he = null, ue = !1, ce = !1, pe = !1, me = !1; const ge = Boolean(ve() && ("ontouchstart" in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch)); var fe, e = window.navigator && window.navigator.userAgentData; if (e && (ie = "Android" === e.platform, re = Boolean(e.brands.find(e => "Microsoft Edge" === e.brand)), ae = Boolean(e.brands.find(e => "Chromium" === e.brand)), oe = !re && ae, le = de = (e.brands.find(e => "Chromium" === e.brand) || {}).version || null, ce = "Windows" === e.platform), !ae) { const N = window.navigator && window.navigator.userAgent || ""; ee = /iPod/i.test(N), te = (e = N.match(/OS (\d+)_/i)) && e[1] ? e[1] : null, ie = /Android/i.test(N), se = (e = N.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i)) ? (gt = e[1] && parseFloat(e[1]), fe = e[2] && parseFloat(e[2]), gt && fe ? parseFloat(e[1] + "." + e[2]) : gt || null) : null, ne = /Firefox/i.test(N), re = /Edg/i.test(N), ae = /Chrome/i.test(N) || /CriOS/i.test(N), oe = !re && ae, le = de = (fe = N.match(/(Chrome|CriOS)\/(\d+)/)) && fe[2] ? parseFloat(fe[2]) : null, he = function () { var e = /MSIE\s(\d+)\.\d/.exec(N); let t = e && parseFloat(e[1]); return t = !t && /Trident\/7.0/i.test(N) && /rv:11.0/.test(N) ? 11 : t }(), ue = /Safari/i.test(N) && !oe && !ie && !re, ce = /Windows/i.test(N), pe = /iPad/i.test(N) || ue && ge && !/iPhone/i.test(N), me = /iPhone/i.test(N) && !pe } const u = me || pe || ee, ye = (ue || u) && !oe; e = Object.freeze({ __proto__: null, get IS_IPOD() { return ee }, get IOS_VERSION() { return te }, get IS_ANDROID() { return ie }, get ANDROID_VERSION() { return se }, get IS_FIREFOX() { return ne }, get IS_EDGE() { return re }, get IS_CHROMIUM() { return ae }, get IS_CHROME() { return oe }, get CHROMIUM_VERSION() { return le }, get CHROME_VERSION() { return de }, get IE_VERSION() { return he }, get IS_SAFARI() { return ue }, get IS_WINDOWS() { return ce }, get IS_IPAD() { return pe }, get IS_IPHONE() { return me }, TOUCH_ENABLED: ge, IS_IOS: u, IS_ANY_SAFARI: ye }); function _e(e) { return "string" == typeof e && Boolean(e.trim()) } function ve() { return document === window.document } function be(e) { return K(e) && 1 === e.nodeType } function Te() { try { return window.parent !== window.self } catch (e) { return !0 } } function Se(i) { return function (e, t) { return _e(e) ? (t = be(t = _e(t) ? document.querySelector(t) : t) ? t : document)[i] && t[i](e) : document[i](null) } } function o(e = "div", i = {}, t = {}, s) { const n = document.createElement(e); return Object.getOwnPropertyNames(i).forEach(function (e) { var t = i[e]; "textContent" === e ? we(n, t) : n[e] === t && "tabIndex" !== e || (n[e] = t) }), Object.getOwnPropertyNames(t).forEach(function (e) { n.setAttribute(e, t[e]) }), s && Ve(n, s), n } function we(e, t) { return "undefined" == typeof e.textContent ? e.innerText = t : e.textContent = t, e } function Ee(e, t) { t.firstChild ? t.insertBefore(e, t.firstChild) : t.appendChild(e) } function Ce(e, t) { if (0 <= t.indexOf(" ")) throw new Error("class has illegal whitespace characters"); return e.classList.contains(t) } function ke(e, ...t) { return e.classList.add(...t.reduce((e, t) => e.concat(t.split(/\s+/)), [])), e } function Ie(e, ...t) { return e ? (e.classList.remove(...t.reduce((e, t) => e.concat(t.split(/\s+/)), [])), e) : (d.warn("removeClass was called with an element that doesn't exist"), null) } function xe(t, e, i) { return "boolean" != typeof (i = "function" == typeof i ? i(t, e) : i) && (i = void 0), e.split(/\s+/).forEach(e => t.classList.toggle(e, i)), t } function Ae(i, s) { Object.getOwnPropertyNames(s).forEach(function (e) { var t = s[e]; null === t || "undefined" == typeof t || !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t) }) } function Le(e) { var i = {}, s = ["autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted"]; if (e && e.attributes && 0 < e.attributes.length) { var n = e.attributes; for (let t = n.length - 1; 0 <= t; t--) { var r = n[t].name; let e = n[t].value; s.includes(r) && (e = null !== e), i[r] = e } } return i } function Pe(e, t) { return e.getAttribute(t) } function De(e, t, i) { e.setAttribute(t, i) } function Oe(e, t) { e.removeAttribute(t) } function Me() { document.body.focus(), document.onselectstart = function () { return !1 } } function Ne() { document.onselectstart = function () { return !0 } } function Re(e) { if (e && e.getBoundingClientRect && e.parentNode) { const t = e.getBoundingClientRect(), i = {}; return ["bottom", "height", "left", "right", "top", "width"].forEach(e => { void 0 !== t[e] && (i[e] = t[e]) }), i.height || (i.height = parseFloat(Ge(e, "height"))), i.width || (i.width = parseFloat(Ge(e, "width"))), i } } function Ue(e) { if (!e || !e.offsetParent) return { left: 0, top: 0, width: 0, height: 0 }; var t = e.offsetWidth, i = e.offsetHeight; let s = 0, n = 0; for (; e.offsetParent && e !== document[j.fullscreenElement];)s += e.offsetLeft, n += e.offsetTop, e = e.offsetParent; return { left: s, top: n, width: t, height: i } } function Be(t, e) { var i = { x: 0, y: 0 }; if (u) { let e = t; for (; e && "html" !== e.nodeName.toLowerCase();) { var s, n = Ge(e, "transform"); /^matrix/.test(n) ? (s = n.slice(7, -1).split(/,\s/).map(Number), i.x += s[4], i.y += s[5]) : /^matrix3d/.test(n) && (s = n.slice(9, -1).split(/,\s/).map(Number), i.x += s[12], i.y += s[13]), e = e.parentNode } } var r = {}, a = Ue(e.target), t = Ue(t), o = t.width, l = t.height; let d = e.offsetY - (t.top - a.top), h = e.offsetX - (t.left - a.left); return e.changedTouches && (h = e.changedTouches[0].pageX - t.left, d = e.changedTouches[0].pageY + t.top, u) && (h -= i.x, d -= i.y), r.y = 1 - Math.max(0, Math.min(1, d / l)), r.x = Math.max(0, Math.min(1, h / o)), r } function Fe(e) { return K(e) && 3 === e.nodeType } function je(e) { for (; e.firstChild;)e.removeChild(e.firstChild); return e } function He(e) { return "function" == typeof e && (e = e()), (Array.isArray(e) ? e : [e]).map(e => be(e = "function" == typeof e ? e() : e) || Fe(e) ? e : "string" == typeof e && /\S/.test(e) ? document.createTextNode(e) : void 0).filter(e => e) } function Ve(t, e) { return He(e).forEach(e => t.appendChild(e)), t } function qe(e, t) { return Ve(je(e), t) } function ze(e) { return void 0 === e.button && void 0 === e.buttons || 0 === e.button && void 0 === e.buttons || "mouseup" === e.type && 0 === e.button && 0 === e.buttons || 0 === e.button && 1 === e.buttons } const $e = Se("querySelector"), We = Se("querySelectorAll"); function Ge(t, i) { if (!t || !i) return ""; if ("function" != typeof window.getComputedStyle) return ""; { let e; try { e = window.getComputedStyle(t) } catch (e) { return "" } return e ? e.getPropertyValue(i) || e[i] : "" } } var Xe = Object.freeze({ __proto__: null, isReal: ve, isEl: be, isInFrame: Te, createEl: o, textContent: we, prependTo: Ee, hasClass: Ce, addClass: ke, removeClass: Ie, toggleClass: xe, setAttributes: Ae, getAttributes: Le, getAttribute: Pe, setAttribute: De, removeAttribute: Oe, blockTextSelection: Me, unblockTextSelection: Ne, getBoundingClientRect: Re, findPosition: Ue, getPointerPosition: Be, isTextNode: Fe, emptyEl: je, normalizeContent: He, appendContent: Ve, insertContent: qe, isSingleLeftClick: ze, $: $e, $$: We, computedStyle: Ge }); let Ke = !1, Ye; function Qe() { if (!1 !== Ye.options.autoSetup) { var e = Array.prototype.slice.call(document.getElementsByTagName("video")), t = Array.prototype.slice.call(document.getElementsByTagName("audio")), i = Array.prototype.slice.call(document.getElementsByTagName("video-js")), s = e.concat(t, i); if (s && 0 < s.length) for (let e = 0, t = s.length; e < t; e++) { var n = s[e]; if (!n || !n.getAttribute) { Je(1); break } void 0 === n.player && null !== n.getAttribute("data-setup") && Ye(n) } else Ke || Je(1) } } function Je(e, t) { ve() && (t && (Ye = t), window.setTimeout(Qe, e)) } function Ze() { Ke = !0, window.removeEventListener("load", Ze) } ve() && ("complete" === document.readyState ? Ze() : window.addEventListener("load", Ze)); function et(e) { var t = document.createElement("style"); return t.className = e, t } function tt(e, t) { e.styleSheet ? e.styleSheet.cssText = t : e.textContent = t } var c = new WeakMap; let it = 3; function st(e, t) { var i; c.has(e) && (0 === (i = c.get(e)).handlers[t].length && (delete i.handlers[t], e.removeEventListener ? e.removeEventListener(t, i.dispatcher, !1) : e.detachEvent && e.detachEvent("on" + t, i.dispatcher)), Object.getOwnPropertyNames(i.handlers).length <= 0 && (delete i.handlers, delete i.dispatcher, delete i.disabled), 0 === Object.getOwnPropertyNames(i).length) && c.delete(e) } function nt(t, i, e, s) { e.forEach(function (e) { t(i, e, s) }) } function rt(e) { if (!e.fixed_) { if (!e || !e.isPropagationStopped || !e.isImmediatePropagationStopped) { const r = e || window.event; e = {}; for (const a in r) "layerX" === a || "layerY" === a || "keyLocation" === a || "webkitMovementX" === a || "webkitMovementY" === a || "path" === a || "returnValue" === a && r.preventDefault || (e[a] = r[a]); var t, i; e.target || (e.target = e.srcElement || document), e.relatedTarget || (e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement), e.preventDefault = function () { r.preventDefault && r.preventDefault(), e.returnValue = !1, r.returnValue = !1, e.defaultPrevented = !0 }, e.defaultPrevented = !1, e.stopPropagation = function () { r.stopPropagation && r.stopPropagation(), e.cancelBubble = !0, r.cancelBubble = !0, e.isPropagationStopped = s }, e.isPropagationStopped = n, e.stopImmediatePropagation = function () { r.stopImmediatePropagation && r.stopImmediatePropagation(), e.isImmediatePropagationStopped = s, e.stopPropagation() }, e.isImmediatePropagationStopped = n, null !== e.clientX && void 0 !== e.clientX && (t = document.documentElement, i = document.body, e.pageX = e.clientX + (t && t.scrollLeft || i && i.scrollLeft || 0) - (t && t.clientLeft || i && i.clientLeft || 0), e.pageY = e.clientY + (t && t.scrollTop || i && i.scrollTop || 0) - (t && t.clientTop || i && i.clientTop || 0)), e.which = e.charCode || e.keyCode, null !== e.button && void 0 !== e.button && (e.button = 1 & e.button ? 0 : 4 & e.button ? 1 : 2 & e.button ? 2 : 0) } e.fixed_ = !0 } return e; function s() { return !0 } function n() { return !1 } } let at; const ot = ["touchstart", "touchmove"]; function lt(r, t, e) { if (Array.isArray(t)) return nt(lt, r, t, e); c.has(r) || c.set(r, {}); const a = c.get(r); if (a.handlers || (a.handlers = {}), a.handlers[t] || (a.handlers[t] = []), e.guid || (e.guid = it++), a.handlers[t].push(e), a.dispatcher || (a.disabled = !1, a.dispatcher = function (i, s) { if (!a.disabled) { i = rt(i); var e = a.handlers[i.type]; if (e) { var n = e.slice(0); for (let e = 0, t = n.length; e < t && !i.isImmediatePropagationStopped(); e++)try { n[e].call(r, i, s) } catch (e) { d.error(e) } } } }), 1 === a.handlers[t].length) if (r.addEventListener) { let e = !1; (function () { if ("boolean" != typeof at) { at = !1; try { var e = Object.defineProperty({}, "passive", { get() { at = !0 } }); window.addEventListener("test", null, e), window.removeEventListener("test", null, e) } catch (e) { } } return at })() && -1 < ot.indexOf(t) && (e = { passive: !0 }), r.addEventListener(t, a.dispatcher, e) } else r.attachEvent && r.attachEvent("on" + t, a.dispatcher) } function p(e, t, i) { if (c.has(e)) { const r = c.get(e); if (r.handlers) { if (Array.isArray(t)) return nt(p, e, t, i); var s = function (e, t) { r.handlers[t] = [], st(e, t) }; if (void 0 === t) for (const a in r.handlers) Object.prototype.hasOwnProperty.call(r.handlers || {}, a) && s(e, a); else { var n = r.handlers[t]; if (n) if (i) { if (i.guid) for (let e = 0; e < n.length; e++)n[e].guid === i.guid && n.splice(e--, 1); st(e, t) } else s(e, t) } } } } function dt(e, t, i) { var s = c.has(e) ? c.get(e) : {}, n = e.parentNode || e.ownerDocument; return "string" == typeof t ? t = { type: t, target: e } : t.target || (t.target = e), t = rt(t), s.dispatcher && s.dispatcher.call(e, t, i), n && !t.isPropagationStopped() && !0 === t.bubbles ? dt.call(null, n, t, i) : !n && !t.defaultPrevented && t.target && t.target[t.type] && (c.has(t.target) || c.set(t.target, {}), s = c.get(t.target), t.target[t.type]) && (s.disabled = !0, "function" == typeof t.target[t.type] && t.target[t.type](), s.disabled = !1), !t.defaultPrevented } function ht(e, t, i) { if (Array.isArray(t)) return nt(ht, e, t, i); function s() { p(e, t, s), i.apply(this, arguments) } s.guid = i.guid = i.guid || it++, lt(e, t, s) } function ut(e, t, i) { function s() { p(e, t, s), i.apply(this, arguments) } s.guid = i.guid = i.guid || it++, lt(e, t, s) } var ct = Object.freeze({ __proto__: null, fixEvent: rt, on: lt, off: p, trigger: dt, one: ht, any: ut }); function m(e, t, i) { return t.guid || (t.guid = it++), (e = t.bind(e)).guid = i ? i + "_" + t.guid : t.guid, e } function pt(i, s) { let n = window.performance.now(); return function (...e) { var t = window.performance.now(); t - n >= s && (i(...e), n = t) } } function mt(s, n, r, a = window) { let o; function e() { const e = this, t = arguments; let i = function () { o = null, i = null, r || s.apply(e, t) }; !o && r && s.apply(e, t), a.clearTimeout(o), o = a.setTimeout(i, n) } return e.cancel = () => { a.clearTimeout(o), o = null }, e } var gt = Object.freeze({ __proto__: null, UPDATE_REFRESH_INTERVAL: 30, bind_: m, throttle: pt, debounce: mt }); let ft; class yt { on(e, t) { var i = this.addEventListener; this.addEventListener = () => { }, lt(this, e, t), this.addEventListener = i } off(e, t) { p(this, e, t) } one(e, t) { var i = this.addEventListener; this.addEventListener = () => { }, ht(this, e, t), this.addEventListener = i } any(e, t) { var i = this.addEventListener; this.addEventListener = () => { }, ut(this, e, t), this.addEventListener = i } trigger(e) { var t = e.type || e; e = rt(e = "string" == typeof e ? { type: t } : e), this.allowedEvents_[t] && this["on" + t] && this["on" + t](e), dt(this, e) } queueTrigger(e) { ft = ft || new Map; const t = e.type || e; let i = ft.get(this); i || (i = new Map, ft.set(this, i)); var s = i.get(t), s = (i.delete(t), window.clearTimeout(s), window.setTimeout(() => { i.delete(t), 0 === i.size && (i = null, ft.delete(this)), this.trigger(e) }, 0)); i.set(t, s) } } yt.prototype.allowedEvents_ = {}, yt.prototype.addEventListener = yt.prototype.on, yt.prototype.removeEventListener = yt.prototype.off, yt.prototype.dispatchEvent = yt.prototype.trigger; const _t = e => "function" == typeof e.name ? e.name() : "string" == typeof e.name ? e.name : e.name_ || (e.constructor && e.constructor.name ? e.constructor.name : typeof e), vt = t => t instanceof yt || !!t.eventBusEl_ && ["on", "one", "off", "trigger"].every(e => "function" == typeof t[e]), bt = e => "string" == typeof e && /\S/.test(e) || Array.isArray(e) && !!e.length, Tt = (e, t, i) => { if (!e || !e.nodeName && !vt(e)) throw new Error(`Invalid target for ${_t(t)}#${i}; must be a DOM node or evented object.`) }, St = (e, t, i) => { if (!bt(e)) throw new Error(`Invalid event type for ${_t(t)}#${i}; must be a non-empty string or array.`) }, wt = (e, t, i) => { if ("function" != typeof e) throw new Error(`Invalid listener for ${_t(t)}#${i}; must be a function.`) }, Et = (e, t, i) => { var s = t.length < 3 || t[0] === e || t[0] === e.eventBusEl_; let n, r, a; return s ? (n = e.eventBusEl_, 3 <= t.length && t.shift(), [r, a] = t) : [n, r, a] = t, Tt(n, e, i), St(r, e, i), wt(a, e, i), a = m(e, a), { isTargetingSelf: s, target: n, type: r, listener: a } }, Ct = (e, t, i, s) => { Tt(e, e, t), e.nodeName ? ct[t](e, i, s) : e[t](i, s) }, kt = { on(...e) { const { isTargetingSelf: t, target: i, type: s, listener: n } = Et(this, e, "on"); if (Ct(i, "on", s, n), !t) { const r = () => this.off(i, s, n); r.guid = n.guid; e = () => this.off("dispose", r); e.guid = n.guid, Ct(this, "on", "dispose", r), Ct(i, "on", "dispose", e) } }, one(...e) { const { isTargetingSelf: t, target: i, type: s, listener: n } = Et(this, e, "one"); if (t) Ct(i, "one", s, n); else { const r = (...e) => { this.off(i, s, r), n.apply(null, e) }; r.guid = n.guid, Ct(i, "one", s, r) } }, any(...e) { const { isTargetingSelf: t, target: i, type: s, listener: n } = Et(this, e, "any"); if (t) Ct(i, "any", s, n); else { const r = (...e) => { this.off(i, s, r), n.apply(null, e) }; r.guid = n.guid, Ct(i, "any", s, r) } }, off(e, t, i) { !e || bt(e) ? p(this.eventBusEl_, e, t) : (e = e, t = t, Tt(e, this, "off"), St(t, this, "off"), wt(i, this, "off"), i = m(this, i), this.off("dispose", i), e.nodeName ? (p(e, t, i), p(e, "dispose", i)) : vt(e) && (e.off(t, i), e.off("dispose", i))) }, trigger(e, t) { Tt(this.eventBusEl_, this, "trigger"); var i = e && "string" != typeof e ? e.type : e; if (bt(i)) return dt(this.eventBusEl_, e, t); throw new Error(`Invalid event type for ${_t(this)}#trigger; ` + "must be a non-empty string or object with a type key that has a non-empty value.") } }; function It(e, t = {}) { t = t.eventBusKey; if (t) { if (!e[t].nodeName) throw new Error(`The eventBusKey "${t}" does not refer to an element.`); e.eventBusEl_ = e[t] } else e.eventBusEl_ = o("span", { className: "vjs-event-bus" }); Object.assign(e, kt), e.eventedCallbacks && e.eventedCallbacks.forEach(e => { e() }), e.on("dispose", () => { e.off(), [e, e.el_, e.eventBusEl_].forEach(function (e) { e && c.has(e) && c.delete(e) }), window.setTimeout(() => { e.eventBusEl_ = null }, 0) }) } const xt = { state: {}, setState(e) { "function" == typeof e && (e = e()); let i; return G(e, (e, t) => { this.state[t] !== e && ((i = i || {})[t] = { from: this.state[t], to: e }), this.state[t] = e }), i && vt(this) && this.trigger({ changes: i, type: "statechanged" }), i } }; function At(e, t) { Object.assign(e, xt), e.state = Object.assign({}, e.state, t), "function" == typeof e.handleStateChanged && vt(e) && e.on("statechanged", e.handleStateChanged) } function Lt(e) { return "string" != typeof e ? e : e.replace(/./, e => e.toLowerCase()) } function g(e) { return "string" != typeof e ? e : e.replace(/./, e => e.toUpperCase()) } function Pt(e, t) { return g(e) === g(t) } var Dt = Object.freeze({ __proto__: null, toLowerCase: Lt, toTitleCase: g, titleCaseEquals: Pt }), Ot = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function Mt(e, t) { return e(t = { exports: {} }, t.exports), t.exports } var n = Mt(function (e, t) { function i(e) { var t; return "number" == typeof (e = e && "object" == typeof e && (t = e.which || e.keyCode || e.charCode) ? t : e) ? o[e] : (t = String(e), s[t.toLowerCase()] || n[t.toLowerCase()] || (1 === t.length ? t.charCodeAt(0) : void 0)) } i.isEventKey = function (e, t) { if (e && "object" == typeof e) { e = e.which || e.keyCode || e.charCode; if (null != e) if ("string" == typeof t) { var i = s[t.toLowerCase()]; if (i) return i === e; if (i = n[t.toLowerCase()]) return i === e } else if ("number" == typeof t) return t === e; return !1 } }; for (var s = (t = e.exports = i).code = t.codes = { backspace: 8, tab: 9, enter: 13, shift: 16, ctrl: 17, alt: 18, "pause/break": 19, "caps lock": 20, esc: 27, space: 32, "page up": 33, "page down": 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40, insert: 45, delete: 46, command: 91, "left command": 91, "right command": 93, "numpad *": 106, "numpad +": 107, "numpad -": 109, "numpad .": 110, "numpad /": 111, "num lock": 144, "scroll lock": 145, "my computer": 182, "my calculator": 183, ";": 186, "=": 187, ",": 188, "-": 189, ".": 190, "/": 191, "`": 192, "[": 219, "\\": 220, "]": 221, "'": 222 }, n = t.aliases = { windows: 91, "⇧": 16, "⌥": 18, "⌃": 17, "⌘": 91, ctl: 17, control: 17, option: 18, pause: 19, break: 19, caps: 20, return: 13, escape: 27, spc: 32, spacebar: 32, pgup: 33, pgdn: 34, ins: 45, del: 46, cmd: 91 }, r = 97; r < 123; r++)s[String.fromCharCode(r)] = r - 32; for (var r = 48; r < 58; r++)s[r - 48] = r; for (r = 1; r < 13; r++)s["f" + r] = r + 111; for (r = 0; r < 10; r++)s["numpad " + r] = r + 96; var a, o = t.names = t.title = {}; for (r in s) o[s[r]] = r; for (a in n) s[a] = n[a] }); n.code, n.codes, n.aliases, n.names, n.title; class f { constructor(e, t, i) { !e && this.play ? this.player_ = e = this : this.player_ = e, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = h({}, this.options_), t = this.options_ = h(this.options_, t), this.id_ = t.id || t.el && t.el.id, this.id_ || (e = e && e.id && e.id() || "no_player", this.id_ = e + "_component_" + it++), this.name_ = t.name || null, t.el ? this.el_ = t.el : !1 !== t.createEl && (this.el_ = this.createEl()), t.className && this.el_ && t.className.split(" ").forEach(e => this.addClass(e)), ["on", "off", "one", "any", "trigger"].forEach(e => { this[e] = void 0 }), !1 !== t.evented && (It(this, { eventBusKey: this.el_ ? "el_" : null }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), At(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = new Set, this.setIntervalIds_ = new Set, this.rafIds_ = new Set, this.namedRafs_ = new Map, (this.clearingTimersOnDispose_ = !1) !== t.initChildren && this.initChildren(), this.ready(i), !1 !== t.reportTouchActivity && this.enableTouchActivity() } on(e, t) { } off(e, t) { } one(e, t) { } any(e, t) { } trigger(e, t) { } dispose(e = {}) { if (!this.isDisposed_) { if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({ type: "dispose", bubbles: !1 }), this.isDisposed_ = !0, this.children_) for (let e = this.children_.length - 1; 0 <= e; e--)this.children_[e].dispose && this.children_[e].dispose(); this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (e.restoreEl ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null } } isDisposed() { return Boolean(this.isDisposed_) } player() { return this.player_ } options(e) { return e && (this.options_ = h(this.options_, e)), this.options_ } el() { return this.el_ } createEl(e, t, i) { return o(e, t, i) } localize(e, s, t = e) { var i = this.player_.language && this.player_.language(), n = this.player_.languages && this.player_.languages(), r = n && n[i], i = i && i.split("-")[0], n = n && n[i]; let a = t; return r && r[e] ? a = r[e] : n && n[e] && (a = n[e]), a = s ? a.replace(/\{(\d+)\}/g, function (e, t) { t = s[t - 1]; let i = "undefined" == typeof t ? e : t; return i }) : a } handleLanguagechange() { } contentEl() { return this.contentEl_ || this.el_ } id() { return this.id_ } name() { return this.name_ } children() { return this.children_ } getChildById(e) { return this.childIndex_[e] } getChild(e) { if (e) return this.childNameIndex_[e] } getDescendant(...t) { t = t.reduce((e, t) => e.concat(t), []); let i = this; for (let e = 0; e < t.length; e++)if (!(i = i.getChild(t[e])) || !i.getChild) return; return i } setIcon(e, t = this.el()) { var i, s, n; if (this.player_.options_.experimentalSvgIcons) return n = "http://www.w3.org/2000/svg", i = o("span", { className: "vjs-icon-placeholder vjs-svg-icon" }, { "aria-hidden": "true" }), (s = document.createElementNS(n, "svg")).setAttributeNS(null, "viewBox", "0 0 512 512"), n = document.createElementNS(n, "use"), s.appendChild(n), n.setAttributeNS(null, "href", "#vjs-icon-" + e), i.appendChild(s), this.iconIsSet_ ? t.replaceChild(i, t.querySelector(".vjs-icon-placeholder")) : t.appendChild(i), this.iconIsSet_ = !0, i } addChild(e, t = {}, i = this.children_.length) { let s, n; if ("string" == typeof e) { n = g(e); var r = t.componentClass || n, a = (t.name = n, f.getComponent(r)); if (!a) throw new Error(`Component ${r} does not exist`); if ("function" != typeof a) return null; s = new a(this.player_ || this, t) } else s = e; if (s.parentComponent_ && s.parentComponent_.removeChild(s), this.children_.splice(i, 0, s), s.parentComponent_ = this, "function" == typeof s.id && (this.childIndex_[s.id()] = s), (n = n || s.name && g(s.name())) && (this.childNameIndex_[n] = s, this.childNameIndex_[Lt(n)] = s), "function" == typeof s.el && s.el()) { let e = null; this.children_[i + 1] && (this.children_[i + 1].el_ ? e = this.children_[i + 1].el_ : be(this.children_[i + 1]) && (e = this.children_[i + 1])), this.contentEl().insertBefore(s.el(), e) } return s } removeChild(i) { if ((i = "string" == typeof i ? this.getChild(i) : i) && this.children_) { let t = !1; for (let e = this.children_.length - 1; 0 <= e; e--)if (this.children_[e] === i) { t = !0, this.children_.splice(e, 1); break } var e; t && (i.parentComponent_ = null, this.childIndex_[i.id()] = null, this.childNameIndex_[g(i.name())] = null, this.childNameIndex_[Lt(i.name())] = null, e = i.el()) && e.parentNode === this.contentEl() && this.contentEl().removeChild(i.el()) } } initChildren() { const s = this.options_.children; if (s) { const n = this.options_; let e; const t = f.getComponent("Tech"); (e = Array.isArray(s) ? s : Object.keys(s)).concat(Object.keys(this.options_).filter(function (t) { return !e.some(function (e) { return "string" == typeof e ? t === e : t === e.name }) })).map(e => { let t, i; return i = "string" == typeof e ? (t = e, s[t] || this.options_[t] || {}) : (t = e.name, e), { name: t, opts: i } }).filter(e => { e = f.getComponent(e.opts.componentClass || g(e.name)); return e && !t.isTech(e) }).forEach(e => { var t = e.name; let i = e.opts; !1 !== (i = void 0 !== n[t] ? n[t] : i) && ((i = !0 === i ? {} : i).playerOptions = this.options_.playerOptions, e = this.addChild(t, i)) && (this[t] = e) }) } } buildCSSClass() { return "" } ready(e, t = !1) { e && (this.isReady_ ? t ? e.call(this) : this.setTimeout(e, 1) : (this.readyQueue_ = this.readyQueue_ || [], this.readyQueue_.push(e))) } triggerReady() { this.isReady_ = !0, this.setTimeout(function () { var e = this.readyQueue_; this.readyQueue_ = [], e && 0 < e.length && e.forEach(function (e) { e.call(this) }, this), this.trigger("ready") }, 1) } $(e, t) { return $e(e, t || this.contentEl()) } $$(e, t) { return We(e, t || this.contentEl()) } hasClass(e) { return Ce(this.el_, e) } addClass(...e) { ke(this.el_, ...e) } removeClass(...e) { Ie(this.el_, ...e) } toggleClass(e, t) { xe(this.el_, e, t) } show() { this.removeClass("vjs-hidden") } hide() { this.addClass("vjs-hidden") } lockShowing() { this.addClass("vjs-lock-showing") } unlockShowing() { this.removeClass("vjs-lock-showing") } getAttribute(e) { return Pe(this.el_, e) } setAttribute(e, t) { De(this.el_, e, t) } removeAttribute(e) { Oe(this.el_, e) } width(e, t) { return this.dimension("width", e, t) } height(e, t) { return this.dimension("height", e, t) } dimensions(e, t) { this.width(e, !0), this.height(t) } dimension(e, t, i) { var s, n; if (void 0 === t) return this.el_ ? -1 !== (n = (s = this.el_.style[e]).indexOf("px")) ? parseInt(s.slice(0, n), 10) : parseInt(this.el_["offset" + g(e)], 10) : 0; -1 !== ("" + (t = null !== t && t == t ? t : 0)).indexOf("%") || -1 !== ("" + t).indexOf("px") ? this.el_.style[e] = t : this.el_.style[e] = "auto" === t ? "" : t + "px", i || this.trigger("componentresize") } currentDimension(e) { let t = 0; if ("width" !== e && "height" !== e) throw new Error("currentDimension only accepts width or height value"); return t = Ge(this.el_, e), 0 !== (t = parseFloat(t)) && !isNaN(t) || (e = "offset" + g(e), t = this.el_[e]), t } currentDimensions() { return { width: this.currentDimension("width"), height: this.currentDimension("height") } } currentWidth() { return this.currentDimension("width") } currentHeight() { return this.currentDimension("height") } focus() { this.el_.focus() } blur() { this.el_.blur() } handleKeyDown(e) { this.player_ && (n.isEventKey(e, "Tab") || e.stopPropagation(), this.player_.handleKeyDown(e)) } handleKeyPress(e) { this.handleKeyDown(e) } emitTapEvents() { let t = 0, i = null; let s; this.on("touchstart", function (e) { 1 === e.touches.length && (i = { pageX: e.touches[0].pageX, pageY: e.touches[0].pageY }, t = window.performance.now(), s = !0) }), this.on("touchmove", function (e) { var t; (1 < e.touches.length || i && (t = e.touches[0].pageX - i.pageX, e = e.touches[0].pageY - i.pageY, 10 < Math.sqrt(t * t + e * e))) && (s = !1) }); function e() { s = !1 } this.on("touchleave", e), this.on("touchcancel", e), this.on("touchend", function (e) { !(i = null) === s && window.performance.now() - t < 200 && (e.preventDefault(), this.trigger("tap")) }) } enableTouchActivity() { if (this.player() && this.player().reportUserActivity) { const i = m(this.player(), this.player().reportUserActivity); let t; this.on("touchstart", function () { i(), this.clearInterval(t), t = this.setInterval(i, 250) }); var e = function (e) { i(), this.clearInterval(t) }; this.on("touchmove", i), this.on("touchend", e), this.on("touchcancel", e) } } setTimeout(e, t) { var i; return e = m(this, e), this.clearTimersOnDispose_(), i = window.setTimeout(() => { this.setTimeoutIds_.has(i) && this.setTimeoutIds_.delete(i), e() }, t), this.setTimeoutIds_.add(i), i } clearTimeout(e) { return this.setTimeoutIds_.has(e) && (this.setTimeoutIds_.delete(e), window.clearTimeout(e)), e } setInterval(e, t) { e = m(this, e), this.clearTimersOnDispose_(); e = window.setInterval(e, t); return this.setIntervalIds_.add(e), e } clearInterval(e) { return this.setIntervalIds_.has(e) && (this.setIntervalIds_.delete(e), window.clearInterval(e)), e } requestAnimationFrame(e) { var t; return this.clearTimersOnDispose_(), e = m(this, e), t = window.requestAnimationFrame(() => { this.rafIds_.has(t) && this.rafIds_.delete(t), e() }), this.rafIds_.add(t), t } requestNamedAnimationFrame(e, t) { var i; if (!this.namedRafs_.has(e)) return this.clearTimersOnDispose_(), t = m(this, t), i = this.requestAnimationFrame(() => { t(), this.namedRafs_.has(e) && this.namedRafs_.delete(e) }), this.namedRafs_.set(e, i), e } cancelNamedAnimationFrame(e) { this.namedRafs_.has(e) && (this.cancelAnimationFrame(this.namedRafs_.get(e)), this.namedRafs_.delete(e)) } cancelAnimationFrame(e) { return this.rafIds_.has(e) && (this.rafIds_.delete(e), window.cancelAnimationFrame(e)), e } clearTimersOnDispose_() { this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", () => { [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(([e, i]) => { this[e].forEach((e, t) => this[i](t)) }), this.clearingTimersOnDispose_ = !1 })) } static registerComponent(t, e) { if ("string" != typeof t || !t) throw new Error(`Illegal component name, "${t}"; must be a non-empty string.`); var i = f.getComponent("Tech"), i = i && i.isTech(e), s = f === e || f.prototype.isPrototypeOf(e.prototype); if (i || !s) { let e; throw e = i ? "techs must be registered using Tech.registerTech()" : "must be a Component subclass", new Error(`Illegal component, "${t}"; ${e}.`) } t = g(t), f.components_ || (f.components_ = {}); s = f.getComponent("Player"); if ("Player" === t && s && s.players) { const n = s.players; i = Object.keys(n); if (n && 0 < i.length && i.map(e => n[e]).every(Boolean)) throw new Error("Can not register Player component after player has been created.") } return f.components_[t] = e, f.components_[Lt(t)] = e } static getComponent(e) { if (e && f.components_) return f.components_[e] } } function Nt(e, t, i, s) { var n = s, r = i.length - 1; if ("number" != typeof n || n < 0 || r < n) throw new Error(`Failed to execute '${e}' on 'TimeRanges': The index provided (${n}) is non-numeric or out of bounds (0-${r}).`); return i[s][t] } function Rt(e) { let t; return t = void 0 === e || 0 === e.length ? { length: 0, start() { throw new Error("This TimeRanges object is empty") }, end() { throw new Error("This TimeRanges object is empty") } } : { length: e.length, start: Nt.bind(null, "start", 0, e), end: Nt.bind(null, "end", 1, e) }, window.Symbol && window.Symbol.iterator && (t[window.Symbol.iterator] = () => (e || []).values()), t } function Ut(e, t) { return Array.isArray(e) ? Rt(e) : void 0 === e || void 0 === t ? Rt() : Rt([[e, t]]) } f.registerComponent("Component", f); function Bt(e, t) { e = e < 0 ? 0 : e; let i = Math.floor(e % 60), s = Math.floor(e / 60 % 60), n = Math.floor(e / 3600); var r = Math.floor(t / 60 % 60), t = Math.floor(t / 3600); return n = 0 < (n = !isNaN(e) && e !== 1 / 0 ? n : s = i = "-") || 0 < t ? n + ":" : "", s = ((n || 10 <= r) && s < 10 ? "0" + s : s) + ":", i = i < 10 ? "0" + i : i, n + s + i } let Ft = Bt; function jt(e) { Ft = e } function Ht() { Ft = Bt } function Vt(e, t = e) { return Ft(e, t) } var qt = Object.freeze({ __proto__: null, createTimeRanges: Ut, createTimeRange: Ut, setFormatTime: jt, resetFormatTime: Ht, formatTime: Vt }); function zt(t, i) { let s = 0; var n; let r; if (!i) return 0; t && t.length || (t = Ut(0, 0)); for (let e = 0; e < t.length; e++)n = t.start(e), (r = t.end(e)) > i && (r = i), s += r - n; return s / i } function i(e) { if (e instanceof i) return e; "number" == typeof e ? this.code = e : "string" == typeof e ? this.message = e : K(e) && ("number" == typeof e.code && (this.code = e.code), Object.assign(this, e)), this.message || (this.message = i.defaultMessages[this.code] || "") } i.prototype.code = 0, i.prototype.message = "", i.prototype.status = null, i.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"], i.defaultMessages = { 1: "You aborted the media playback", 2: "A network error caused the media download to fail part-way.", 3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.", 4: "The media could not be loaded, either because the server or network failed or because the format is not supported.", 5: "The media is encrypted and we do not have the keys to decrypt it." }; for (let e = 0; e < i.errorTypes.length; e++)i[i.errorTypes[e]] = e, i.prototype[i.errorTypes[e]] = e; var $t = function (e, t) { var i, s = null; try { i = JSON.parse(e, t) } catch (e) { s = e } return [s, i] }; function Wt(e) { return null != e && "function" == typeof e.then } function Gt(e) { Wt(e) && e.then(null, e => { }) } function Xt(s) { return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce((e, t, i) => (s[t] && (e[t] = s[t]), e), { cues: s.cues && Array.prototype.map.call(s.cues, function (e) { return { startTime: e.startTime, endTime: e.endTime, text: e.text, id: e.id } }) }) } var Kt = function (e) { var t = e.$$("track"); const i = Array.prototype.map.call(t, e => e.track); return Array.prototype.map.call(t, function (e) { var t = Xt(e.track); return e.src && (t.src = e.src), t }).concat(Array.prototype.filter.call(e.textTracks(), function (e) { return -1 === i.indexOf(e) }).map(Xt)) }, Yt = function (e, i) { return e.forEach(function (e) { const t = i.addRemoteTextTrack(e).track; !e.src && e.cues && e.cues.forEach(e => t.addCue(e)) }), i.textTracks() }; Xt; const Qt = "vjs-modal-dialog"; class Jt extends f { constructor(e, t) { super(e, t), this.handleKeyDown_ = e => this.handleKeyDown(e), this.close_ = e => this.close(e), this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = !1, this.closeable(!this.options_.uncloseable), this.content(this.options_.content), this.contentEl_ = o("div", { className: Qt + "-content" }, { role: "document" }), this.descEl_ = o("p", { className: Qt + "-description vjs-control-text", id: this.el().getAttribute("aria-describedby") }), we(this.descEl_, this.description()), this.el_.appendChild(this.descEl_), this.el_.appendChild(this.contentEl_) } createEl() { return super.createEl("div", { className: this.buildCSSClass(), tabIndex: -1 }, { "aria-describedby": this.id() + "_description", "aria-hidden": "true", "aria-label": this.label(), role: "dialog" }) } dispose() { this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, super.dispose() } buildCSSClass() { return Qt + " vjs-hidden " + super.buildCSSClass() } label() { return this.localize(this.options_.label || "Modal Window") } description() { let e = this.options_.description || this.localize("This is a modal window."); return this.closeable() && (e += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), e } open() { var e; this.opened_ || (e = this.player(), this.trigger("beforemodalopen"), this.opened_ = !0, !this.options_.fillAlways && (this.hasBeenOpened_ || this.hasBeenFilled_) || this.fill(), this.wasPlaying_ = !e.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && e.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = e.controls(), e.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0) } opened(e) { return "boolean" == typeof e && this[e ? "open" : "close"](), this.opened_ } close() { var e; this.opened_ && (e = this.player(), this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && e.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && e.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary) && this.dispose() } closeable(t) { if ("boolean" == typeof t) { var i, t = this.closeable_ = !!t; let e = this.getChild("closeButton"); t && !e && (i = this.contentEl_, this.contentEl_ = this.el_, e = this.addChild("closeButton", { controlText: "Close Modal Dialog" }), this.contentEl_ = i, this.on(e, "close", this.close_)), !t && e && (this.off(e, "close", this.close_), this.removeChild(e), e.dispose()) } return this.closeable_ } fill() { this.fillWith(this.content()) } fillWith(e) { var t = this.contentEl(), i = t.parentNode, s = t.nextSibling, e = (this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, i.removeChild(t), this.empty(), qe(t, e), this.trigger("modalfill"), s ? i.insertBefore(t, s) : i.appendChild(t), this.getChild("closeButton")); e && i.appendChild(e.el_) } empty() { this.trigger("beforemodalempty"), je(this.contentEl()), this.trigger("modalempty") } content(e) { return "undefined" != typeof e && (this.content_ = e), this.content_ } conditionalFocus_() { var e = document.activeElement, t = this.player_.el_; this.previouslyActiveEl_ = null, !t.contains(e) && t !== e || (this.previouslyActiveEl_ = e, this.focus()) } conditionalBlur_() { this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null) } handleKeyDown(e) { if (e.stopPropagation(), n.isEventKey(e, "Escape") && this.closeable()) e.preventDefault(), this.close(); else if (n.isEventKey(e, "Tab")) { var i = this.focusableEls_(), s = this.el_.querySelector(":focus"); let t; for (let e = 0; e < i.length; e++)if (s === i[e]) { t = e; break } document.activeElement === this.el_ && (t = 0), e.shiftKey && 0 === t ? (i[i.length - 1].focus(), e.preventDefault()) : e.shiftKey || t !== i.length - 1 || (i[0].focus(), e.preventDefault()) } } focusableEls_() { var e = this.el_.querySelectorAll("*"); return Array.prototype.filter.call(e, e => (e instanceof window.HTMLAnchorElement || e instanceof window.HTMLAreaElement) && e.hasAttribute("href") || (e instanceof window.HTMLInputElement || e instanceof window.HTMLSelectElement || e instanceof window.HTMLTextAreaElement || e instanceof window.HTMLButtonElement) && !e.hasAttribute("disabled") || e instanceof window.HTMLIFrameElement || e instanceof window.HTMLObjectElement || e instanceof window.HTMLEmbedElement || e.hasAttribute("tabindex") && -1 !== e.getAttribute("tabindex") || e.hasAttribute("contenteditable")) } } Jt.prototype.options_ = { pauseOnOpen: !0, temporary: !0 }, f.registerComponent("ModalDialog", Jt); class Zt extends yt { constructor(t = []) { super(), this.tracks_ = [], Object.defineProperty(this, "length", { get() { return this.tracks_.length } }); for (let e = 0; e < t.length; e++)this.addTrack(t[e]) } addTrack(e) { const t = this.tracks_.length; "" + t in this || Object.defineProperty(this, t, { get() { return this.tracks_[t] } }), -1 === this.tracks_.indexOf(e) && (this.tracks_.push(e), this.trigger({ track: e, type: "addtrack", target: this })), e.labelchange_ = () => { this.trigger({ track: e, type: "labelchange", target: this }) }, vt(e) && e.addEventListener("labelchange", e.labelchange_) } removeTrack(i) { let s; for (let e = 0, t = this.length; e < t; e++)if (this[e] === i) { (s = this[e]).off && s.off(), this.tracks_.splice(e, 1); break } s && this.trigger({ track: s, type: "removetrack", target: this }) } getTrackById(i) { let s = null; for (let e = 0, t = this.length; e < t; e++) { var n = this[e]; if (n.id === i) { s = n; break } } return s } } for (const Hu in Zt.prototype.allowedEvents_ = { change: "change", addtrack: "addtrack", removetrack: "removetrack", labelchange: "labelchange" }) Zt.prototype["on" + Hu] = null; function ei(t, i) { for (let e = 0; e < t.length; e++)Object.keys(t[e]).length && i.id !== t[e].id && (t[e].enabled = !1) } function ti(t, i) { for (let e = 0; e < t.length; e++)Object.keys(t[e]).length && i.id !== t[e].id && (t[e].selected = !1) } class ii extends Zt { addTrack(e) { super.addTrack(e), this.queueChange_ || (this.queueChange_ = () => this.queueTrigger("change")), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange")), e.addEventListener("modechange", this.queueChange_); -1 === ["metadata", "chapters"].indexOf(e.kind) && e.addEventListener("modechange", this.triggerSelectedlanguagechange_) } removeTrack(e) { super.removeTrack(e), e.removeEventListener && (this.queueChange_ && e.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_) && e.removeEventListener("modechange", this.triggerSelectedlanguagechange_) } } class si { constructor(e) { si.prototype.setCues_.call(this, e), Object.defineProperty(this, "length", { get() { return this.length_ } }) } setCues_(e) { var t = this.length || 0; let i = 0; function s(e) { "" + e in this || Object.defineProperty(this, "" + e, { get() { return this.cues_[e] } }) } var n = e.length; this.cues_ = e, this.length_ = e.length; if (t < n) for (i = t; i < n; i++)s.call(this, i) } getCueById(i) { let s = null; for (let e = 0, t = this.length; e < t; e++) { var n = this[e]; if (n.id === i) { s = n; break } } return s } } const ni = { alternative: "alternative", captions: "captions", main: "main", sign: "sign", subtitles: "subtitles", commentary: "commentary" }, ri = { alternative: "alternative", descriptions: "descriptions", main: "main", "main-desc": "main-desc", translation: "translation", commentary: "commentary" }, ai = { subtitles: "subtitles", captions: "captions", descriptions: "descriptions", chapters: "chapters", metadata: "metadata" }, oi = { disabled: "disabled", hidden: "hidden", showing: "showing" }; class li extends yt { constructor(e = {}) { super(); const t = { id: e.id || "vjs_track_" + it++, kind: e.kind || "", language: e.language || "" }; let i = e.label || ""; for (const s in t) Object.defineProperty(this, s, { get() { return t[s] }, set() { } }); Object.defineProperty(this, "label", { get() { return i }, set(e) { e !== i && (i = e, this.trigger("labelchange")) } }) } } function di(e) { var t = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"], i = document.createElement("a"), s = (i.href = e, {}); for (let e = 0; e < t.length; e++)s[t[e]] = i[t[e]]; return "http:" === s.protocol && (s.host = s.host.replace(/:80$/, "")), "https:" === s.protocol && (s.host = s.host.replace(/:443$/, "")), s.protocol || (s.protocol = window.location.protocol), s.host || (s.host = window.location.host), s } function hi(e) { var t; return e.match(/^https?:\/\//) || ((t = document.createElement("a")).href = e, e = t.href), e } function ui(e, t = window.location) { return (":" === (e = di(e)).protocol ? t : e).protocol + e.host !== t.protocol + t.host } const ci = function (e) { if ("string" == typeof e) { e = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/.exec(e); if (e) return e.pop().toLowerCase() } return "" }; var pi = Object.freeze({ __proto__: null, parseUrl: di, getAbsoluteURL: hi, getFileExtension: ci, isCrossOrigin: ui }), mi = "undefined" != typeof window ? window : "undefined" != typeof Ot ? Ot : "undefined" != typeof self ? self : {}, gi = mi, fi = Mt(function (e) { function t() { return e.exports = t = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i, s = arguments[t]; for (i in s) Object.prototype.hasOwnProperty.call(s, i) && (e[i] = s[i]) } return e }, e.exports.__esModule = !0, e.exports.default = e.exports, t.apply(this, arguments) } e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports }), yi = (mi = fi) && mi.__esModule && Object.prototype.hasOwnProperty.call(mi, "default") ? mi.default : mi, _i = function (e) { var t; return !!e && ("[object Function]" === (t = vi.call(e)) || "function" == typeof e && "[object RegExp]" !== t || "undefined" != typeof window && (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt)) }, vi = Object.prototype.toString; ki.httpHandler = function (s, n) { return void 0 === n && (n = !1), function (e, t, i) { if (e) s(e); else if (400 <= t.statusCode && t.statusCode <= 599) { e = i; if (n) if (gi.TextDecoder) { t = function (e) { void 0 === e && (e = ""); return e.toLowerCase().split(";").reduce(function (e, t) { var t = t.split("="), i = t[0], t = t[1]; return "charset" === i.trim() ? t.trim() : e }, "utf-8") }(t.headers && t.headers["content-type"]); try { e = new TextDecoder(t).decode(i) } catch (e) { } } else e = String.fromCharCode.apply(null, new Uint8Array(i)); s({ cause: e }) } else s(null, i) } }; for (var bi = function (e) { var s = {}; return e && e.trim().split("\n").forEach(function (e) { var t = e.indexOf(":"), i = e.slice(0, t).trim().toLowerCase(), e = e.slice(t + 1).trim(); "undefined" == typeof s[i] ? s[i] = e : Array.isArray(s[i]) ? s[i].push(e) : s[i] = [s[i], e] }), s }, Ti = ki, mi = ki, Si = (ki.XMLHttpRequest = gi.XMLHttpRequest || function () { }, ki.XDomainRequest = "withCredentials" in new ki.XMLHttpRequest ? ki.XMLHttpRequest : gi.XDomainRequest, ["get", "put", "post", "patch", "head", "delete"]), wi = function (s) { ki["delete" === s ? "del" : s] = function (e, t, i) { return (t = Ci(e, t, i)).method = s.toUpperCase(), Ii(t) } }, Ei = 0; Ei < Si.length; Ei++)wi(Si[Ei]); function Ci(e, t, i) { var s = e; return _i(t) ? (i = t, "string" == typeof e && (s = { uri: e })) : s = fi({}, t, { uri: e }), s.callback = i, s } function ki(e, t, i) { return Ii(t = Ci(e, t, i)) } function Ii(s) { if ("undefined" == typeof s.callback) throw new Error("callback argument missing"); var n = !1, r = function (e, t, i) { n || (n = !0, s.callback(e, t, i)) }; function a() { var e = void 0, e = d.response || d.responseText || function (e) { try { if ("document" === e.responseType) return e.responseXML; var t = e.responseXML && "parsererror" === e.responseXML.documentElement.nodeName; if ("" === e.responseType && !t) return e.responseXML } catch (e) { } return null }(d); if (g) try { e = JSON.parse(e) } catch (e) { } return e } function t(e) { return clearTimeout(l), (e = e instanceof Error ? e : new Error("" + (e || "Unknown XMLHttpRequest Error"))).statusCode = 0, r(e, f) } function e() { var e, t, i; if (!o) return clearTimeout(l), e = s.useXDR && void 0 === d.status ? 200 : 1223 === d.status ? 204 : d.status, t = f, i = null, 0 !== e ? (t = { body: a(), statusCode: e, method: u, headers: {}, url: h, rawRequest: d }, d.getAllResponseHeaders && (t.headers = bi(d.getAllResponseHeaders()))) : i = new Error("Internal XMLHttpRequest Error"), r(i, t, t.body) } var i, o, l, d = s.xhr || null, h = (d = d || new (s.cors || s.useXDR ? ki.XDomainRequest : ki.XMLHttpRequest)).url = s.uri || s.url, u = d.method = s.method || "GET", c = s.body || s.data, p = d.headers = s.headers || {}, m = !!s.sync, g = !1, f = { body: void 0, headers: {}, statusCode: 0, method: u, url: h, rawRequest: d }; if ("json" in s && !1 !== s.json && (g = !0, p.accept || p.Accept || (p.Accept = "application/json"), "GET" !== u) && "HEAD" !== u && (p["content-type"] || p["Content-Type"] || (p["Content-Type"] = "application/json"), c = JSON.stringify(!0 === s.json ? c : s.json)), d.onreadystatechange = function () { 4 === d.readyState && setTimeout(e, 0) }, d.onload = e, d.onerror = t, d.onprogress = function () { }, d.onabort = function () { o = !0 }, d.ontimeout = t, d.open(u, h, !m, s.username, s.password), m || (d.withCredentials = !!s.withCredentials), !m && 0 < s.timeout && (l = setTimeout(function () { var e; o || (o = !0, d.abort("timeout"), (e = new Error("XMLHttpRequest timeout")).code = "ETIMEDOUT", t(e)) }, s.timeout)), d.setRequestHeader) for (i in p) p.hasOwnProperty(i) && d.setRequestHeader(i, p[i]); else if (s.headers && !function (e) { for (var t in e) if (e.hasOwnProperty(t)) return; return 1 }(s.headers)) throw new Error("Headers cannot be set on an XDomainRequest object"); return "responseType" in s && (d.responseType = s.responseType), "beforeSend" in s && "function" == typeof s.beforeSend && s.beforeSend(d), d.send(c || null), d } Ti.default = mi; function xi(e, t) { var i = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder()); const s = []; i.oncue = function (e) { t.addCue(e) }, i.onparsingerror = function (e) { s.push(e) }, i.onflush = function () { t.trigger({ type: "loadeddata", target: t }) }, i.parse(e), 0 < s.length && (window.console && window.console.groupCollapsed && window.console.groupCollapsed("Text Track parsing errors for " + t.src), s.forEach(e => d.error(e)), window.console) && window.console.groupEnd && window.console.groupEnd(), i.flush() } function Ai(e, s) { var t = { uri: e }; (e = ui(e)) && (t.cors = e), (e = "use-credentials" === s.tech_.crossOrigin()) && (t.withCredentials = e), Ti(t, m(this, function (e, t, i) { if (e) return d.error(e, t); s.loaded_ = !0, "function" != typeof window.WebVTT ? s.tech_ && s.tech_.any(["vttjsloaded", "vttjserror"], e => { if ("vttjserror" !== e.type) return xi(i, s); d.error("vttjs failed to load, stopping trying to process " + s.src) }) : xi(i, s) })) } class Li extends li { constructor(e = {}) { if (!e.tech) throw new Error("A tech was not provided."); e = h(e, { kind: ai[e.kind] || "subtitles", language: e.language || e.srclang || "" }); let t = oi[e.mode] || "disabled"; const i = e.default, s = ("metadata" !== e.kind && "chapters" !== e.kind || (t = "hidden"), super(e), this.tech_ = e.tech, this.cues_ = [], this.activeCues_ = [], this.preload_ = !1 !== this.tech_.preloadTextTracks, new si(this.cues_)), r = new si(this.activeCues_); let a = !1; this.timeupdateHandler = m(this, function (e = {}) { this.tech_.isDisposed() || (this.tech_.isReady_ && (this.activeCues = this.activeCues, a) && (this.trigger("cuechange"), a = !1), "timeupdate" !== e.type && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler))) }); this.tech_.one("dispose", () => { this.stopTracking() }), "disabled" !== t && this.startTracking(), Object.defineProperties(this, { default: { get() { return i }, set() { } }, mode: { get() { return t }, set(e) { oi[e] && t !== e && (t = e, this.preload_ || "disabled" === t || 0 !== this.cues.length || Ai(this.src, this), this.stopTracking(), "disabled" !== t && this.startTracking(), this.trigger("modechange")) } }, cues: { get() { return this.loaded_ ? s : null }, set() { } }, activeCues: { get() { if (!this.loaded_) return null; if (0 !== this.cues.length) { var i = this.tech_.currentTime(), s = []; for (let e = 0, t = this.cues.length; e < t; e++) { var n = this.cues[e]; n.startTime <= i && n.endTime >= i && s.push(n) } if (a = !1, s.length !== this.activeCues_.length) a = !0; else for (let e = 0; e < s.length; e++)-1 === this.activeCues_.indexOf(s[e]) && (a = !0); this.activeCues_ = s, r.setCues_(this.activeCues_) } return r }, set() { } } }), e.src ? (this.src = e.src, this.preload_ || (this.loaded_ = !0), (this.preload_ || "subtitles" !== e.kind && "captions" !== e.kind) && Ai(this.src, this)) : this.loaded_ = !0 } startTracking() { this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler) } stopTracking() { this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler) } addCue(e) { let t = e; if (window.vttjs && !(e instanceof window.vttjs.VTTCue)) { t = new window.vttjs.VTTCue(e.startTime, e.endTime, e.text); for (const s in e) s in t || (t[s] = e[s]); t.id = e.id, t.originalCue_ = e } var i = this.tech_.textTracks(); for (let e = 0; e < i.length; e++)i[e] !== this && i[e].removeCue(t); this.cues_.push(t), this.cues.setCues_(this.cues_) } removeCue(e) { let t = this.cues_.length; for (; t--;) { var i = this.cues_[t]; if (i === e || i.originalCue_ && i.originalCue_ === e) { this.cues_.splice(t, 1), this.cues.setCues_(this.cues_); break } } } } Li.prototype.allowedEvents_ = { cuechange: "cuechange" }; class Pi extends li { constructor(e = {}) { e = h(e, { kind: ri[e.kind] || "" }); super(e); let t = !1; Object.defineProperty(this, "enabled", { get() { return t }, set(e) { "boolean" == typeof e && e !== t && (t = e, this.trigger("enabledchange")) } }), e.enabled && (this.enabled = e.enabled), this.loaded_ = !0 } } class Di extends li { constructor(e = {}) { e = h(e, { kind: ni[e.kind] || "" }); super(e); let t = !1; Object.defineProperty(this, "selected", { get() { return t }, set(e) { "boolean" == typeof e && e !== t && (t = e, this.trigger("selectedchange")) } }), e.selected && (this.selected = e.selected) } } class Oi extends yt { constructor(e = {}) { super(); let t; const i = new Li(e); this.kind = i.kind, this.src = i.src, this.srclang = i.language, this.label = i.label, this.default = i.default, Object.defineProperties(this, { readyState: { get() { return t } }, track: { get() { return i } } }), t = Oi.NONE, i.addEventListener("loadeddata", () => { t = Oi.LOADED, this.trigger({ type: "load", target: this }) }) } } Oi.prototype.allowedEvents_ = { load: "load" }, Oi.NONE = 0, Oi.LOADING = 1, Oi.LOADED = 2, Oi.ERROR = 3; const Mi = { audio: { ListClass: class extends Zt { constructor(t = []) { for (let e = t.length - 1; 0 <= e; e--)if (t[e].enabled) { ei(t, t[e]); break } super(t), this.changing_ = !1 } addTrack(e) { e.enabled && ei(this, e), super.addTrack(e), e.addEventListener && (e.enabledChange_ = () => { this.changing_ || (this.changing_ = !0, ei(this, e), this.changing_ = !1, this.trigger("change")) }, e.addEventListener("enabledchange", e.enabledChange_)) } removeTrack(e) { super.removeTrack(e), e.removeEventListener && e.enabledChange_ && (e.removeEventListener("enabledchange", e.enabledChange_), e.enabledChange_ = null) } }, TrackClass: Pi, capitalName: "Audio" }, video: { ListClass: class extends Zt { constructor(t = []) { for (let e = t.length - 1; 0 <= e; e--)if (t[e].selected) { ti(t, t[e]); break } super(t), this.changing_ = !1, Object.defineProperty(this, "selectedIndex", { get() { for (let e = 0; e < this.length; e++)if (this[e].selected) return e; return -1 }, set() { } }) } addTrack(e) { e.selected && ti(this, e), super.addTrack(e), e.addEventListener && (e.selectedChange_ = () => { this.changing_ || (this.changing_ = !0, ti(this, e), this.changing_ = !1, this.trigger("change")) }, e.addEventListener("selectedchange", e.selectedChange_)) } removeTrack(e) { super.removeTrack(e), e.removeEventListener && e.selectedChange_ && (e.removeEventListener("selectedchange", e.selectedChange_), e.selectedChange_ = null) } }, TrackClass: Di, capitalName: "Video" }, text: { ListClass: ii, TrackClass: Li, capitalName: "Text" } }, Ni = (Object.keys(Mi).forEach(function (e) { Mi[e].getterName = e + "Tracks", Mi[e].privateName = e + "Tracks_" }), { remoteText: { ListClass: ii, TrackClass: Li, capitalName: "RemoteText", getterName: "remoteTextTracks", privateName: "remoteTextTracks_" }, remoteTextEl: { ListClass: class { constructor(i = []) { this.trackElements_ = [], Object.defineProperty(this, "length", { get() { return this.trackElements_.length } }); for (let e = 0, t = i.length; e < t; e++)this.addTrackElement_(i[e]) } addTrackElement_(e) { const t = this.trackElements_.length; "" + t in this || Object.defineProperty(this, t, { get() { return this.trackElements_[t] } }), -1 === this.trackElements_.indexOf(e) && this.trackElements_.push(e) } getTrackElementByTrack_(i) { let s; for (let e = 0, t = this.trackElements_.length; e < t; e++)if (i === this.trackElements_[e].track) { s = this.trackElements_[e]; break } return s } removeTrackElement_(i) { for (let e = 0, t = this.trackElements_.length; e < t; e++)if (i === this.trackElements_[e]) { this.trackElements_[e].track && "function" == typeof this.trackElements_[e].track.off && this.trackElements_[e].track.off(), "function" == typeof this.trackElements_[e].off && this.trackElements_[e].off(), this.trackElements_.splice(e, 1); break } } }, TrackClass: Oi, capitalName: "RemoteTextTrackEls", getterName: "remoteTextTrackEls", privateName: "remoteTextTrackEls_" } }), a = Object.assign({}, Mi, Ni); Ni.names = Object.keys(Ni), Mi.names = Object.keys(Mi), a.names = [].concat(Ni.names).concat(Mi.names); var mi = "undefined" != typeof Ot ? Ot : "undefined" != typeof window ? window : {}, Ri = "undefined" != typeof document ? document : (Ri = mi["__GLOBAL_DOCUMENT_CACHE@4"]) || (mi["__GLOBAL_DOCUMENT_CACHE@4"] = {}), Ot = Ri, Ui = Object.create || function (e) { if (1 !== arguments.length) throw new Error("Object.create shim only accepts one parameter."); return Bi.prototype = e, new Bi }; function Bi() { } function Fi(e, t) { this.name = "ParsingError", this.code = e.code, this.message = t || e.message } function ji(e) { function t(e, t, i, s) { return 3600 * (0 | e) + 60 * (0 | t) + (0 | i) + (0 | s) / 1e3 } e = e.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/); return e ? e[3] ? t(e[1], e[2], e[3].replace(":", ""), e[4]) : 59 < e[1] ? t(e[1], e[2], 0, e[4]) : t(0, e[1], e[2], e[4]) : null } function Hi() { this.values = Ui(null) } function Vi(e, t, i, s) { var n, r, a = s ? e.split(s) : [e]; for (n in a) "string" == typeof a[n] && 2 === (r = a[n].split(i)).length && t(r[0].trim(), r[1].trim()) } ((Fi.prototype = Ui(Error.prototype)).constructor = Fi).Errors = { BadSignature: { code: 0, message: "Malformed WebVTT signature." }, BadTimeStamp: { code: 1, message: "Malformed time stamp." } }, Hi.prototype = { set: function (e, t) { this.get(e) || "" === t || (this.values[e] = t) }, get: function (e, t, i) { return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t }, has: function (e) { return e in this.values }, alt: function (e, t, i) { for (var s = 0; s < i.length; ++s)if (t === i[s]) { this.set(e, t); break } }, integer: function (e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) }, percent: function (e, t) { return !!(t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && 0 <= (t = parseFloat(t)) && t <= 100) && (this.set(e, t), !0) } }; var qi = Ot.createElement && Ot.createElement("textarea"), zi = { c: "span", i: "i", b: "b", u: "u", ruby: "ruby", rt: "rt", v: "span", lang: "span" }, $i = { white: "rgba(255,255,255,1)", lime: "rgba(0,255,0,1)", cyan: "rgba(0,255,255,1)", red: "rgba(255,0,0,1)", yellow: "rgba(255,255,0,1)", magenta: "rgba(255,0,255,1)", blue: "rgba(0,0,255,1)", black: "rgba(0,0,0,1)" }, Wi = { v: "title", lang: "lang" }, Gi = { rt: "ruby" }; function Xi(e, t) { for (var i, s, n, r, a, o, l = e.document.createElement("div"), d = l, h = []; null !== (o = void 0, o = t ? (o = (o = t.match(/^([^<]*)(<[^>]*>?)?/))[1] || o[2], t = t.substr(o.length), o) : null);)"<" === o[0] ? "/" === o[1] ? h.length && h[h.length - 1] === o.substr(2).replace(">", "") && (h.pop(), d = d.parentNode) : (s = ji(o.substr(1, o.length - 2))) ? (i = e.document.createProcessingInstruction("timestamp", s), d.appendChild(i)) : (s = o.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/)) && (n = s[1], r = s[3], a = void 0, a = zi[n], i = a ? (a = e.document.createElement(a), (n = Wi[n]) && r && (a[n] = r.trim()), a) : null) && (n = d, Gi[(r = i).localName] && Gi[r.localName] !== n.localName || (s[2] && ((a = s[2].split(".")).forEach(function (e) { var t = /^bg_/.test(e), e = t ? e.slice(3) : e; $i.hasOwnProperty(e) && (e = $i[e], i.style[t ? "background-color" : "color"] = e) }), i.className = a.join(" ")), h.push(s[1]), d.appendChild(i), d = i)) : d.appendChild(e.document.createTextNode((r = o, qi.innerHTML = r, r = qi.textContent, qi.textContent = "", r))); return l } var Ki = [[1470, 1470], [1472, 1472], [1475, 1475], [1478, 1478], [1488, 1514], [1520, 1524], [1544, 1544], [1547, 1547], [1549, 1549], [1563, 1563], [1566, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1984, 2026], [2036, 2037], [2042, 2042], [2048, 2069], [2074, 2074], [2084, 2084], [2088, 2088], [2096, 2110], [2112, 2136], [2142, 2142], [2208, 2208], [2210, 2220], [8207, 8207], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64449], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [67584, 67589], [67592, 67592], [67594, 67637], [67639, 67640], [67644, 67644], [67647, 67669], [67671, 67679], [67840, 67867], [67872, 67897], [67903, 67903], [67968, 68023], [68030, 68031], [68096, 68096], [68112, 68115], [68117, 68119], [68121, 68147], [68160, 68167], [68176, 68184], [68192, 68223], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68479], [68608, 68680], [126464, 126467], [126469, 126495], [126497, 126498], [126500, 126500], [126503, 126503], [126505, 126514], [126516, 126519], [126521, 126521], [126523, 126523], [126530, 126530], [126535, 126535], [126537, 126537], [126539, 126539], [126541, 126543], [126545, 126546], [126548, 126548], [126551, 126551], [126553, 126553], [126555, 126555], [126557, 126557], [126559, 126559], [126561, 126562], [126564, 126564], [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], [126590, 126590], [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [1114109, 1114109]]; function Yi(e) { var t = [], i = ""; if (e && e.childNodes) for (r(t, e); i = function e(t) { var i, s, n; return t && t.length ? (s = (i = t.pop()).textContent || i.innerText) ? (n = s.match(/^.*(\n|\r)/)) ? n[t.length = 0] : s : "ruby" === i.tagName ? e(t) : i.childNodes ? (r(t, i), e(t)) : void 0 : null }(t);)for (var s = 0; s < i.length; s++)if (function (e) { for (var t = 0; t < Ki.length; t++) { var i = Ki[t]; if (e >= i[0] && e <= i[1]) return 1 } }(i.charCodeAt(s))) return "rtl"; return "ltr"; function r(e, t) { for (var i = t.childNodes.length - 1; 0 <= i; i--)e.push(t.childNodes[i]) } } function Qi() { } function Ji(e, t, i) { Qi.call(this), this.cue = t, this.cueDiv = Xi(e, t.text); var s = { color: "rgba(255, 255, 255, 1)", backgroundColor: "rgba(0, 0, 0, 0.8)", position: "relative", left: 0, right: 0, top: 0, bottom: 0, display: "inline", writingMode: "" === t.vertical ? "horizontal-tb" : "lr" === t.vertical ? "vertical-lr" : "vertical-rl", unicodeBidi: "plaintext" }, n = (this.applyStyles(s, this.cueDiv), this.div = e.document.createElement("div"), s = { direction: Yi(this.cueDiv), writingMode: "" === t.vertical ? "horizontal-tb" : "lr" === t.vertical ? "vertical-lr" : "vertical-rl", unicodeBidi: "plaintext", textAlign: "middle" === t.align ? "center" : t.align, font: i.font, whiteSpace: "pre-line", position: "absolute" }, this.applyStyles(s), this.div.appendChild(this.cueDiv), 0); switch (t.positionAlign) { case "start": n = t.position; break; case "center": n = t.position - t.size / 2; break; case "end": n = t.position - t.size }"" === t.vertical ? this.applyStyles({ left: this.formatStyle(n, "%"), width: this.formatStyle(t.size, "%") }) : this.applyStyles({ top: this.formatStyle(n, "%"), height: this.formatStyle(t.size, "%") }), this.move = function (e) { this.applyStyles({ top: this.formatStyle(e.top, "px"), bottom: this.formatStyle(e.bottom, "px"), left: this.formatStyle(e.left, "px"), right: this.formatStyle(e.right, "px"), height: this.formatStyle(e.height, "px"), width: this.formatStyle(e.width, "px") }) } } function y(e) { var t, i, s, n; e.div && (t = e.div.offsetHeight, i = e.div.offsetWidth, s = e.div.offsetTop, n = (n = (n = e.div.childNodes) && n[0]) && n.getClientRects && n.getClientRects(), e = e.div.getBoundingClientRect(), n = n ? Math.max(n[0] && n[0].height || 0, e.height / n.length) : 0), this.left = e.left, this.right = e.right, this.top = e.top || s, this.height = e.height || t, this.bottom = e.bottom || s + (e.height || t), this.width = e.width || i, this.lineHeight = void 0 !== n ? n : e.lineHeight } function Zi(e, t, o, l) { var i, s = new y(t), n = t.cue, r = function (e) { if ("number" == typeof e.line && (e.snapToLines || 0 <= e.line && e.line <= 100)) return e.line; if (!e.track || !e.track.textTrackList || !e.track.textTrackList.mediaElement) return -1; for (var t = e.track, i = t.textTrackList, s = 0, n = 0; n < i.length && i[n] !== t; n++)"showing" === i[n].mode && s++; return -1 * ++s }(n), a = []; if (n.snapToLines) { switch (n.vertical) { case "": a = ["+y", "-y"], i = "height"; break; case "rl": a = ["+x", "-x"], i = "width"; break; case "lr": a = ["-x", "+x"], i = "width" }var d = s.lineHeight, h = d * Math.round(r), u = o[i] + d, c = a[0]; Math.abs(h) > u && (h = h < 0 ? -1 : 1, h *= Math.ceil(u / d) * d), r < 0 && (h += "" === n.vertical ? o.height : o.width, a = a.reverse()), s.move(c, h) } else { var p = s.lineHeight / o.height * 100; switch (n.lineAlign) { case "center": r -= p / 2; break; case "end": r -= p }switch (n.vertical) { case "": t.applyStyles({ top: t.formatStyle(r, "%") }); break; case "rl": t.applyStyles({ left: t.formatStyle(r, "%") }); break; case "lr": t.applyStyles({ right: t.formatStyle(r, "%") }) }a = ["+y", "-x", "+x", "-y"], s = new y(t) } u = function (e, t) { for (var i, s = new y(e), n = 1, r = 0; r < t.length; r++) { for (; e.overlapsOppositeAxis(o, t[r]) || e.within(o) && e.overlapsAny(l);)e.move(t[r]); if (e.within(o)) return e; var a = e.intersectPercentage(o); a < n && (i = new y(e), n = a), e = new y(s) } return i || s }(s, a); t.move(u.toCSSCompatValues(o)) } function es() { } Qi.prototype.applyStyles = function (e, t) { for (var i in t = t || this.div, e) e.hasOwnProperty(i) && (t.style[i] = e[i]) }, Qi.prototype.formatStyle = function (e, t) { return 0 === e ? 0 : e + t }, (Ji.prototype = Ui(Qi.prototype)).constructor = Ji, y.prototype.move = function (e, t) { switch (t = void 0 !== t ? t : this.lineHeight, e) { case "+x": this.left += t, this.right += t; break; case "-x": this.left -= t, this.right -= t; break; case "+y": this.top += t, this.bottom += t; break; case "-y": this.top -= t, this.bottom -= t } }, y.prototype.overlaps = function (e) { return this.left < e.right && this.right > e.left && this.top < e.bottom && this.bottom > e.top }, y.prototype.overlapsAny = function (e) { for (var t = 0; t < e.length; t++)if (this.overlaps(e[t])) return !0; return !1 }, y.prototype.within = function (e) { return this.top >= e.top && this.bottom <= e.bottom && this.left >= e.left && this.right <= e.right }, y.prototype.overlapsOppositeAxis = function (e, t) { switch (t) { case "+x": return this.left < e.left; case "-x": return this.right > e.right; case "+y": return this.top < e.top; case "-y": return this.bottom > e.bottom } }, y.prototype.intersectPercentage = function (e) { return Math.max(0, Math.min(this.right, e.right) - Math.max(this.left, e.left)) * Math.max(0, Math.min(this.bottom, e.bottom) - Math.max(this.top, e.top)) / (this.height * this.width) }, y.prototype.toCSSCompatValues = function (e) { return { top: this.top - e.top, bottom: e.bottom - this.bottom, left: this.left - e.left, right: e.right - this.right, height: this.height, width: this.width } }, y.getSimpleBoxPosition = function (e) { var t = e.div ? e.div.offsetHeight : e.tagName ? e.offsetHeight : 0, i = e.div ? e.div.offsetWidth : e.tagName ? e.offsetWidth : 0, s = e.div ? e.div.offsetTop : e.tagName ? e.offsetTop : 0; return { left: (e = e.div ? e.div.getBoundingClientRect() : e.tagName ? e.getBoundingClientRect() : e).left, right: e.right, top: e.top || s, height: e.height || t, bottom: e.bottom || s + (e.height || t), width: e.width || i } }, es.StringDecoder = function () { return { decode: function (e) { if (!e) return ""; if ("string" != typeof e) throw new Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } } }, es.convertCueToDOMTree = function (e, t) { return e && t ? Xi(e, t) : null }; es.processCues = function (e, t, i) { if (!e || !t || !i) return null; for (; i.firstChild;)i.removeChild(i.firstChild); var s = e.document.createElement("div"); if (s.style.position = "absolute", s.style.left = "0", s.style.right = "0", s.style.top = "0", s.style.bottom = "0", s.style.margin = "1.5%", i.appendChild(s), function (e) { for (var t = 0; t < e.length; t++)if (e[t].hasBeenReset || !e[t].displayState) return 1 }(t)) for (var n, r, a = [], o = y.getSimpleBoxPosition(s), l = { font: Math.round(.05 * o.height * 100) / 100 + "px sans-serif" }, d = 0; d < t.length; d++)r = t[d], n = new Ji(e, r, l), s.appendChild(n.div), Zi(0, n, o, a), r.displayState = n.div, a.push(y.getSimpleBoxPosition(n)); else for (var h = 0; h < t.length; h++)s.appendChild(t[h].displayState) }, (es.Parser = function (e, t, i) { i || (i = t, t = {}), t = t || {}, this.window = e, this.vttjs = t, this.state = "INITIAL", this.buffer = "", this.decoder = i || new TextDecoder("utf8"), this.regionList = [] }).prototype = { reportOrThrowError: function (e) { if (!(e instanceof Fi)) throw e; this.onparsingerror && this.onparsingerror(e) }, parse: function (e) { var s = this; function t() { for (var e = s.buffer, t = 0; t < e.length && "\r" !== e[t] && "\n" !== e[t];)++t; var i = e.substr(0, t); return "\r" === e[t] && ++t, "\n" === e[t] && ++t, s.buffer = e.substr(t), i } function i(e) { e.match(/X-TIMESTAMP-MAP/) ? Vi(e, function (e, t) { var i; "X-TIMESTAMP-MAP" === e && (e = t, i = new Hi, Vi(e, function (e, t) { switch (e) { case "MPEGT": i.integer(e + "S", t); break; case "LOCA": i.set(e + "L", ji(t)) } }, /[^\d]:/, /,/), s.ontimestampmap) && s.ontimestampmap({ MPEGTS: i.get("MPEGTS"), LOCAL: i.get("LOCAL") }) }, /=/) : Vi(e, function (e, t) { var n; "Region" === e && (e = t, n = new Hi, Vi(e, function (e, t) { switch (e) { case "id": n.set(e, t); break; case "width": n.percent(e, t); break; case "lines": n.integer(e, t); break; case "regionanchor": case "viewportanchor": var i, s = t.split(","); 2 === s.length && ((i = new Hi).percent("x", s[0]), i.percent("y", s[1]), i.has("x") && i.has("y")) && (n.set(e + "X", i.get("x")), n.set(e + "Y", i.get("y"))); break; case "scroll": n.alt(e, t, ["up"]) } }, /=/, /\s/), n.has("id")) && ((e = new (s.vttjs.VTTRegion || s.window.VTTRegion)).width = n.get("width", 100), e.lines = n.get("lines", 3), e.regionAnchorX = n.get("regionanchorX", 0), e.regionAnchorY = n.get("regionanchorY", 100), e.viewportAnchorX = n.get("viewportanchorX", 0), e.viewportAnchorY = n.get("viewportanchorY", 100), e.scroll = n.get("scroll", ""), s.onregion && s.onregion(e), s.regionList.push({ id: n.get("id"), region: e })) }, /:/) } e && (s.buffer += s.decoder.decode(e, { stream: !0 })); try { if ("INITIAL" === s.state) { if (!/\r\n|\n/.test(s.buffer)) return this; var n, r = (n = t()).match(/^WEBVTT([ \t].*)?$/); if (!r || !r[0]) throw new Fi(Fi.Errors.BadSignature); s.state = "HEADER" } for (var a = !1; s.buffer;) { if (!/\r\n|\n/.test(s.buffer)) return this; switch (a ? a = !1 : n = t(), s.state) { case "HEADER": /:/.test(n) ? i(n) : n || (s.state = "ID"); continue; case "NOTE": n || (s.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(n)) { s.state = "NOTE"; break } if (!n) continue; s.cue = new (s.vttjs.VTTCue || s.window.VTTCue)(0, 0, ""); try { s.cue.align = "center" } catch (e) { s.cue.align = "middle" } if (s.state = "CUE", -1 === n.indexOf("--\x3e")) { s.cue.id = n; continue } case "CUE": try { !function (t, i, r) { var s = t; function e() { var e = ji(t); if (null === e) throw new Fi(Fi.Errors.BadTimeStamp, "Malformed timestamp: " + s); return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e } function n() { t = t.replace(/^\s+/, "") } if (n(), i.startTime = e(), n(), "--\x3e" !== t.substr(0, 3)) throw new Fi(Fi.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '--\x3e'): " + s); t = t.substr(3), n(), i.endTime = e(), n(); var a = t, o = new Hi; Vi(a, function (e, t) { switch (e) { case "region": for (var i = r.length - 1; 0 <= i; i--)if (r[i].id === t) { o.set(e, r[i].region); break } break; case "vertical": o.alt(e, t, ["rl", "lr"]); break; case "line": var s = t.split(","), n = s[0]; o.integer(e, n), o.percent(e, n) && o.set("snapToLines", !1), o.alt(e, n, ["auto"]), 2 === s.length && o.alt("lineAlign", s[1], ["start", "center", "end"]); break; case "position": s = t.split(","), o.percent(e, s[0]), 2 === s.length && o.alt("positionAlign", s[1], ["start", "center", "end"]); break; case "size": o.percent(e, t); break; case "align": o.alt(e, t, ["start", "center", "end", "left", "right"]) } }, /:/, /\s/), i.region = o.get("region", null), i.vertical = o.get("vertical", ""); try { i.line = o.get("line", "auto") } catch (e) { } i.lineAlign = o.get("lineAlign", "start"), i.snapToLines = o.get("snapToLines", !0), i.size = o.get("size", 100); try { i.align = o.get("align", "center") } catch (e) { i.align = o.get("align", "middle") } try { i.position = o.get("position", "auto") } catch (e) { i.position = o.get("position", { start: 0, left: 0, center: 50, middle: 50, end: 100, right: 100 }, i.align) } i.positionAlign = o.get("positionAlign", { start: "start", left: "start", center: "center", middle: "center", end: "end", right: "end" }, i.align) }(n, s.cue, s.regionList) } catch (e) { s.reportOrThrowError(e), s.cue = null, s.state = "BADCUE"; continue } s.state = "CUETEXT"; continue; case "CUETEXT": var o = -1 !== n.indexOf("--\x3e"); if (!n || o && (a = !0)) { s.oncue && s.oncue(s.cue), s.cue = null, s.state = "ID"; continue } s.cue.text && (s.cue.text += "\n"), s.cue.text += n.replace(/\u2028/g, "\n").replace(/u2029/g, "\n"); continue; case "BADCUE": n || (s.state = "ID"); continue } } } catch (e) { s.reportOrThrowError(e), "CUETEXT" === s.state && s.cue && s.oncue && s.oncue(s.cue), s.cue = null, s.state = "INITIAL" === s.state ? "BADWEBVTT" : "BADCUE" } return this }, flush: function () { var t = this; try { if (t.buffer += t.decoder.decode(), !t.cue && "HEADER" !== t.state || (t.buffer += "\n\n", t.parse()), "INITIAL" === t.state) throw new Fi(Fi.Errors.BadSignature) } catch (e) { t.reportOrThrowError(e) } return t.onflush && t.onflush(), this } }; var ts = es, is = { "": 1, lr: 1, rl: 1 }, ss = { start: 1, center: 1, end: 1, left: 1, right: 1, auto: 1, "line-left": 1, "line-right": 1 }; function ns(e) { return "string" == typeof e && !!ss[e.toLowerCase()] && e.toLowerCase() } function rs(e, t, i) { this.hasBeenReset = !1; var s = "", n = !1, r = e, a = t, o = i, l = null, d = "", h = !0, u = "auto", c = "start", p = "auto", m = "auto", g = 100, f = "center"; Object.defineProperties(this, { id: { enumerable: !0, get: function () { return s }, set: function (e) { s = "" + e } }, pauseOnExit: { enumerable: !0, get: function () { return n }, set: function (e) { n = !!e } }, startTime: { enumerable: !0, get: function () { return r }, set: function (e) { if ("number" != typeof e) throw new TypeError("Start time must be set to a number."); r = e, this.hasBeenReset = !0 } }, endTime: { enumerable: !0, get: function () { return a }, set: function (e) { if ("number" != typeof e) throw new TypeError("End time must be set to a number."); a = e, this.hasBeenReset = !0 } }, text: { enumerable: !0, get: function () { return o }, set: function (e) { o = "" + e, this.hasBeenReset = !0 } }, region: { enumerable: !0, get: function () { return l }, set: function (e) { l = e, this.hasBeenReset = !0 } }, vertical: { enumerable: !0, get: function () { return d }, set: function (e) { e = "string" == typeof (e = e) && !!is[e.toLowerCase()] && e.toLowerCase(); if (!1 === e) throw new SyntaxError("Vertical: an invalid or illegal direction string was specified."); d = e, this.hasBeenReset = !0 } }, snapToLines: { enumerable: !0, get: function () { return h }, set: function (e) { h = !!e, this.hasBeenReset = !0 } }, line: { enumerable: !0, get: function () { return u }, set: function (e) { if ("number" != typeof e && "auto" !== e) throw new SyntaxError("Line: an invalid number or illegal string was specified."); u = e, this.hasBeenReset = !0 } }, lineAlign: { enumerable: !0, get: function () { return c }, set: function (e) { e = ns(e); e && (c = e, this.hasBeenReset = !0) } }, position: { enumerable: !0, get: function () { return p }, set: function (e) { if (e < 0 || 100 < e) throw new Error("Position must be between 0 and 100."); p = e, this.hasBeenReset = !0 } }, positionAlign: { enumerable: !0, get: function () { return m }, set: function (e) { e = ns(e); e && (m = e, this.hasBeenReset = !0) } }, size: { enumerable: !0, get: function () { return g }, set: function (e) { if (e < 0 || 100 < e) throw new Error("Size must be between 0 and 100."); g = e, this.hasBeenReset = !0 } }, align: { enumerable: !0, get: function () { return f }, set: function (e) { e = ns(e); if (!e) throw new SyntaxError("align: an invalid or illegal alignment string was specified."); f = e, this.hasBeenReset = !0 } } }), this.displayState = void 0 } rs.prototype.getCueAsHTML = function () { return WebVTT.convertCueToDOMTree(window, this.text) }; var as = rs, os = { "": !0, up: !0 }; function ls(e) { return "number" == typeof e && 0 <= e && e <= 100 } function ds() { var t = 100, i = 3, s = 0, n = 100, r = 0, a = 100, o = ""; Object.defineProperties(this, { width: { enumerable: !0, get: function () { return t }, set: function (e) { if (!ls(e)) throw new Error("Width must be between 0 and 100."); t = e } }, lines: { enumerable: !0, get: function () { return i }, set: function (e) { if ("number" != typeof e) throw new TypeError("Lines must be set to a number."); i = e } }, regionAnchorY: { enumerable: !0, get: function () { return n }, set: function (e) { if (!ls(e)) throw new Error("RegionAnchorX must be between 0 and 100."); n = e } }, regionAnchorX: { enumerable: !0, get: function () { return s }, set: function (e) { if (!ls(e)) throw new Error("RegionAnchorY must be between 0 and 100."); s = e } }, viewportAnchorY: { enumerable: !0, get: function () { return a }, set: function (e) { if (!ls(e)) throw new Error("ViewportAnchorY must be between 0 and 100."); a = e } }, viewportAnchorX: { enumerable: !0, get: function () { return r }, set: function (e) { if (!ls(e)) throw new Error("ViewportAnchorX must be between 0 and 100."); r = e } }, scroll: { enumerable: !0, get: function () { return o }, set: function (e) { e = "string" == typeof (e = e) && !!os[e.toLowerCase()] && e.toLowerCase(); !1 !== e && (o = e) } } }) } var hs = Mt(function (e) { var e = e.exports = { WebVTT: ts, VTTCue: as, VTTRegion: ds }, t = (gi.vttjs = e, gi.WebVTT = e.WebVTT, e.VTTCue), i = e.VTTRegion, s = gi.VTTCue, n = gi.VTTRegion; e.shim = function () { gi.VTTCue = t, gi.VTTRegion = i }, e.restore = function () { gi.VTTCue = s, gi.VTTRegion = n }, gi.VTTCue || e.shim() }); hs.WebVTT, hs.VTTCue, hs.VTTRegion; class _ extends f { constructor(t = {}, e = function () { }) { t.reportTouchActivity = !1, super(null, t, e), this.onDurationChange_ = e => this.onDurationChange(e), this.trackProgress_ = e => this.trackProgress(e), this.trackCurrentTime_ = e => this.trackCurrentTime(e), this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e), this.disposeSourceHandler_ = e => this.disposeSourceHandler(e), this.queuedHanders_ = new Set, this.hasStarted_ = !1, this.on("playing", function () { this.hasStarted_ = !0 }), this.on("loadstart", function () { this.hasStarted_ = !1 }), a.names.forEach(e => { e = a[e]; t && t[e.getterName] && (this[e.privateName] = t[e.getterName]) }), this.featuresProgressEvents || this.manualProgressOn(), this.featuresTimeupdateEvents || this.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach(e => { !1 === t[`native${e}Tracks`] && (this[`featuresNative${e}Tracks`] = !1) }), !1 === t.nativeCaptions || !1 === t.nativeTextTracks ? this.featuresNativeTextTracks = !1 : !0 !== t.nativeCaptions && !0 !== t.nativeTextTracks || (this.featuresNativeTextTracks = !0), this.featuresNativeTextTracks || this.emulateTextTracks(), this.preloadTextTracks = !1 !== t.preloadTextTracks, this.autoRemoteTextTracks_ = new a.text.ListClass, this.initTrackListeners(), t.nativeControlsForTouch || this.emitTapEvents(), this.constructor && (this.name_ = this.constructor.name || "Unknown Tech") } triggerSourceset(e) { this.isReady_ || this.one("ready", () => this.setTimeout(() => this.triggerSourceset(e), 1)), this.trigger({ src: e, type: "sourceset" }) } manualProgressOn() { this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_) } manualProgressOff() { this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_) } trackProgress(e) { this.stopTrackingProgress(), this.progressInterval = this.setInterval(m(this, function () { var e = this.bufferedPercent(); this.bufferedPercent_ !== e && this.trigger("progress"), 1 === (this.bufferedPercent_ = e) && this.stopTrackingProgress() }), 500) } onDurationChange(e) { this.duration_ = this.duration() } buffered() { return Ut(0, 0) } bufferedPercent() { return zt(this.buffered(), this.duration_) } stopTrackingProgress() { this.clearInterval(this.progressInterval) } manualTimeUpdatesOn() { this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_) } manualTimeUpdatesOff() { this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_) } trackCurrentTime() { this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function () { this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) }, 250) } stopTrackingCurrentTime() { this.clearInterval(this.currentTimeInterval), this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) } dispose() { this.clearTracks(Mi.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), super.dispose() } clearTracks(e) { (e = [].concat(e)).forEach(e => { var t = this[e + "Tracks"]() || []; let i = t.length; for (; i--;) { var s = t[i]; "text" === e && this.removeRemoteTextTrack(s), t.removeTrack(s) } }) } cleanupAutoTextTracks() { var e = this.autoRemoteTextTracks_ || []; let t = e.length; for (; t--;) { var i = e[t]; this.removeRemoteTextTrack(i) } } reset() { } crossOrigin() { } setCrossOrigin() { } error(e) { return void 0 !== e && (this.error_ = new i(e), this.trigger("error")), this.error_ } played() { return this.hasStarted_ ? Ut(0, 0) : Ut() } play() { } setScrubbing(e) { } scrubbing() { } setCurrentTime(e) { this.manualTimeUpdates && this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) } initTrackListeners() { Mi.names.forEach(e => { var t = Mi[e]; const i = () => { this.trigger(e + "trackchange") }, s = this[t.getterName](); s.addEventListener("removetrack", i), s.addEventListener("addtrack", i), this.on("dispose", () => { s.removeEventListener("removetrack", i), s.removeEventListener("addtrack", i) }) }) } addWebVttScript_() { if (!window.WebVTT) if (document.body.contains(this.el())) if (!this.options_["vtt.js"] && Y(hs) && 0 < Object.keys(hs).length) this.trigger("vttjsloaded"); else { const e = document.createElement("script"); e.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", e.onload = () => { this.trigger("vttjsloaded") }, e.onerror = () => { this.trigger("vttjserror") }, this.on("dispose", () => { e.onload = null, e.onerror = null }), window.WebVTT = !0, this.el().parentNode.appendChild(e) } else this.ready(this.addWebVttScript_) } emulateTextTracks() { const i = this.textTracks(), e = this.remoteTextTracks(), t = e => i.addTrack(e.track), s = e => i.removeTrack(e.track), n = (e.on("addtrack", t), e.on("removetrack", s), this.addWebVttScript_(), () => this.trigger("texttrackchange")), r = () => { n(); for (let e = 0; e < i.length; e++) { var t = i[e]; t.removeEventListener("cuechange", n), "showing" === t.mode && t.addEventListener("cuechange", n) } }; r(), i.addEventListener("change", r), i.addEventListener("addtrack", r), i.addEventListener("removetrack", r), this.on("dispose", function () { e.off("addtrack", t), e.off("removetrack", s), i.removeEventListener("change", r), i.removeEventListener("addtrack", r), i.removeEventListener("removetrack", r); for (let e = 0; e < i.length; e++)i[e].removeEventListener("cuechange", n) }) } addTextTrack(e, t, i) { if (e) return e = e, t = t, i = i, n = {}, r = (s = this).textTracks(), n.kind = e, t && (n.label = t), i && (n.language = i), n.tech = s, e = new a.text.TrackClass(n), r.addTrack(e), e; throw new Error("TextTrack kind is required but was not provided"); var s, n, r } createRemoteTextTrack(e) { e = h(e, { tech: this }); return new Ni.remoteTextEl.TrackClass(e) } addRemoteTextTrack(e = {}, t) { const i = this.createRemoteTextTrack(e); return "boolean" != typeof t && (t = !1), this.remoteTextTrackEls().addTrackElement_(i), this.remoteTextTracks().addTrack(i.track), !1 === t && this.ready(() => this.autoRemoteTextTracks_.addTrack(i.track)), i } removeRemoteTextTrack(e) { var t = this.remoteTextTrackEls().getTrackElementByTrack_(e); this.remoteTextTrackEls().removeTrackElement_(t), this.remoteTextTracks().removeTrack(e), this.autoRemoteTextTracks_.removeTrack(e) } getVideoPlaybackQuality() { return {} } requestPictureInPicture() { return Promise.reject() } disablePictureInPicture() { return !0 } setDisablePictureInPicture() { } requestVideoFrameCallback(e) { const t = it++; return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(t), this.one("playing", () => { this.queuedHanders_.has(t) && (this.queuedHanders_.delete(t), e()) })) : this.requestNamedAnimationFrame(t, e), t } cancelVideoFrameCallback(e) { this.queuedHanders_.has(e) ? this.queuedHanders_.delete(e) : this.cancelNamedAnimationFrame(e) } setPoster() { } playsinline() { } setPlaysinline() { } overrideNativeAudioTracks(e) { } overrideNativeVideoTracks(e) { } canPlayType(e) { return "" } static canPlayType(e) { return "" } static canPlaySource(e, t) { return _.canPlayType(e.type) } static isTech(e) { return e.prototype instanceof _ || e instanceof _ || e === _ } static registerTech(e, t) { if (_.techs_ || (_.techs_ = {}), !_.isTech(t)) throw new Error(`Tech ${e} must be a Tech`); if (!_.canPlayType) throw new Error("Techs must have a static canPlayType method on them"); if (_.canPlaySource) return e = g(e), _.techs_[e] = t, _.techs_[Lt(e)] = t, "Tech" !== e && _.defaultTechOrder_.push(e), t; throw new Error("Techs must have a static canPlaySource method on them") } static getTech(e) { if (e) return _.techs_ && _.techs_[e] ? _.techs_[e] : (e = g(e), window && window.tm_videojs && window.tm_videojs[e] ? (d.warn(`The ${e} tech was added to the tm_videojs object when it should be registered using tm_videojs.registerTech(name, tech)`), window.tm_videojs[e]) : void 0) } } a.names.forEach(function (e) { const t = a[e]; _.prototype[t.getterName] = function () { return this[t.privateName] = this[t.privateName] || new t.ListClass, this[t.privateName] } }), _.prototype.featuresVolumeControl = !0, _.prototype.featuresMuteControl = !0, _.prototype.featuresFullscreenResize = !1, _.prototype.featuresPlaybackRate = !1, _.prototype.featuresProgressEvents = !1, _.prototype.featuresSourceset = !1, _.prototype.featuresTimeupdateEvents = !1, _.prototype.featuresNativeTextTracks = !1, _.prototype.featuresVideoFrameCallback = !1, _.withSourceHandlers = function (n) { n.registerSourceHandler = function (e, t) { let i = n.sourceHandlers; i = i || (n.sourceHandlers = []), void 0 === t && (t = i.length), i.splice(t, 0, e) }, n.canPlayType = function (t) { var i, s = n.sourceHandlers || []; for (let e = 0; e < s.length; e++)if (i = s[e].canPlayType(t)) return i; return "" }, n.selectSourceHandler = function (t, i) { var s = n.sourceHandlers || []; for (let e = 0; e < s.length; e++)if (s[e].canHandleSource(t, i)) return s[e]; return null }, n.canPlaySource = function (e, t) { var i = n.selectSourceHandler(e, t); return i ? i.canHandleSource(e, t) : "" };["seekable", "seeking", "duration"].forEach(function (e) { const t = this[e]; "function" == typeof t && (this[e] = function () { return this.sourceHandler_ && this.sourceHandler_[e] ? this.sourceHandler_[e].apply(this.sourceHandler_, arguments) : t.apply(this, arguments) }) }, n.prototype), n.prototype.setSource = function (e) { let t = n.selectSourceHandler(e, this.options_); t || (n.nativeSourceHandler ? t = n.nativeSourceHandler : d.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), t !== n.nativeSourceHandler && (this.currentSource_ = e), this.sourceHandler_ = t.handleSource(e, this, this.options_), this.one("dispose", this.disposeSourceHandler_) }, n.prototype.disposeSourceHandler = function () { this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null) } }, f.registerComponent("Tech", _), _.registerTech("Tech", _), _.defaultTechOrder_ = []; const us = {}, cs = {}, ps = {}; function ms(e, t, i) { e.setTimeout(() => function i(s = {}, e = [], n, r, a = [], o = !1) { const [t, ...l] = e; if ("string" == typeof t) i(s, us[t], n, r, a, o); else if (t) { const d = bs(r, t); if (!d.setSource) return a.push(d), i(s, l, n, r, a, o); d.setSource(Object.assign({}, s), function (e, t) { if (e) return i(s, l, n, r, a, o); a.push(d), i(t, s.type === t.type ? l : us[t.type], n, r, a, o) }) } else l.length ? i(s, l, n, r, a, o) : o ? n(s, a) : i(s, us["*"], n, r, a, !0) }(t, us[t.type], i, e), 1) } function gs(e, t, i, s = null) { var n = "call" + g(i), n = e.reduce(vs(n), s), s = n === ps, t = s ? null : t[i](n), r = e, a = i, o = t, l = s; for (let e = r.length - 1; 0 <= e; e--) { var d = r[e]; d[a] && d[a](l, o) } return t } const fs = { buffered: 1, currentTime: 1, duration: 1, muted: 1, played: 1, paused: 1, seekable: 1, volume: 1, ended: 1 }, ys = { setCurrentTime: 1, setMuted: 1, setVolume: 1 }, _s = { play: 1, pause: 1 }; function vs(i) { return (e, t) => e === ps ? ps : t[i] ? t[i](e) : e } function bs(e, t) { var i = cs[e.id()]; let s = null; if (null == i) s = t(e), cs[e.id()] = [[t, s]]; else { for (let e = 0; e < i.length; e++) { var [n, r] = i[e]; n === t && (s = r) } null === s && (s = t(e), i.push([t, s])) } return s } function Ts(e) { if (Array.isArray(e)) { let t = []; e.forEach(function (e) { e = Ts(e), Array.isArray(e) ? t = t.concat(e) : K(e) && t.push(e) }), e = t } else e = "string" == typeof e && e.trim() ? [Es({ src: e })] : K(e) && "string" == typeof e.src && e.src && e.src.trim() ? [Es(e)] : []; return e } const Ss = { opus: "video/ogg", ogv: "video/ogg", mp4: "video/mp4", mov: "video/mp4", m4v: "video/mp4", mkv: "video/x-matroska", m4a: "audio/mp4", mp3: "audio/mpeg", aac: "audio/aac", caf: "audio/x-caf", flac: "audio/flac", oga: "audio/ogg", wav: "audio/wav", m3u8: "application/x-mpegURL", mpd: "application/dash+xml", jpg: "image/jpeg", jpeg: "image/jpeg", gif: "image/gif", png: "image/png", svg: "image/svg+xml", webp: "image/webp" }, ws = function (e = "") { e = ci(e); return Ss[e.toLowerCase()] || "" }; function Es(e) { var t; return e.type || (t = ws(e.src)) && (e.type = t), e } class Cs extends f { constructor(s, e, t) { if (super(s, h({ createEl: !1 }, e), t), e.playerOptions.sources && 0 !== e.playerOptions.sources.length) s.src(e.playerOptions.sources); else for (let t = 0, i = e.playerOptions.techOrder; t < i.length; t++) { var n = g(i[t]); let e = _.getTech(n); if ((e = n ? e : f.getComponent(n)) && e.isSupported()) { s.loadTech_(n); break } } } } f.registerComponent("MediaLoader", Cs); class ks extends f { constructor(e, t) { super(e, t), this.options_.controlText && this.controlText(this.options_.controlText), this.handleMouseOver_ = e => this.handleMouseOver(e), this.handleMouseOut_ = e => this.handleMouseOut(e), this.handleClick_ = e => this.handleClick(e), this.handleKeyDown_ = e => this.handleKeyDown(e), this.emitTapEvents(), this.enable() } createEl(e = "div", t = {}, i = {}) { t = Object.assign({ className: this.buildCSSClass(), tabIndex: 0 }, t), "button" === e && d.error(`Creating a ClickableComponent with an HTML element of ${e} is not supported; use a Button instead.`), i = Object.assign({ role: "button" }, i), this.tabIndex_ = t.tabIndex; e = o(e, t, i); return this.player_.options_.experimentalSvgIcons || e.appendChild(o("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), this.createControlTextEl(e), e } dispose() { this.controlTextEl_ = null, super.dispose() } createControlTextEl(e) { return this.controlTextEl_ = o("span", { className: "vjs-control-text" }, { "aria-live": "polite" }), e && e.appendChild(this.controlTextEl_), this.controlText(this.controlText_, e), this.controlTextEl_ } controlText(e, t = this.el()) { if (void 0 === e) return this.controlText_ || "Need Text"; var i = this.localize(e); this.controlText_ = e, we(this.controlTextEl_, i), this.nonIconControl || this.player_.options_.noUITitleAttributes || t.setAttribute("title", i) } buildCSSClass() { return "vjs-control vjs-button " + super.buildCSSClass() } enable() { this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), "undefined" != typeof this.tabIndex_ && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_)) } disable() { this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), "undefined" != typeof this.tabIndex_ && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_) } handleLanguagechange() { this.controlText(this.controlText_) } handleClick(e) { this.options_.clickHandler && this.options_.clickHandler.call(this, arguments) } handleKeyDown(e) { n.isEventKey(e, "Space") || n.isEventKey(e, "Enter") ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e) } } f.registerComponent("ClickableComponent", ks); class Is extends ks { constructor(e, t) { super(e, t), this.update(), this.update_ = e => this.update(e), e.on("posterchange", this.update_) } dispose() { this.player().off("posterchange", this.update_), super.dispose() } createEl() { return o("div", { className: "vjs-poster" }) } crossOrigin(e) { if ("undefined" == typeof e) return this.$("img") ? this.$("img").crossOrigin : this.player_.tech_ && this.player_.tech_.isReady_ ? this.player_.crossOrigin() : this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null; null !== e && "anonymous" !== e && "use-credentials" !== e ? this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`) : this.$("img") && (this.$("img").crossOrigin = e) } update(e) { var t = this.player().poster(); this.setSrc(t), t ? this.show() : this.hide() } setSrc(e) { e ? (this.$("img") || this.el_.appendChild(o("picture", { className: "vjs-poster", tabIndex: -1 }, {}, o("img", { loading: "lazy", crossOrigin: this.crossOrigin() }, { alt: "" }))), this.$("img").src = e) : this.el_.textContent = "" } handleClick(e) { this.player_.controls() && (this.player_.tech(!0) && this.player_.tech(!0).focus(), this.player_.paused() ? Gt(this.player_.play()) : this.player_.pause()) } } Is.prototype.crossorigin = Is.prototype.crossOrigin, f.registerComponent("PosterImage", Is); const xs = { monospace: "monospace", sansSerif: "sans-serif", serif: "serif", monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace', monospaceSerif: '"Courier New", monospace', proportionalSansSerif: "sans-serif", proportionalSerif: "serif", casual: '"Comic Sans MS", Impact, fantasy', script: '"Monotype Corsiva", cursive', smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif' }; function As(e, t) { let i; if (4 === e.length) i = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]; else { if (7 !== e.length) throw new Error("Invalid color code provided, " + e + "; must be formatted as e.g. #f0e or #f604e2."); i = e.slice(1) } return "rgba(" + parseInt(i.slice(0, 2), 16) + "," + parseInt(i.slice(2, 4), 16) + "," + parseInt(i.slice(4, 6), 16) + "," + t + ")" } function Ls(e, t, i) { try { e.style[t] = i } catch (e) { } } function Ps(e) { return e ? e + "px" : "" } class Ds extends f { constructor(s, e, t) { super(s, e, t); const n = e => { this.updateDisplayOverlay(), this.updateDisplay(e) }; s.on("loadstart", e => this.toggleDisplay(e)), s.on("texttrackchange", e => this.updateDisplay(e)), s.on("loadedmetadata", e => { this.updateDisplayOverlay(), this.preselectTrack(e) }), s.ready(m(this, function () { if (s.tech_ && s.tech_.featuresNativeTextTracks) this.hide(); else { s.on("fullscreenchange", n), s.on("playerresize", n); const e = window.screen.orientation || window, i = window.screen.orientation ? "change" : "orientationchange"; e.addEventListener(i, n), s.on("dispose", () => e.removeEventListener(i, n)); var t = this.options_.playerOptions.tracks || []; for (let e = 0; e < t.length; e++)this.player_.addRemoteTextTrack(t[e], !0); this.preselectTrack() } })) } preselectTrack() { var t = { captions: 1, subtitles: 1 }, i = this.player_.textTracks(), s = this.player_.cache_.selectedLanguage; let n, r, a; for (let e = 0; e < i.length; e++) { var o = i[e]; s && s.enabled && s.language && s.language === o.language && o.kind in t ? a = o.kind !== s.kind && a || o : s && !s.enabled ? (a = null, n = null, r = null) : o.default && ("descriptions" !== o.kind || n ? o.kind in t && !r && (r = o) : n = o) } a ? a.mode = "showing" : r ? r.mode = "showing" : n && (n.mode = "showing") } toggleDisplay() { this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show() } createEl() { return super.createEl("div", { className: "vjs-text-track-display" }, { translate: "yes", "aria-live": "off", "aria-atomic": "true" }) } clearDisplay() { "function" == typeof window.WebVTT && window.WebVTT.processCues(window, [], this.el_) } updateDisplay() { var s = this.player_.textTracks(), e = this.options_.allowMultipleShowingTracks; if (this.clearDisplay(), e) { var t = []; for (let e = 0; e < s.length; ++e) { var i = s[e]; "showing" === i.mode && t.push(i) } this.updateForTrack(t) } else { let e = null, t = null, i = s.length; for (; i--;) { var n = s[i]; "showing" === n.mode && ("descriptions" === n.kind ? e = n : t = n) } t ? ("off" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "off"), this.updateForTrack(t)) : e && ("assertive" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "assertive"), this.updateForTrack(e)) } } updateDisplayOverlay() { if (this.player_.videoHeight()) { var i = this.player_.currentWidth(), s = this.player_.currentHeight(), n = i / s, r = this.player_.videoWidth() / this.player_.videoHeight(); let e = 0, t = 0; .1 < Math.abs(n - r) && (r < n ? e = Math.round((i - s * r) / 2) : t = Math.round((s - i / r) / 2)), Ls(this.el_, "insetInline", Ps(e)), Ls(this.el_, "insetBlock", Ps(t)) } } updateDisplayState(e) { var t = this.player_.textTrackSettings.getValues(), i = e.activeCues; let s = i.length; for (; s--;) { var n, r = i[s]; r && (r = r.displayState, t.color && (r.firstChild.style.color = t.color), t.textOpacity && Ls(r.firstChild, "color", As(t.color || "#fff", t.textOpacity)), t.backgroundColor && (r.firstChild.style.backgroundColor = t.backgroundColor), t.backgroundOpacity && Ls(r.firstChild, "backgroundColor", As(t.backgroundColor || "#000", t.backgroundOpacity)), t.windowColor && (t.windowOpacity ? Ls(r, "backgroundColor", As(t.windowColor, t.windowOpacity)) : r.style.backgroundColor = t.windowColor), t.edgeStyle && ("dropshadow" === t.edgeStyle ? r.firstChild.style.textShadow = "2px 2px 3px #222, 2px 2px 4px #222, 2px 2px 5px #222" : "raised" === t.edgeStyle ? r.firstChild.style.textShadow = "1px 1px #222, 2px 2px #222, 3px 3px #222" : "depressed" === t.edgeStyle ? r.firstChild.style.textShadow = "1px 1px #ccc, 0 1px #ccc, -1px -1px #222, 0 -1px #222" : "uniform" === t.edgeStyle && (r.firstChild.style.textShadow = "0 0 4px #222, 0 0 4px #222, 0 0 4px #222, 0 0 4px #222")), t.fontPercent && 1 !== t.fontPercent && (n = window.parseFloat(r.style.fontSize), r.style.fontSize = n * t.fontPercent + "px", r.style.height = "auto", r.style.top = "auto"), t.fontFamily) && "default" !== t.fontFamily && ("small-caps" === t.fontFamily ? r.firstChild.style.fontVariant = "small-caps" : r.firstChild.style.fontFamily = xs[t.fontFamily]) } } updateForTrack(i) { if (Array.isArray(i) || (i = [i]), "function" == typeof window.WebVTT && !i.every(e => !e.activeCues)) { var t = []; for (let e = 0; e < i.length; ++e) { var s = i[e]; for (let e = 0; e < s.activeCues.length; ++e)t.push(s.activeCues[e]) } window.WebVTT.processCues(window, t, this.el_); for (let t = 0; t < i.length; ++t) { var n = i[t]; for (let e = 0; e < n.activeCues.length; ++e) { var r = n.activeCues[e].displayState; ke(r, "vjs-text-track-cue", "vjs-text-track-cue-" + (n.language || t)), n.language && De(r, "lang", n.language) } this.player_.textTrackSettings && this.updateDisplayState(n) } } } } f.registerComponent("TextTrackDisplay", Ds); class Os extends f { createEl() { var e = this.player_.isAudio(), e = this.localize(e ? "Audio Player" : "Video Player"), e = o("span", { className: "vjs-control-text", textContent: this.localize("{1} is loading.", [e]) }), t = super.createEl("div", { className: "vjs-loading-spinner", dir: "ltr" }); return t.appendChild(e), t } handleLanguagechange() { this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [this.player_.isAudio() ? "Audio Player" : "Video Player"]) } } f.registerComponent("LoadingSpinner", Os); class s extends ks { createEl(e, t = {}, i = {}) { t = o("button", t = Object.assign({ className: this.buildCSSClass() }, t), i = Object.assign({ type: "button" }, i)); return this.player_.options_.experimentalSvgIcons || t.appendChild(o("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), this.createControlTextEl(t), t } addChild(e, t = {}) { var i = this.constructor.name; return d.warn(`Adding an actionable (user controllable) child to a Button (${i}) is not supported; use a ClickableComponent instead.`), f.prototype.addChild.call(this, e, t) } enable() { super.enable(), this.el_.removeAttribute("disabled") } disable() { super.disable(), this.el_.setAttribute("disabled", "disabled") } handleKeyDown(e) { n.isEventKey(e, "Space") || n.isEventKey(e, "Enter") ? e.stopPropagation() : super.handleKeyDown(e) } } f.registerComponent("Button", s); class Ms extends s { constructor(e, t) { super(e, t), this.mouseused_ = !1, this.setIcon("play"), this.on("mousedown", e => this.handleMouseDown(e)) } buildCSSClass() { return "vjs-big-play-button" } handleClick(e) { var t = this.player_.play(); if (this.mouseused_ && e.clientX && e.clientY) Gt(t), this.player_.tech(!0) && this.player_.tech(!0).focus(); else { var e = this.player_.getChild("controlBar"); const i = e && e.getChild("playToggle"); i ? (e = () => i.focus(), Wt(t) ? t.then(e, () => { }) : this.setTimeout(e, 1)) : this.player_.tech(!0).focus() } } handleKeyDown(e) { this.mouseused_ = !1, super.handleKeyDown(e) } handleMouseDown(e) { this.mouseused_ = !0 } } Ms.prototype.controlText_ = "Play Video", f.registerComponent("BigPlayButton", Ms); s; f.registerComponent("CloseButton", class extends s { constructor(e, t) { super(e, t), this.setIcon("cancel"), this.controlText(t && t.controlText || this.localize("Close")) } buildCSSClass() { return "vjs-close-button " + super.buildCSSClass() } handleClick(e) { this.trigger({ type: "close", bubbles: !1 }) } handleKeyDown(e) { n.isEventKey(e, "Esc") ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e) } }); class Ns extends s { constructor(e, t = {}) { super(e, t), t.replay = void 0 === t.replay || t.replay, this.on(e, "play", e => this.handlePlay(e)), this.on(e, "pause", e => this.handlePause(e)), t.replay && this.on(e, "ended", e => this.handleEnded(e)) } buildCSSClass() { return "vjs-play-control " + super.buildCSSClass() } handleClick(e) { this.player_.paused() ? Gt(this.player_.play()) : this.player_.pause() } handleSeeked(e) { this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(e) : this.handlePlay(e) } handlePlay(e) { this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.setIcon("pause"), this.controlText("Pause") } handlePause(e) { this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.setIcon("play"), this.controlText("Play") } handleEnded(e) { this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.setIcon("replay"), this.controlText("Replay"), this.one(this.player_, "seeked", e => this.handleSeeked(e)) } } Ns.prototype.controlText_ = "Play", f.registerComponent("PlayToggle", Ns); class Rs extends f { constructor(e, t) { super(e, t), this.on(e, ["timeupdate", "ended"], e => this.updateContent(e)), this.updateTextNode_() } createEl() { var e = this.buildCSSClass(), t = super.createEl("div", { className: e + " vjs-time-control vjs-control" }), i = o("span", { className: "vjs-control-text", textContent: this.localize(this.labelText_) + " " }, { role: "presentation" }); return t.appendChild(i), this.contentEl_ = o("span", { className: e + "-display" }, { role: "presentation" }), t.appendChild(this.contentEl_), t } dispose() { this.contentEl_ = null, this.textNode_ = null, super.dispose() } updateTextNode_(e = 0) { e = Vt(e), this.formattedTime_ !== e && (this.formattedTime_ = e, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", () => { if (this.contentEl_) { let e = this.textNode_; e && this.contentEl_.firstChild !== e && (e = null, d.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")), this.textNode_ = document.createTextNode(this.formattedTime_), this.textNode_ && (e ? this.contentEl_.replaceChild(this.textNode_, e) : this.contentEl_.appendChild(this.textNode_)) } })) } updateContent(e) { } } Rs.prototype.labelText_ = "Time", Rs.prototype.controlText_ = "Time", f.registerComponent("TimeDisplay", Rs); class Us extends Rs { buildCSSClass() { return "vjs-current-time" } updateContent(e) { let t; t = this.player_.ended() ? this.player_.duration() : this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(t) } } Us.prototype.labelText_ = "Current Time", Us.prototype.controlText_ = "Current Time", f.registerComponent("CurrentTimeDisplay", Us); class Bs extends Rs { constructor(e, t) { super(e, t); t = e => this.updateContent(e); this.on(e, "durationchange", t), this.on(e, "loadstart", t), this.on(e, "loadedmetadata", t) } buildCSSClass() { return "vjs-duration" } updateContent(e) { var t = this.player_.duration(); this.updateTextNode_(t) } } Bs.prototype.labelText_ = "Duration", Bs.prototype.controlText_ = "Duration", f.registerComponent("DurationDisplay", Bs); class Fs extends f { createEl() { var e = super.createEl("div", { className: "vjs-time-control vjs-time-divider" }, { "aria-hidden": !0 }), t = super.createEl("div"), i = super.createEl("span", { textContent: "/" }); return t.appendChild(i), e.appendChild(t), e } } f.registerComponent("TimeDivider", Fs); class js extends Rs { constructor(e, t) { super(e, t), this.on(e, "durationchange", e => this.updateContent(e)) } buildCSSClass() { return "vjs-remaining-time" } createEl() { var e = super.createEl(); return !1 !== this.options_.displayNegative && e.insertBefore(o("span", {}, { "aria-hidden": !0 }, "-"), this.contentEl_), e } updateContent(e) { if ("number" == typeof this.player_.duration()) { let e; e = this.player_.ended() ? 0 : this.player_.remainingTimeDisplay ? this.player_.remainingTimeDisplay() : this.player_.remainingTime(), this.updateTextNode_(e) } } } js.prototype.labelText_ = "Remaining Time", js.prototype.controlText_ = "Remaining Time", f.registerComponent("RemainingTimeDisplay", js); class Hs extends f { constructor(e, t) { super(e, t), this.updateShowing(), this.on(this.player(), "durationchange", e => this.updateShowing(e)) } createEl() { var e = super.createEl("div", { className: "vjs-live-control vjs-control" }); return this.contentEl_ = o("div", { className: "vjs-live-display" }, { "aria-live": "off" }), this.contentEl_.appendChild(o("span", { className: "vjs-control-text", textContent: this.localize("Stream Type") + " " })), this.contentEl_.appendChild(document.createTextNode(this.localize("LIVE"))), e.appendChild(this.contentEl_), e } dispose() { this.contentEl_ = null, super.dispose() } updateShowing(e) { this.player().duration() === 1 / 0 ? this.show() : this.hide() } } f.registerComponent("LiveDisplay", Hs); class Vs extends s { constructor(e, t) { super(e, t), this.updateLiveEdgeStatus(), this.player_.liveTracker && (this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e), this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_)) } createEl() { var e = super.createEl("button", { className: "vjs-seek-to-live-control vjs-control" }); return this.setIcon("circle", e), this.textEl_ = o("span", { className: "vjs-seek-to-live-text", textContent: this.localize("LIVE") }, { "aria-hidden": "true" }), e.appendChild(this.textEl_), e } updateLiveEdgeStatus() { !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live")) } handleClick() { this.player_.liveTracker.seekToLiveEdge() } dispose() { this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_), this.textEl_ = null, super.dispose() } } function qs(e, t, i) { return e = Number(e), Math.min(i, Math.max(t, isNaN(e) ? t : e)) } Vs.prototype.controlText_ = "Seek to live, currently playing live", f.registerComponent("SeekToLive", Vs); mi = Object.freeze({ __proto__: null, clamp: qs }); class zs extends f { constructor(e, t) { super(e, t), this.handleMouseDown_ = e => this.handleMouseDown(e), this.handleMouseUp_ = e => this.handleMouseUp(e), this.handleKeyDown_ = e => this.handleKeyDown(e), this.handleClick_ = e => this.handleClick(e), this.handleMouseMove_ = e => this.handleMouseMove(e), this.update_ = e => this.update(e), this.bar = this.getChild(this.options_.barName), this.vertical(!!this.options_.vertical), this.enable() } enabled() { return this.enabled_ } enable() { this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0) } disable() { var e; this.enabled() && (e = this.bar.el_.ownerDocument, this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(e, "mousemove", this.handleMouseMove_), this.off(e, "mouseup", this.handleMouseUp_), this.off(e, "touchmove", this.handleMouseMove_), this.off(e, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1) } createEl(e, t = {}, i = {}) { return t.className = t.className + " vjs-slider", t = Object.assign({ tabIndex: 0 }, t), i = Object.assign({ role: "slider", "aria-valuenow": 0, "aria-valuemin": 0, "aria-valuemax": 100 }, i), super.createEl(e, t, i) } handleMouseDown(e) { var t = this.bar.el_.ownerDocument; "mousedown" === e.type && e.preventDefault(), "touchstart" !== e.type || oe || e.preventDefault(), Me(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(t, "mousemove", this.handleMouseMove_), this.on(t, "mouseup", this.handleMouseUp_), this.on(t, "touchmove", this.handleMouseMove_), this.on(t, "touchend", this.handleMouseUp_), this.handleMouseMove(e, !0) } handleMouseMove(e) { } handleMouseUp(e) { var t = this.bar.el_.ownerDocument; Ne(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(t, "mousemove", this.handleMouseMove_), this.off(t, "mouseup", this.handleMouseUp_), this.off(t, "touchmove", this.handleMouseMove_), this.off(t, "touchend", this.handleMouseUp_), this.update() } update() { if (this.el_ && this.bar) { const t = this.getProgress(); return t !== this.progress_ && (this.progress_ = t, this.requestNamedAnimationFrame("Slider#update", () => { var e = this.vertical() ? "height" : "width"; this.bar.el().style[e] = (100 * t).toFixed(2) + "%" })), t } } getProgress() { return Number(qs(this.getPercent(), 0, 1).toFixed(4)) } calculateDistance(e) { e = Be(this.el_, e); return this.vertical() ? e.y : e.x } handleKeyDown(e) { n.isEventKey(e, "Left") || n.isEventKey(e, "Down") ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : n.isEventKey(e, "Right") || n.isEventKey(e, "Up") ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : super.handleKeyDown(e) } handleClick(e) { e.stopPropagation(), e.preventDefault() } vertical(e) { if (void 0 === e) return this.vertical_ || !1; this.vertical_ = !!e, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal") } } f.registerComponent("Slider", zs); const $s = (e, t) => qs(e / t * 100, 0, 100).toFixed(2) + "%"; class Ws extends f { constructor(e, t) { super(e, t), this.partEls_ = [], this.on(e, "progress", e => this.update(e)) } createEl() { var e = super.createEl("div", { className: "vjs-load-progress" }), t = o("span", { className: "vjs-control-text" }), i = o("span", { textContent: this.localize("Loaded") }), s = document.createTextNode(": "); return this.percentageEl_ = o("span", { className: "vjs-control-text-loaded-percentage", textContent: "0%" }), e.appendChild(t), t.appendChild(i), t.appendChild(s), t.appendChild(this.percentageEl_), e } dispose() { this.partEls_ = null, this.percentageEl_ = null, super.dispose() } update(e) { this.requestNamedAnimationFrame("LoadProgressBar#update", () => { var e = this.player_.liveTracker, i = this.player_.buffered(), e = e && e.isLive() ? e.seekableEnd() : this.player_.duration(), s = this.player_.bufferedEnd(), n = this.partEls_, e = $s(s, e); this.percent_ !== e && (this.el_.style.width = e, we(this.percentageEl_, e), this.percent_ = e); for (let t = 0; t < i.length; t++) { var r = i.start(t), a = i.end(t); let e = n[t]; e || (e = this.el_.appendChild(o()), n[t] = e), e.dataset.start === r && e.dataset.end === a || (e.dataset.start = r, e.dataset.end = a, e.style.left = $s(r, s), e.style.width = $s(a - r, s)) } for (let e = n.length; e > i.length; e--)this.el_.removeChild(n[e - 1]); n.length = i.length }) } } f.registerComponent("LoadProgressBar", Ws); class Gs extends f { constructor(e, t) { super(e, t), this.update = pt(m(this, this.update), 30) } createEl() { return super.createEl("div", { className: "vjs-time-tooltip" }, { "aria-hidden": "true" }) } update(t, i, s) { var n = Ue(this.el_), r = Re(this.player_.el()), i = t.width * i; if (r && n) { var a = t.left - r.left + i, i = t.width - i + (r.right - t.right); let e = n.width / 2; a < e ? e += e - a : i < e && (e = i), e < 0 ? e = 0 : e > n.width && (e = n.width), e = Math.round(e), this.el_.style.right = `-${e}px`, this.write(s) } } write(e) { we(this.el_, e) } updateTime(n, r, a, o) { this.requestNamedAnimationFrame("TimeTooltip#updateTime", () => { let e; var t, i, s = this.player_.duration(); e = this.player_.liveTracker && this.player_.liveTracker.isLive() ? ((i = (t = this.player_.liveTracker.liveWindow()) - r * t) < 1 ? "" : "-") + Vt(i, t) : Vt(a, s), this.update(n, r, e), o && o() }) } } f.registerComponent("TimeTooltip", Gs); class Xs extends f { constructor(e, t) { super(e, t), this.setIcon("circle"), this.update = pt(m(this, this.update), 30) } createEl() { return super.createEl("div", { className: "vjs-play-progress vjs-slider-bar" }, { "aria-hidden": "true" }) } update(e, t) { var i, s = this.getChild("timeTooltip"); s && (i = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), s.updateTime(e, t, i)) } } Xs.prototype.options_ = { children: [] }, u || ie || Xs.prototype.options_.children.push("timeTooltip"), f.registerComponent("PlayProgressBar", Xs); class Ks extends f { constructor(e, t) { super(e, t), this.update = pt(m(this, this.update), 30) } createEl() { return super.createEl("div", { className: "vjs-mouse-display" }) } update(e, t) { var i = t * this.player_.duration(); this.getChild("timeTooltip").updateTime(e, t, i, () => { this.el_.style.left = e.width * t + "px" }) } } Ks.prototype.options_ = { children: ["timeTooltip"] }, f.registerComponent("MouseTimeDisplay", Ks); class Ys extends zs { constructor(e, t) { super(e, t), this.setEventHandlers_() } setEventHandlers_() { this.update_ = m(this, this.update), this.update = pt(this.update_, 30), this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = e => this.enableInterval_(e), this.disableIntervalHandler_ = e => this.disableInterval_(e), this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in document && "visibilityState" in document && this.on(document, "visibilitychange", this.toggleVisibility_) } toggleVisibility_(e) { "hidden" === document.visibilityState ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(e)) : (this.player_.ended() || this.player_.paused() || this.enableInterval_(), this.update()) } enableInterval_() { this.updateInterval || (this.updateInterval = this.setInterval(this.update, 30)) } disableInterval_(e) { this.player_.liveTracker && this.player_.liveTracker.isLive() && e && "ended" !== e.type || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null) } createEl() { return super.createEl("div", { className: "vjs-progress-holder" }, { "aria-label": this.localize("Progress Bar") }) } update(e) { if ("hidden" !== document.visibilityState) { const s = super.update(); return this.requestNamedAnimationFrame("SeekBar#update", () => { var e = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_(), t = this.player_.liveTracker; let i = this.player_.duration(); t && t.isLive() && (i = this.player_.liveTracker.liveCurrentTime()), this.percent_ !== s && (this.el_.setAttribute("aria-valuenow", (100 * s).toFixed(2)), this.percent_ = s), this.currentTime_ === e && this.duration_ === i || (this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [Vt(e, i), Vt(i, i)], "{1} of {2}")), this.currentTime_ = e, this.duration_ = i), this.bar && this.bar.update(Re(this.el()), this.getProgress()) }), s } } userSeek_(e) { this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e) } getCurrentTime_() { return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime() } getPercent() { var e = this.getCurrentTime_(); let t; var i = this.player_.liveTracker; return i && i.isLive() ? (t = (e - i.seekableStart()) / i.liveWindow(), i.atLiveEdge() && (t = 1)) : t = e / this.player_.duration(), t } handleMouseDown(e) { ze(e) && (e.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), super.handleMouseDown(e)) } handleMouseMove(t, i = !1) { if (ze(t) && !isNaN(this.player_.duration())) { i || this.player_.scrubbing() || this.player_.scrubbing(!0); let e; i = this.calculateDistance(t), t = this.player_.liveTracker; if (t && t.isLive()) { if (.99 <= i) return void t.seekToLiveEdge(); var s = t.seekableStart(), n = t.liveCurrentTime(); if ((e = (e = (e = s + i * t.liveWindow()) >= n ? n : e) <= s ? s + .1 : e) === 1 / 0) return } else (e = i * this.player_.duration()) === this.player_.duration() && (e -= .1); this.userSeek_(e) } } enable() { super.enable(); var e = this.getChild("mouseTimeDisplay"); e && e.show() } disable() { super.disable(); var e = this.getChild("mouseTimeDisplay"); e && e.hide() } handleMouseUp(e) { super.handleMouseUp(e), e && e.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }), this.videoWasPlaying ? Gt(this.player_.play()) : this.update_() } stepForward() { this.userSeek_(this.player_.currentTime() + 5) } stepBack() { this.userSeek_(this.player_.currentTime() - 5) } handleAction(e) { this.player_.paused() ? this.player_.play() : this.player_.pause() } handleKeyDown(e) { var t, i = this.player_.liveTracker; n.isEventKey(e, "Space") || n.isEventKey(e, "Enter") ? (e.preventDefault(), e.stopPropagation(), this.handleAction(e)) : n.isEventKey(e, "Home") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(0)) : n.isEventKey(e, "End") ? (e.preventDefault(), e.stopPropagation(), i && i.isLive() ? this.userSeek_(i.liveCurrentTime()) : this.userSeek_(this.player_.duration())) : /^[0-9]$/.test(n(e)) ? (e.preventDefault(), e.stopPropagation(), t = 10 * (n.codes[n(e)] - n.codes[0]) / 100, i && i.isLive() ? this.userSeek_(i.seekableStart() + i.liveWindow() * t) : this.userSeek_(this.player_.duration() * t)) : n.isEventKey(e, "PgDn") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() - 60)) : n.isEventKey(e, "PgUp") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() + 60)) : super.handleKeyDown(e) } dispose() { this.disableInterval_(), this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in document && "visibilityState" in document && this.off(document, "visibilitychange", this.toggleVisibility_), super.dispose() } } Ys.prototype.options_ = { children: ["loadProgressBar", "playProgressBar"], barName: "playProgressBar" }, u || ie || Ys.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"), f.registerComponent("SeekBar", Ys); class Qs extends f { constructor(e, t) { super(e, t), this.handleMouseMove = pt(m(this, this.handleMouseMove), 30), this.throttledHandleMouseSeek = pt(m(this, this.handleMouseSeek), 30), this.handleMouseUpHandler_ = e => this.handleMouseUp(e), this.handleMouseDownHandler_ = e => this.handleMouseDown(e), this.enable() } createEl() { return super.createEl("div", { className: "vjs-progress-control vjs-control" }) } handleMouseMove(e) { var t, i, s, n, r = this.getChild("seekBar"); r && (t = r.getChild("playProgressBar"), i = r.getChild("mouseTimeDisplay"), t || i) && (s = Ue(n = r.el()), n = qs(n = Be(n, e).x, 0, 1), i && i.update(s, n), t) && t.update(s, r.getProgress()) } handleMouseSeek(e) { var t = this.getChild("seekBar"); t && t.handleMouseMove(e) } enabled() { return this.enabled_ } disable() { var e; this.children().forEach(e => e.disable && e.disable()), this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, "mousemove", this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing()) && (e = this.getChild("seekBar"), this.player_.scrubbing(!1), e.videoWasPlaying) && Gt(this.player_.play()) } enable() { this.children().forEach(e => e.enable && e.enable()), this.enabled() || (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0) } removeListenersAddedOnMousedownAndTouchstart() { var e = this.el_.ownerDocument; this.off(e, "mousemove", this.throttledHandleMouseSeek), this.off(e, "touchmove", this.throttledHandleMouseSeek), this.off(e, "mouseup", this.handleMouseUpHandler_), this.off(e, "touchend", this.handleMouseUpHandler_) } handleMouseDown(e) { var t = this.el_.ownerDocument, i = this.getChild("seekBar"); i && i.handleMouseDown(e), this.on(t, "mousemove", this.throttledHandleMouseSeek), this.on(t, "touchmove", this.throttledHandleMouseSeek), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_) } handleMouseUp(e) { var t = this.getChild("seekBar"); t && t.handleMouseUp(e), this.removeListenersAddedOnMousedownAndTouchstart() } } Qs.prototype.options_ = { children: ["seekBar"] }, f.registerComponent("ProgressControl", Qs); class Js extends s { constructor(e, t) { super(e, t), this.setIcon("picture-in-picture-enter"), this.on(e, ["enterpictureinpicture", "leavepictureinpicture"], e => this.handlePictureInPictureChange(e)), this.on(e, ["disablepictureinpicturechanged", "loadedmetadata"], e => this.handlePictureInPictureEnabledChange(e)), this.on(e, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], () => this.handlePictureInPictureAudioModeChange()), this.disable() } buildCSSClass() { return "vjs-picture-in-picture-control vjs-hidden " + super.buildCSSClass() } handlePictureInPictureAudioModeChange() { "audio" === this.player_.currentType().substring(0, 5) || this.player_.audioPosterMode() || this.player_.audioOnlyMode() ? (this.player_.isInPictureInPicture() && this.player_.exitPictureInPicture(), this.hide()) : this.show() } handlePictureInPictureEnabledChange() { document.pictureInPictureEnabled && !1 === this.player_.disablePictureInPicture() || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in window ? this.enable() : this.disable() } handlePictureInPictureChange(e) { this.player_.isInPictureInPicture() ? (this.setIcon("picture-in-picture-exit"), this.controlText("Exit Picture-in-Picture")) : (this.setIcon("picture-in-picture-enter"), this.controlText("Picture-in-Picture")), this.handlePictureInPictureEnabledChange() } handleClick(e) { this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture() } show() { "function" == typeof document.exitPictureInPicture && super.show() } } Js.prototype.controlText_ = "Picture-in-Picture", f.registerComponent("PictureInPictureToggle", Js); class Zs extends s { constructor(e, t) { super(e, t), this.setIcon("fullscreen-enter"), this.on(e, "fullscreenchange", e => this.handleFullscreenChange(e)), !1 === document[e.fsApi_.fullscreenEnabled] && this.disable() } buildCSSClass() { return "vjs-fullscreen-control " + super.buildCSSClass() } handleFullscreenChange(e) { this.player_.isFullscreen() ? (this.controlText("Exit Fullscreen"), this.setIcon("fullscreen-exit")) : (this.controlText("Fullscreen"), this.setIcon("fullscreen-enter")) } handleClick(e) { this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen() } } Zs.prototype.controlText_ = "Fullscreen", f.registerComponent("FullscreenToggle", Zs); class en extends f { createEl() { var e = super.createEl("div", { className: "vjs-volume-level" }); return this.setIcon("circle", e), e.appendChild(super.createEl("span", { className: "vjs-control-text" })), e } } f.registerComponent("VolumeLevel", en); class tn extends f { constructor(e, t) { super(e, t), this.update = pt(m(this, this.update), 30) } createEl() { return super.createEl("div", { className: "vjs-volume-tooltip" }, { "aria-hidden": "true" }) } update(t, i, s, e) { if (!s) { var s = Re(this.el_), n = Re(this.player_.el()), i = t.width * i; if (!n || !s) return; var r = t.left - n.left + i, i = t.width - i + (n.right - t.right); let e = s.width / 2; r < e ? e += e - r : i < e && (e = i), e < 0 ? e = 0 : e > s.width && (e = s.width), this.el_.style.right = `-${e}px` } this.write(e + "%") } write(e) { we(this.el_, e) } updateVolume(e, t, i, s, n) { this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", () => { this.update(e, t, i, s.toFixed(0)), n && n() }) } } f.registerComponent("VolumeLevelTooltip", tn); class sn extends f { constructor(e, t) { super(e, t), this.update = pt(m(this, this.update), 30) } createEl() { return super.createEl("div", { className: "vjs-mouse-display" }) } update(e, t, i) { var s = 100 * t; this.getChild("volumeLevelTooltip").updateVolume(e, t, i, s, () => { i ? this.el_.style.bottom = e.height * t + "px" : this.el_.style.left = e.width * t + "px" }) } } sn.prototype.options_ = { children: ["volumeLevelTooltip"] }, f.registerComponent("MouseVolumeLevelDisplay", sn); class nn extends zs { constructor(e, t) { super(e, t), this.on("slideractive", e => this.updateLastVolume_(e)), this.on(e, "volumechange", e => this.updateARIAAttributes(e)), e.ready(() => this.updateARIAAttributes()) } createEl() { return super.createEl("div", { className: "vjs-volume-bar vjs-slider-bar" }, { "aria-label": this.localize("Volume Level"), "aria-live": "polite" }) } handleMouseDown(e) { ze(e) && super.handleMouseDown(e) } handleMouseMove(e) { var t, i, s, n = this.getChild("mouseVolumeLevelDisplay"); n && (t = Re(s = this.el()), i = this.vertical(), s = Be(s, e), s = qs(s = i ? s.y : s.x, 0, 1), n.update(t, s, i)), ze(e) && (this.checkMuted(), this.player_.volume(this.calculateDistance(e))) } checkMuted() { this.player_.muted() && this.player_.muted(!1) } getPercent() { return this.player_.muted() ? 0 : this.player_.volume() } stepForward() { this.checkMuted(), this.player_.volume(this.player_.volume() + .1) } stepBack() { this.checkMuted(), this.player_.volume(this.player_.volume() - .1) } updateARIAAttributes(e) { var t = this.player_.muted() ? 0 : this.volumeAsPercentage_(); this.el_.setAttribute("aria-valuenow", t), this.el_.setAttribute("aria-valuetext", t + "%") } volumeAsPercentage_() { return Math.round(100 * this.player_.volume()) } updateLastVolume_() { const e = this.player_.volume(); this.one("sliderinactive", () => { 0 === this.player_.volume() && this.player_.lastVolume_(e) }) } } nn.prototype.options_ = { children: ["volumeLevel"], barName: "volumeLevel" }, u || ie || nn.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay"), nn.prototype.playerEvent = "volumechange", f.registerComponent("VolumeBar", nn); class rn extends f { constructor(e, t = {}) { var i, s; t.vertical = t.vertical || !1, "undefined" != typeof t.volumeBar && !Y(t.volumeBar) || (t.volumeBar = t.volumeBar || {}, t.volumeBar.vertical = t.vertical), super(e, t), i = this, (s = e).tech_ && !s.tech_.featuresVolumeControl && i.addClass("vjs-hidden"), i.on(s, "loadstart", function () { s.tech_.featuresVolumeControl ? i.removeClass("vjs-hidden") : i.addClass("vjs-hidden") }), this.throttledHandleMouseMove = pt(m(this, this.handleMouseMove), 30), this.handleMouseUpHandler_ = e => this.handleMouseUp(e), this.on("mousedown", e => this.handleMouseDown(e)), this.on("touchstart", e => this.handleMouseDown(e)), this.on("mousemove", e => this.handleMouseMove(e)), this.on(this.volumeBar, ["focus", "slideractive"], () => { this.volumeBar.addClass("vjs-slider-active"), this.addClass("vjs-slider-active"), this.trigger("slideractive") }), this.on(this.volumeBar, ["blur", "sliderinactive"], () => { this.volumeBar.removeClass("vjs-slider-active"), this.removeClass("vjs-slider-active"), this.trigger("sliderinactive") }) } createEl() { let e = "vjs-volume-horizontal"; return this.options_.vertical && (e = "vjs-volume-vertical"), super.createEl("div", { className: "vjs-volume-control vjs-control " + e }) } handleMouseDown(e) { var t = this.el_.ownerDocument; this.on(t, "mousemove", this.throttledHandleMouseMove), this.on(t, "touchmove", this.throttledHandleMouseMove), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_) } handleMouseUp(e) { var t = this.el_.ownerDocument; this.off(t, "mousemove", this.throttledHandleMouseMove), this.off(t, "touchmove", this.throttledHandleMouseMove), this.off(t, "mouseup", this.handleMouseUpHandler_), this.off(t, "touchend", this.handleMouseUpHandler_) } handleMouseMove(e) { this.volumeBar.handleMouseMove(e) } } rn.prototype.options_ = { children: ["volumeBar"] }, f.registerComponent("VolumeControl", rn); class an extends s { constructor(e, t) { var i, s; super(e, t), i = this, (s = e).tech_ && !s.tech_.featuresMuteControl && i.addClass("vjs-hidden"), i.on(s, "loadstart", function () { s.tech_.featuresMuteControl ? i.removeClass("vjs-hidden") : i.addClass("vjs-hidden") }), this.on(e, ["loadstart", "volumechange"], e => this.update(e)) } buildCSSClass() { return "vjs-mute-control " + super.buildCSSClass() } handleClick(e) { var t = this.player_.volume(), i = this.player_.lastVolume_(); 0 === t ? (this.player_.volume(i < .1 ? .1 : i), this.player_.muted(!1)) : this.player_.muted(!this.player_.muted()) } update(e) { this.updateIcon_(), this.updateControlText_() } updateIcon_() { var e = this.player_.volume(); let t = 3; this.setIcon("volume-high"), u && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), 0 === e || this.player_.muted() ? (this.setIcon("volume-mute"), t = 0) : e < .33 ? (this.setIcon("volume-low"), t = 1) : e < .67 && (this.setIcon("volume-medium"), t = 2), Ie(this.el_, [0, 1, 2, 3].reduce((e, t) => e + `${t ? " " : ""}vjs-vol-` + t, "")), ke(this.el_, "vjs-vol-" + t) } updateControlText_() { var e = this.player_.muted() || 0 === this.player_.volume() ? "Unmute" : "Mute"; this.controlText() !== e && this.controlText(e) } } an.prototype.controlText_ = "Mute", f.registerComponent("MuteToggle", an); class on extends f { constructor(e, t = {}) { "undefined" != typeof t.inline ? t.inline = t.inline : t.inline = !0, "undefined" != typeof t.volumeControl && !Y(t.volumeControl) || (t.volumeControl = t.volumeControl || {}, t.volumeControl.vertical = !t.inline), super(e, t), this.handleKeyPressHandler_ = e => this.handleKeyPress(e), this.on(e, ["loadstart"], e => this.volumePanelState_(e)), this.on(this.muteToggle, "keyup", e => this.handleKeyPress(e)), this.on(this.volumeControl, "keyup", e => this.handleVolumeControlKeyUp(e)), this.on("keydown", e => this.handleKeyPress(e)), this.on("mouseover", e => this.handleMouseOver(e)), this.on("mouseout", e => this.handleMouseOut(e)), this.on(this.volumeControl, ["slideractive"], this.sliderActive_), this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_) } sliderActive_() { this.addClass("vjs-slider-active") } sliderInactive_() { this.removeClass("vjs-slider-active") } volumePanelState_() { this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only") } createEl() { let e = "vjs-volume-panel-horizontal"; return this.options_.inline || (e = "vjs-volume-panel-vertical"), super.createEl("div", { className: "vjs-volume-panel vjs-control " + e }) } dispose() { this.handleMouseOut(), super.dispose() } handleVolumeControlKeyUp(e) { n.isEventKey(e, "Esc") && this.muteToggle.focus() } handleMouseOver(e) { this.addClass("vjs-hover"), lt(document, "keyup", this.handleKeyPressHandler_) } handleMouseOut(e) { this.removeClass("vjs-hover"), p(document, "keyup", this.handleKeyPressHandler_) } handleKeyPress(e) { n.isEventKey(e, "Esc") && this.handleMouseOut() } } on.prototype.options_ = { children: ["muteToggle", "volumeControl"] }, f.registerComponent("VolumePanel", on); s; f.registerComponent("SkipForward", class extends s { constructor(e, t) { super(e, t), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipForwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon("forward-" + this.skipTime), this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime])), this.show()) : this.hide() } getSkipForwardTime() { var e = this.options_.playerOptions; return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.forward } buildCSSClass() { return `vjs-skip-forward-${this.getSkipForwardTime()} ` + super.buildCSSClass() } handleClick(e) { if (!isNaN(this.player_.duration())) { var t = this.player_.currentTime(), i = this.player_.liveTracker, i = i && i.isLive() ? i.seekableEnd() : this.player_.duration(); let e; e = t + this.skipTime <= i ? t + this.skipTime : i, this.player_.currentTime(e) } } handleLanguagechange() { this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime])) } }); class ln extends s { constructor(e, t) { super(e, t), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipBackwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon("replay-" + this.skipTime), this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime])), this.show()) : this.hide() } getSkipBackwardTime() { var e = this.options_.playerOptions; return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.backward } buildCSSClass() { return `vjs-skip-backward-${this.getSkipBackwardTime()} ` + super.buildCSSClass() } handleClick(e) { var t = this.player_.currentTime(), i = this.player_.liveTracker, i = i && i.isLive() && i.seekableStart(); let s; s = i && t - this.skipTime <= i ? i : t >= this.skipTime ? t - this.skipTime : 0, this.player_.currentTime(s) } handleLanguagechange() { this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime])) } } ln.prototype.controlText_ = "Skip Backward", f.registerComponent("SkipBackward", ln); class dn extends f { constructor(e, t) { super(e, t), t && (this.menuButton_ = t.menuButton), this.focusedChild_ = -1, this.on("keydown", e => this.handleKeyDown(e)), this.boundHandleBlur_ = e => this.handleBlur(e), this.boundHandleTapClick_ = e => this.handleTapClick(e) } addEventListenerForItem(e) { e instanceof f && (this.on(e, "blur", this.boundHandleBlur_), this.on(e, ["tap", "click"], this.boundHandleTapClick_)) } removeEventListenerForItem(e) { e instanceof f && (this.off(e, "blur", this.boundHandleBlur_), this.off(e, ["tap", "click"], this.boundHandleTapClick_)) } removeChild(e) { "string" == typeof e && (e = this.getChild(e)), this.removeEventListenerForItem(e), super.removeChild(e) } addItem(e) { e = this.addChild(e); e && this.addEventListenerForItem(e) } createEl() { var e = this.options_.contentElType || "ul", e = (this.contentEl_ = o(e, { className: "vjs-menu-content" }), this.contentEl_.setAttribute("role", "menu"), super.createEl("div", { append: this.contentEl_, className: "vjs-menu" })); return e.appendChild(this.contentEl_), lt(e, "click", function (e) { e.preventDefault(), e.stopImmediatePropagation() }), e } dispose() { this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, super.dispose() } handleBlur(e) { const t = e.relatedTarget || document.activeElement; this.children().some(e => e.el() === t) || (e = this.menuButton_) && e.buttonPressed_ && t !== e.el().firstChild && e.unpressButton() } handleTapClick(t) { var e; this.menuButton_ && (this.menuButton_.unpressButton(), e = this.children(), Array.isArray(e)) && (e = e.filter(e => e.el() === t.target)[0]) && "CaptionSettingsMenuItem" !== e.name() && this.menuButton_.focus() } handleKeyDown(e) { n.isEventKey(e, "Left") || n.isEventKey(e, "Down") ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (n.isEventKey(e, "Right") || n.isEventKey(e, "Up")) && (e.preventDefault(), e.stopPropagation(), this.stepBack()) } stepForward() { let e = 0; void 0 !== this.focusedChild_ && (e = this.focusedChild_ + 1), this.focus(e) } stepBack() { let e = 0; void 0 !== this.focusedChild_ && (e = this.focusedChild_ - 1), this.focus(e) } focus(e = 0) { var t = this.children().slice(); t.length && t[0].hasClass("vjs-menu-title") && t.shift(), 0 < t.length && (e < 0 ? e = 0 : e >= t.length && (e = t.length - 1), t[this.focusedChild_ = e].el_.focus()) } } f.registerComponent("Menu", dn); class hn extends f { constructor(e, t = {}) { super(e, t), this.menuButton_ = new s(e, t), this.menuButton_.controlText(this.controlText_), this.menuButton_.el_.setAttribute("aria-haspopup", "true"); e = s.prototype.buildCSSClass(), this.menuButton_.el_.className = this.buildCSSClass() + " " + e, this.menuButton_.removeClass("vjs-control"), this.addChild(this.menuButton_), this.update(), this.enabled_ = !0, t = e => this.handleClick(e); this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e), this.on(this.menuButton_, "tap", t), this.on(this.menuButton_, "click", t), this.on(this.menuButton_, "keydown", e => this.handleKeyDown(e)), this.on(this.menuButton_, "mouseenter", () => { this.addClass("vjs-hover"), this.menu.show(), lt(document, "keyup", this.handleMenuKeyUp_) }), this.on("mouseleave", e => this.handleMouseLeave(e)), this.on("keydown", e => this.handleSubmenuKeyDown(e)) } update() { var e = this.createMenu(); this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = e, this.addChild(e), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu")) } createMenu() { var e, t = new dn(this.player_, { menuButton: this }); if (this.hideThreshold_ = 0, this.options_.title && (e = o("li", { className: "vjs-menu-title", textContent: g(this.options_.title), tabIndex: -1 }), e = new f(this.player_, { el: e }), t.addItem(e)), this.items = this.createItems(), this.items) for (let e = 0; e < this.items.length; e++)t.addItem(this.items[e]); return t } createItems() { } createEl() { return super.createEl("div", { className: this.buildWrapperCSSClass() }, {}) } setIcon(e) { super.setIcon(e, this.menuButton_.el_) } buildWrapperCSSClass() { let e = "vjs-menu-button"; !0 === this.options_.inline ? e += "-inline" : e += "-popup"; var t = s.prototype.buildCSSClass(); return `vjs-menu-button ${e} ${t} ` + super.buildCSSClass() } buildCSSClass() { let e = "vjs-menu-button"; return !0 === this.options_.inline ? e += "-inline" : e += "-popup", `vjs-menu-button ${e} ` + super.buildCSSClass() } controlText(e, t = this.menuButton_.el()) { return this.menuButton_.controlText(e, t) } dispose() { this.handleMouseLeave(), super.dispose() } handleClick(e) { this.buttonPressed_ ? this.unpressButton() : this.pressButton() } handleMouseLeave(e) { this.removeClass("vjs-hover"), p(document, "keyup", this.handleMenuKeyUp_) } focus() { this.menuButton_.focus() } blur() { this.menuButton_.blur() } handleKeyDown(e) { n.isEventKey(e, "Esc") || n.isEventKey(e, "Tab") ? (this.buttonPressed_ && this.unpressButton(), n.isEventKey(e, "Tab") || (e.preventDefault(), this.menuButton_.focus())) : !n.isEventKey(e, "Up") && !n.isEventKey(e, "Down") || this.buttonPressed_ || (e.preventDefault(), this.pressButton()) } handleMenuKeyUp(e) { (n.isEventKey(e, "Esc") || n.isEventKey(e, "Tab")) && this.removeClass("vjs-hover") } handleSubmenuKeyPress(e) { this.handleSubmenuKeyDown(e) } handleSubmenuKeyDown(e) { (n.isEventKey(e, "Esc") || n.isEventKey(e, "Tab")) && (this.buttonPressed_ && this.unpressButton(), n.isEventKey(e, "Tab") || (e.preventDefault(), this.menuButton_.focus())) } pressButton() { this.enabled_ && (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), u && Te() || this.menu.focus()) } unpressButton() { this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false")) } disable() { this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable() } enable() { this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable() } } f.registerComponent("MenuButton", hn); class un extends hn { constructor(e, t) { const i = t.tracks; if (super(e, t), this.items.length <= 1 && this.hide(), i) { const s = m(this, this.update); i.addEventListener("removetrack", s), i.addEventListener("addtrack", s), i.addEventListener("labelchange", s), this.player_.on("ready", s), this.player_.on("dispose", function () { i.removeEventListener("removetrack", s), i.removeEventListener("addtrack", s), i.removeEventListener("labelchange", s) }) } } } f.registerComponent("TrackButton", un); const cn = ["Tab", "Esc", "Up", "Down", "Right", "Left"]; class pn extends ks { constructor(e, t) { super(e, t), this.selectable = t.selectable, this.isSelected_ = t.selected || !1, this.multiSelectable = t.multiSelectable, this.selected(this.isSelected_), this.selectable ? this.multiSelectable ? this.el_.setAttribute("role", "menuitemcheckbox") : this.el_.setAttribute("role", "menuitemradio") : this.el_.setAttribute("role", "menuitem") } createEl(e, t, i) { this.nonIconControl = !0; t = super.createEl("li", Object.assign({ className: "vjs-menu-item", tabIndex: -1 }, t), i), i = o("span", { className: "vjs-menu-item-text", textContent: this.localize(this.options_.label) }); return this.player_.options_.experimentalSvgIcons ? t.appendChild(i) : t.replaceChild(i, t.querySelector(".vjs-icon-placeholder")), t } handleKeyDown(t) { cn.some(e => n.isEventKey(t, e)) || super.handleKeyDown(t) } handleClick(e) { this.selected(!0) } selected(e) { this.selectable && (e ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1)) } } f.registerComponent("MenuItem", pn); class mn extends pn { constructor(e, t) { var i = t.track; const s = e.textTracks(), n = (t.label = i.label || i.language || "Unknown", t.selected = "showing" === i.mode, super(e, t), this.track = i, this.kinds = (t.kinds || [t.kind || this.track.kind]).filter(Boolean), (...e) => { this.handleTracksChange.apply(this, e) }), r = (...e) => { this.handleSelectedLanguageChange.apply(this, e) }; if (e.on(["loadstart", "texttrackchange"], n), s.addEventListener("change", n), s.addEventListener("selectedlanguagechange", r), this.on("dispose", function () { e.off(["loadstart", "texttrackchange"], n), s.removeEventListener("change", n), s.removeEventListener("selectedlanguagechange", r) }), void 0 === s.onchange) { let e; this.on(["tap", "click"], function () { if ("object" != typeof window.Event) try { e = new window.Event("change") } catch (e) { } e || (e = document.createEvent("Event")).initEvent("change", !0, !0), s.dispatchEvent(e) }) } this.handleTracksChange() } handleClick(e) { var t = this.track, i = this.player_.textTracks(); if (super.handleClick(e), i) for (let e = 0; e < i.length; e++) { var s = i[e]; -1 !== this.kinds.indexOf(s.kind) && (s === t ? "showing" !== s.mode && (s.mode = "showing") : "disabled" !== s.mode && (s.mode = "disabled")) } } handleTracksChange(e) { var t = "showing" === this.track.mode; t !== this.isSelected_ && this.selected(t) } handleSelectedLanguageChange(e) { var t; "showing" !== this.track.mode || (t = this.player_.cache_.selectedLanguage) && t.enabled && t.language === this.track.language && t.kind !== this.track.kind || (this.player_.cache_.selectedLanguage = { enabled: !0, language: this.track.language, kind: this.track.kind }) } dispose() { this.track = null, super.dispose() } } f.registerComponent("TextTrackMenuItem", mn); class gn extends mn { constructor(e, t) { t.track = { player: e, kind: t.kind, kinds: t.kinds, default: !1, mode: "disabled" }, t.kinds || (t.kinds = [t.kind]), t.label ? t.track.label = t.label : t.track.label = t.kinds.join(" and ") + " off", t.selectable = !0, t.multiSelectable = !1, super(e, t) } handleTracksChange(e) { var i = this.player().textTracks(); let s = !0; for (let e = 0, t = i.length; e < t; e++) { var n = i[e]; if (-1 < this.options_.kinds.indexOf(n.kind) && "showing" === n.mode) { s = !1; break } } s !== this.isSelected_ && this.selected(s) } handleSelectedLanguageChange(e) { var i = this.player().textTracks(); let s = !0; for (let e = 0, t = i.length; e < t; e++) { var n = i[e]; if (-1 < ["captions", "descriptions", "subtitles"].indexOf(n.kind) && "showing" === n.mode) { s = !1; break } } s && (this.player_.cache_.selectedLanguage = { enabled: !1 }) } handleLanguagechange() { this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label), super.handleLanguagechange() } } f.registerComponent("OffTextTrackMenuItem", gn); class fn extends un { constructor(e, t = {}) { t.tracks = e.textTracks(), super(e, t) } createItems(t = [], i = mn) { let e; this.label_ && (e = this.label_ + " off"), t.push(new gn(this.player_, { kinds: this.kinds_, kind: this.kind_, label: e })), this.hideThreshold_ += 1; var s = this.player_.textTracks(); Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]); for (let e = 0; e < s.length; e++) { var n, r = s[e]; -1 < this.kinds_.indexOf(r.kind) && ((n = new i(this.player_, { track: r, kinds: this.kinds_, kind: this.kind_, selectable: !0, multiSelectable: !1 })).addClass(`vjs-${r.kind}-menu-item`), t.push(n)) } return t } } f.registerComponent("TextTrackButton", fn); class yn extends pn { constructor(e, t) { var i = t.track, s = t.cue, n = e.currentTime(); t.selectable = !0, t.multiSelectable = !1, t.label = s.text, t.selected = s.startTime <= n && n < s.endTime, super(e, t), this.track = i, this.cue = s } handleClick(e) { super.handleClick(), this.player_.currentTime(this.cue.startTime) } } f.registerComponent("ChaptersTrackMenuItem", yn); class _n extends fn { constructor(e, t, i) { super(e, t, i), this.setIcon("chapters"), this.selectCurrentItem_ = () => { this.items.forEach(e => { e.selected(this.track_.activeCues[0] === e.cue) }) } } buildCSSClass() { return "vjs-chapters-button " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-chapters-button " + super.buildWrapperCSSClass() } update(e) { e && e.track && "chapters" !== e.track.kind || ((e = this.findChaptersTrack()) !== this.track_ ? (this.setTrack(e), super.update()) : (!this.items || e && e.cues && e.cues.length !== this.items.length) && super.update()) } setTrack(e) { var t; this.track_ !== e && (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_ && ((t = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_)) && t.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null), this.track_ = e, this.track_) && (this.track_.mode = "hidden", (t = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_)) && t.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_)) } findChaptersTrack() { var t = this.player_.textTracks() || []; for (let e = t.length - 1; 0 <= e; e--) { var i = t[e]; if (i.kind === this.kind_) return i } } getMenuCaption() { return this.track_ && this.track_.label ? this.track_.label : this.localize(g(this.kind_)) } createMenu() { return this.options_.title = this.getMenuCaption(), super.createMenu() } createItems() { var i = []; if (this.track_) { var s = this.track_.cues; if (s) for (let e = 0, t = s.length; e < t; e++) { var n = s[e], n = new yn(this.player_, { track: this.track_, cue: n }); i.push(n) } } return i } } _n.prototype.kind_ = "chapters", _n.prototype.controlText_ = "Chapters", f.registerComponent("ChaptersButton", _n); class vn extends fn { constructor(e, t, i) { super(e, t, i), this.setIcon("audio-description"); const s = e.textTracks(), n = m(this, this.handleTracksChange); s.addEventListener("change", n), this.on("dispose", function () { s.removeEventListener("change", n) }) } handleTracksChange(e) { var i = this.player().textTracks(); let s = !1; for (let e = 0, t = i.length; e < t; e++) { var n = i[e]; if (n.kind !== this.kind_ && "showing" === n.mode) { s = !0; break } } s ? this.disable() : this.enable() } buildCSSClass() { return "vjs-descriptions-button " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-descriptions-button " + super.buildWrapperCSSClass() } } vn.prototype.kind_ = "descriptions", vn.prototype.controlText_ = "Descriptions", f.registerComponent("DescriptionsButton", vn); class bn extends fn { constructor(e, t, i) { super(e, t, i), this.setIcon("subtitles") } buildCSSClass() { return "vjs-subtitles-button " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-subtitles-button " + super.buildWrapperCSSClass() } } bn.prototype.kind_ = "subtitles", bn.prototype.controlText_ = "Subtitles", f.registerComponent("SubtitlesButton", bn); class Tn extends mn { constructor(e, t) { t.track = { player: e, kind: t.kind, label: t.kind + " settings", selectable: !1, default: !1, mode: "disabled" }, t.selectable = !1, t.name = "CaptionSettingsMenuItem", super(e, t), this.addClass("vjs-texttrack-settings"), this.controlText(", opens " + t.kind + " settings dialog") } handleClick(e) { this.player().getChild("textTrackSettings").open() } handleLanguagechange() { this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings"), super.handleLanguagechange() } } f.registerComponent("CaptionSettingsMenuItem", Tn); class Sn extends fn { constructor(e, t, i) { super(e, t, i), this.setIcon("captions") } buildCSSClass() { return "vjs-captions-button " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-captions-button " + super.buildWrapperCSSClass() } createItems() { var e = []; return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new Tn(this.player_, { kind: this.kind_ })), this.hideThreshold_ += 1), super.createItems(e) } } Sn.prototype.kind_ = "captions", Sn.prototype.controlText_ = "Captions", f.registerComponent("CaptionsButton", Sn); class wn extends mn { createEl(e, t, i) { e = super.createEl(e, t, i), t = e.querySelector(".vjs-menu-item-text"); return "captions" === this.options_.track.kind && (this.player_.options_.experimentalSvgIcons ? this.setIcon("captions", e) : t.appendChild(o("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), t.appendChild(o("span", { className: "vjs-control-text", textContent: " " + this.localize("Captions") }))), e } } f.registerComponent("SubsCapsMenuItem", wn); class En extends fn { constructor(e, t = {}) { super(e, t), this.label_ = "subtitles", this.setIcon("subtitles"), -1 < ["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) && (this.label_ = "captions", this.setIcon("captions")), this.menuButton_.controlText(g(this.label_)) } buildCSSClass() { return "vjs-subs-caps-button " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-subs-caps-button " + super.buildWrapperCSSClass() } createItems() { let e = []; return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new Tn(this.player_, { kind: this.label_ })), this.hideThreshold_ += 1), e = super.createItems(e, wn) } } En.prototype.kinds_ = ["captions", "subtitles"], En.prototype.controlText_ = "Subtitles", f.registerComponent("SubsCapsButton", En); class Cn extends pn { constructor(e, t) { var i = t.track; const s = e.audioTracks(), n = (t.label = i.label || i.language || "Unknown", t.selected = i.enabled, super(e, t), this.track = i, this.addClass(`vjs-${i.kind}-menu-item`), (...e) => { this.handleTracksChange.apply(this, e) }); s.addEventListener("change", n), this.on("dispose", () => { s.removeEventListener("change", n) }) } createEl(e, t, i) { e = super.createEl(e, t, i), t = e.querySelector(".vjs-menu-item-text"); return 0 <= ["main-desc", "description"].indexOf(this.options_.track.kind) && (t.appendChild(o("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), t.appendChild(o("span", { className: "vjs-control-text", textContent: " " + this.localize("Descriptions") }))), e } handleClick(e) { if (super.handleClick(e), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks) { var t = this.player_.audioTracks(); for (let e = 0; e < t.length; e++) { var i = t[e]; i !== this.track && (i.enabled = i === this.track) } } } handleTracksChange(e) { this.selected(this.track.enabled) } } f.registerComponent("AudioTrackMenuItem", Cn); class kn extends un { constructor(e, t = {}) { t.tracks = e.audioTracks(), super(e, t), this.setIcon("audio") } buildCSSClass() { return "vjs-audio-button " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-audio-button " + super.buildWrapperCSSClass() } createItems(t = []) { this.hideThreshold_ = 1; var i = this.player_.audioTracks(); for (let e = 0; e < i.length; e++) { var s = i[e]; t.push(new Cn(this.player_, { track: s, selectable: !0, multiSelectable: !1 })) } return t } } kn.prototype.controlText_ = "Audio Track", f.registerComponent("AudioTrackButton", kn); class In extends pn { constructor(e, t) { var i = t.rate, s = parseFloat(i, 10); t.label = i, t.selected = s === e.playbackRate(), t.selectable = !0, t.multiSelectable = !1, super(e, t), this.label = i, this.rate = s, this.on(e, "ratechange", e => this.update(e)) } handleClick(e) { super.handleClick(), this.player().playbackRate(this.rate) } update(e) { this.selected(this.player().playbackRate() === this.rate) } } In.prototype.contentElType = "button", f.registerComponent("PlaybackRateMenuItem", In); class xn extends hn { constructor(e, t) { super(e, t), this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_), this.updateVisibility(), this.updateLabel(), this.on(e, "loadstart", e => this.updateVisibility(e)), this.on(e, "ratechange", e => this.updateLabel(e)), this.on(e, "playbackrateschange", e => this.handlePlaybackRateschange(e)) } createEl() { var e = super.createEl(); return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = o("div", { className: "vjs-playback-rate-value", id: this.labelElId_, textContent: "1x" }), e.appendChild(this.labelEl_), e } dispose() { this.labelEl_ = null, super.dispose() } buildCSSClass() { return "vjs-playback-rate " + super.buildCSSClass() } buildWrapperCSSClass() { return "vjs-playback-rate " + super.buildWrapperCSSClass() } createItems() { var t = this.playbackRates(), i = []; for (let e = t.length - 1; 0 <= e; e--)i.push(new In(this.player(), { rate: t[e] + "x" })); return i } handlePlaybackRateschange(e) { this.update() } playbackRates() { var e = this.player(); return e.playbackRates && e.playbackRates() || [] } playbackRateSupported() { return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && 0 < this.playbackRates().length } updateVisibility(e) { this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden") } updateLabel(e) { this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x") } } xn.prototype.controlText_ = "Playback Rate", f.registerComponent("PlaybackRateMenuButton", xn); class An extends f { buildCSSClass() { return "vjs-spacer " + super.buildCSSClass() } createEl(e = "div", t = {}, i = {}) { return t.className || (t.className = this.buildCSSClass()), super.createEl(e, t, i) } } f.registerComponent("Spacer", An); f.registerComponent("CustomControlSpacer", class extends An { buildCSSClass() { return "vjs-custom-control-spacer " + super.buildCSSClass() } createEl() { return super.createEl("div", { className: this.buildCSSClass(), textContent: " " }) } }); class Ln extends f { createEl() { return super.createEl("div", { className: "vjs-control-bar", dir: "ltr" }) } } Ln.prototype.options_ = { children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle"] }, f.registerComponent("ControlBar", Ln); class Pn extends Jt { constructor(e, t) { super(e, t), this.on(e, "error", e => this.open(e)) } buildCSSClass() { return "vjs-error-display " + super.buildCSSClass() } content() { var e = this.player().error(); return e ? this.localize(e.message) : "" } } Pn.prototype.options_ = Object.assign({}, Jt.prototype.options_, { pauseOnOpen: !1, fillAlways: !0, temporary: !1, uncloseable: !0 }), f.registerComponent("ErrorDisplay", Pn); const Dn = "vjs-text-track-settings"; var Ri = ["#000", "Black"], Ot = ["#00F", "Blue"], On = ["#0FF", "Cyan"], Mn = ["#0F0", "Green"], t = ["#F0F", "Magenta"], Nn = ["#F00", "Red"], Rn = ["#FFF", "White"], r = ["#FF0", "Yellow"], Un = ["1", "Opaque"], Bn = ["0.5", "Semi-Transparent"], Fn = ["0", "Transparent"]; const jn = { backgroundColor: { selector: ".vjs-bg-color > select", id: "captions-background-color-%s", label: "Color", options: [Ri, Rn, Nn, Mn, Ot, r, t, On] }, backgroundOpacity: { selector: ".vjs-bg-opacity > select", id: "captions-background-opacity-%s", label: "Opacity", options: [Un, Bn, Fn] }, color: { selector: ".vjs-text-color > select", id: "captions-foreground-color-%s", label: "Color", options: [Rn, Ri, Nn, Mn, Ot, r, t, On] }, edgeStyle: { selector: ".vjs-edge-style > select", id: "%s", label: "Text Edge Style", options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]] }, fontFamily: { selector: ".vjs-font-family > select", id: "captions-font-family-%s", label: "Font Family", options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]] }, fontPercent: { selector: ".vjs-font-percent > select", id: "captions-font-size-%s", label: "Font Size", options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]], default: 2, parser: e => "1.00" === e ? null : Number(e) }, textOpacity: { selector: ".vjs-text-opacity > select", id: "captions-foreground-opacity-%s", label: "Opacity", options: [Un, Bn] }, windowColor: { selector: ".vjs-window-color > select", id: "captions-window-color-%s", label: "Color" }, windowOpacity: { selector: ".vjs-window-opacity > select", id: "captions-window-opacity-%s", label: "Opacity", options: [Fn, Bn, Un] } }; function Hn(e, t) { if ((e = t ? t(e) : e) && "none" !== e) return e } jn.windowColor.options = jn.backgroundColor.options; class Vn extends Jt { constructor(e, t) { t.temporary = !1, super(e, t), this.updateDisplay = this.updateDisplay.bind(this), this.fill(), this.hasBeenOpened_ = this.hasBeenFilled_ = !0, this.endDialog = o("p", { className: "vjs-control-text", textContent: this.localize("End of dialog window.") }), this.el().appendChild(this.endDialog), this.setDefaults(), void 0 === t.persistTextTrackSettings && (this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings), this.on(this.$(".vjs-done-button"), "click", () => { this.saveSettings(), this.close() }), this.on(this.$(".vjs-default-button"), "click", () => { this.setDefaults(), this.updateDisplay() }), G(jn, e => { this.on(this.$(e.selector), "change", this.updateDisplay) }), this.options_.persistTextTrackSettings && this.restoreSettings() } dispose() { this.endDialog = null, super.dispose() } createElSelect_(e, t = "", i = "label") { e = jn[e]; const s = e.id.replace("%s", this.id_), n = [t, s].join(" ").trim(); return [`<${i} id="${s}" class="${"label" === i ? "vjs-label" : ""}">`, this.localize(e.label), `</${i}>`, `<select aria-labelledby="${n}">`].concat(e.options.map(e => { var t = s + "-" + e[1].replace(/\W+/g, ""); return [`<option id="${t}" value="${e[0]}" `, `aria-labelledby="${n} ${t}">`, this.localize(e[1]), "</option>"].join("") })).concat("</select>").join("") } createElFgColor_() { var e = "captions-text-legend-" + this.id_; return ['<fieldset class="vjs-fg vjs-track-setting">', `<legend id="${e}">`, this.localize("Text"), "</legend>", '<span class="vjs-text-color">', this.createElSelect_("color", e), "</span>", '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", e), "</span>", "</fieldset>"].join("") } createElBgColor_() { var e = "captions-background-" + this.id_; return ['<fieldset class="vjs-bg vjs-track-setting">', `<legend id="${e}">`, this.localize("Text Background"), "</legend>", '<span class="vjs-bg-color">', this.createElSelect_("backgroundColor", e), "</span>", '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", e), "</span>", "</fieldset>"].join("") } createElWinColor_() { var e = "captions-window-" + this.id_; return ['<fieldset class="vjs-window vjs-track-setting">', `<legend id="${e}">`, this.localize("Caption Area Background"), "</legend>", '<span class="vjs-window-color">', this.createElSelect_("windowColor", e), "</span>", '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", e), "</span>", "</fieldset>"].join("") } createElColors_() { return o("div", { className: "vjs-track-settings-colors", innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("") }) } createElFont_() { return o("div", { className: "vjs-track-settings-font", innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("") }) } createElControls_() { var e = this.localize("restore all settings to the default values"); return o("div", { className: "vjs-track-settings-controls", innerHTML: [`<button type="button" class="vjs-default-button" title="${e}">`, this.localize("Reset"), `<span class="vjs-control-text"> ${e}</span>`, "</button>", `<button type="button" class="vjs-done-button">${this.localize("Done")}</button>`].join("") }) } content() { return [this.createElColors_(), this.createElFont_(), this.createElControls_()] } label() { return this.localize("Caption Settings Dialog") } description() { return this.localize("Beginning of dialog window. Escape will cancel and close the window.") } buildCSSClass() { return super.buildCSSClass() + " vjs-text-track-settings" } getValues() { return X(jn, (e, t, i) => { s = this.$(t.selector), t = t.parser; var s = Hn(s.options[s.options.selectedIndex].value, t); return void 0 !== s && (e[i] = s), e }, {}) } setValues(r) { G(jn, (e, t) => { var i = this.$(e.selector), s = r[t], n = e.parser; if (s) for (let e = 0; e < i.options.length; e++)if (Hn(i.options[e].value, n) === s) { i.selectedIndex = e; break } }) } setDefaults() { G(jn, e => { var t = e.hasOwnProperty("default") ? e.default : 0; this.$(e.selector).selectedIndex = t }) } restoreSettings() { let e; try { e = JSON.parse(window.localStorage.getItem(Dn)) } catch (e) { d.warn(e) } e && this.setValues(e) } saveSettings() { if (this.options_.persistTextTrackSettings) { var e = this.getValues(); try { Object.keys(e).length ? window.localStorage.setItem(Dn, JSON.stringify(e)) : window.localStorage.removeItem(Dn) } catch (e) { d.warn(e) } } } updateDisplay() { var e = this.player_.getChild("textTrackDisplay"); e && e.updateDisplay() } conditionalBlur_() { this.previouslyActiveEl_ = null; var e = this.player_.controlBar, t = e && e.subsCapsButton, e = e && e.captionsButton; t ? t.focus() : e && e.focus() } handleLanguagechange() { this.fill() } } f.registerComponent("TextTrackSettings", Vn); class qn extends f { constructor(e, t) { let i = t.ResizeObserver || window.ResizeObserver; super(e, h({ createEl: !(i = null === t.ResizeObserver ? !1 : i), reportTouchActivity: !1 }, t)), this.ResizeObserver = t.ResizeObserver || window.ResizeObserver, this.loadListener_ = null, this.resizeObserver_ = null, this.debouncedHandler_ = mt(() => { this.resizeHandler() }, 100, !1, this), i ? (this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_), this.resizeObserver_.observe(e.el())) : (this.loadListener_ = () => { if (this.el_ && this.el_.contentWindow) { const t = this.debouncedHandler_; let e = this.unloadListener_ = function () { p(this, "resize", t), p(this, "unload", e), e = null }; lt(this.el_.contentWindow, "unload", e), lt(this.el_.contentWindow, "resize", t) } }, this.one("load", this.loadListener_)) } createEl() { return super.createEl("iframe", { className: "vjs-resize-manager", tabIndex: -1, title: this.localize("No content") }, { "aria-hidden": "true" }) } resizeHandler() { this.player_ && this.player_.trigger && this.player_.trigger("playerresize") } dispose() { this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, super.dispose() } } f.registerComponent("ResizeManager", qn); const zn = { trackingThreshold: 20, liveTolerance: 15 }; class $n extends f { constructor(e, t) { super(e, h(zn, t, { createEl: !1 })), this.trackLiveHandler_ = () => this.trackLive_(), this.handlePlay_ = e => this.handlePlay(e), this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e), this.handleSeeked_ = e => this.handleSeeked(e), this.seekToLiveEdge_ = e => this.seekToLiveEdge(e), this.reset_(), this.on(this.player_, "durationchange", e => this.handleDurationchange(e)), this.on(this.player_, "canplay", () => this.toggleTracking()) } trackLive_() { var t = this.player_.seekable(); if (t && t.length) { var t = Number(window.performance.now().toFixed(4)), i = -1 === this.lastTime_ ? 0 : (t - this.lastTime_) / 1e3, t = (this.lastTime_ = t, this.pastSeekEnd_ = this.pastSeekEnd() + i, this.liveCurrentTime()), i = this.player_.currentTime(); let e = this.player_.paused() || this.seekedBehindLive_ || Math.abs(t - i) > this.options_.liveTolerance; (e = this.timeupdateSeen_ && t !== 1 / 0 ? e : !1) !== this.behindLiveEdge_ && (this.behindLiveEdge_ = e, this.trigger("liveedgechange")) } } handleDurationchange() { this.toggleTracking() } toggleTracking() { this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking()) } startTracking() { this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, 30), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_))) } handleFirstTimeupdate() { this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_) } handleSeeked() { var e = Math.abs(this.liveCurrentTime() - this.player_.currentTime()); this.seekedBehindLive_ = this.nextSeekedFromUser_ && 2 < e, this.nextSeekedFromUser_ = !1, this.trackLive_() } handlePlay() { this.one(this.player_, "timeupdate", this.seekToLiveEdge_) } reset_() { this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_) } nextSeekedFromUser() { this.nextSeekedFromUser_ = !0 } stopTracking() { this.isTracking() && (this.reset_(), this.trigger("liveedgechange")) } seekableEnd() { var e = this.player_.seekable(), t = []; let i = e ? e.length : 0; for (; i--;)t.push(e.end(i)); return t.length ? t.sort()[t.length - 1] : 1 / 0 } seekableStart() { var e = this.player_.seekable(), t = []; let i = e ? e.length : 0; for (; i--;)t.push(e.start(i)); return t.length ? t.sort()[0] : 0 } liveWindow() { var e = this.liveCurrentTime(); return e === 1 / 0 ? 0 : e - this.seekableStart() } isLive() { return this.isTracking() } atLiveEdge() { return !this.behindLiveEdge() } liveCurrentTime() { return this.pastSeekEnd() + this.seekableEnd() } pastSeekEnd() { var e = this.seekableEnd(); return -1 !== this.lastSeekEnd_ && e !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = e, this.pastSeekEnd_ } behindLiveEdge() { return this.behindLiveEdge_ } isTracking() { return "number" == typeof this.trackingInterval_ } seekToLiveEdge() { this.seekedBehindLive_ = !1, this.atLiveEdge() || (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime())) } dispose() { this.stopTracking(), super.dispose() } } f.registerComponent("LiveTracker", $n); class Wn extends f { constructor(e, t) { super(e, t), this.on("statechanged", e => this.updateDom_()), this.updateDom_() } createEl() { return this.els = { title: o("div", { className: "vjs-title-bar-title", id: "vjs-title-bar-title-" + it++ }), description: o("div", { className: "vjs-title-bar-description", id: "vjs-title-bar-description-" + it++ }) }, o("div", { className: "vjs-title-bar" }, {}, Q(this.els)) } updateDom_() { var e = this.player_.tech_; const s = e && e.el_, n = { title: "aria-labelledby", description: "aria-describedby" };["title", "description"].forEach(e => { var t = this.state[e], i = this.els[e], e = n[e]; je(i), t && we(i, t), s && (s.removeAttribute(e), t) && s.setAttribute(e, i.id) }), this.state.title || this.state.description ? this.show() : this.hide() } update(e) { this.setState(e) } dispose() { var e = this.player_.tech_, e = e && e.el_; e && (e.removeAttribute("aria-labelledby"), e.removeAttribute("aria-describedby")), super.dispose(), this.els = null } } f.registerComponent("TitleBar", Wn); function Gn(i) { const s = i.el(); if (!s.resetSourceWatch_) { const t = {}, e = Jn(i), n = t => (...e) => { e = t.apply(s, e); return Kn(i), e };["append", "appendChild", "insertAdjacentHTML"].forEach(e => { s[e] && (t[e] = s[e], s[e] = n(t[e])) }), Object.defineProperty(s, "innerHTML", h(e, { set: n(e.set) })), s.resetSourceWatch_ = () => { s.resetSourceWatch_ = null, Object.keys(t).forEach(e => { s[e] = t[e] }), Object.defineProperty(s, "innerHTML", e) }, i.one("sourceset", s.resetSourceWatch_) } } function Xn(i) { if (i.featuresSourceset) { const s = i.el(); if (!s.resetSourceset_) { e = i; const t = Qn([e.el(), window.HTMLMediaElement.prototype, Zn], "src"); var e; const n = s.setAttribute, r = s.load; Object.defineProperty(s, "src", h(t, { set: e => { e = t.set.call(s, e); return i.triggerSourceset(s.src), e } })), s.setAttribute = (e, t) => { t = n.call(s, e, t); return /src/i.test(e) && i.triggerSourceset(s.src), t }, s.load = () => { var e = r.call(s); return Kn(i) || (i.triggerSourceset(""), Gn(i)), e }, s.currentSrc ? i.triggerSourceset(s.currentSrc) : Kn(i) || Gn(i), s.resetSourceset_ = () => { s.resetSourceset_ = null, s.load = r, s.setAttribute = n, Object.defineProperty(s, "src", t), s.resetSourceWatch_ && s.resetSourceWatch_() } } } } const Kn = t => { var e = t.el(); if (e.hasAttribute("src")) t.triggerSourceset(e.src); else { var i = t.$$("source"), s = []; let e = ""; if (!i.length) return !1; for (let e = 0; e < i.length; e++) { var n = i[e].src; n && -1 === s.indexOf(n) && s.push(n) } if (!s.length) return !1; 1 === s.length && (e = s[0]), t.triggerSourceset(e) } return !0 }, Yn = Object.defineProperty({}, "innerHTML", { get() { return this.cloneNode(!0).innerHTML }, set(e) { for (var t = document.createElement(this.nodeName.toLowerCase()), i = (t.innerHTML = e, document.createDocumentFragment()); t.childNodes.length;)i.appendChild(t.childNodes[0]); return this.innerText = "", window.Element.prototype.appendChild.call(this, i), this.innerHTML } }), Qn = (t, i) => { let s = {}; for (let e = 0; e < t.length && !((s = Object.getOwnPropertyDescriptor(t[e], i)) && s.set && s.get); e++); return s.enumerable = !0, s.configurable = !0, s }, Jn = e => Qn([e.el(), window.HTMLMediaElement.prototype, window.Element.prototype, Yn], "innerHTML"), Zn = Object.defineProperty({}, "src", { get() { return this.hasAttribute("src") ? hi(window.Element.prototype.getAttribute.call(this, "src")) : "" }, set(e) { return window.Element.prototype.setAttribute.call(this, "src", e), e } }); class v extends _ { constructor(e, t) { super(e, t); t = e.source; let i = !1; if (this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && "VIDEO" === this.el_.tagName, t && (this.el_.currentSrc !== t.src || e.tag && 3 === e.tag.initNetworkState_) ? this.setSource(t) : this.handleLateInit_(this.el_), e.enableSourceset && this.setupSourcesetHandling_(), this.isScrubbing_ = !1, this.el_.hasChildNodes()) { var s = this.el_.childNodes; let e = s.length; for (var n = []; e--;) { var r = s[e]; "track" === r.nodeName.toLowerCase() && (this.featuresNativeTextTracks ? (this.remoteTextTrackEls().addTrackElement_(r), this.remoteTextTracks().addTrack(r.track), this.textTracks().addTrack(r.track), i || this.el_.hasAttribute("crossorigin") || !ui(r.src) || (i = !0)) : n.push(r)) } for (let e = 0; e < n.length; e++)this.el_.removeChild(n[e]) } this.proxyNativeTracks_(), this.featuresNativeTextTracks && i && d.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading."), this.restoreMetadataTracksInIOSNativePlayer_(), (ge || me) && !0 === e.nativeControlsForTouch && this.setControls(!0), this.proxyWebkitFullscreen_(), this.triggerReady() } dispose() { this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), v.disposeMediaElement(this.el_), this.options_ = null, super.dispose() } setupSourcesetHandling_() { Xn(this) } restoreMetadataTracksInIOSNativePlayer_() { const i = this.textTracks(); let s; const e = () => { s = []; for (let e = 0; e < i.length; e++) { var t = i[e]; "metadata" === t.kind && s.push({ track: t, storedMode: t.mode }) } }, n = (e(), i.addEventListener("change", e), this.on("dispose", () => i.removeEventListener("change", e)), () => { for (let e = 0; e < s.length; e++) { var t = s[e]; "disabled" === t.track.mode && t.track.mode !== t.storedMode && (t.track.mode = t.storedMode) } i.removeEventListener("change", n) }); this.on("webkitbeginfullscreen", () => { i.removeEventListener("change", e), i.removeEventListener("change", n), i.addEventListener("change", n) }), this.on("webkitendfullscreen", () => { i.removeEventListener("change", e), i.addEventListener("change", e), i.removeEventListener("change", n) }) } overrideNative_(e, t) { if (t === this[`featuresNative${e}Tracks`]) { const i = e.toLowerCase(); this[i + "TracksListeners_"] && Object.keys(this[i + "TracksListeners_"]).forEach(e => { this.el()[i + "Tracks"].removeEventListener(e, this[i + "TracksListeners_"][e]) }), this[`featuresNative${e}Tracks`] = !t, this[i + "TracksListeners_"] = null, this.proxyNativeTracksForType_(i) } } overrideNativeAudioTracks(e) { this.overrideNative_("Audio", e) } overrideNativeVideoTracks(e) { this.overrideNative_("Video", e) } proxyNativeTracksForType_(i) { var e = Mi[i]; const s = this.el()[e.getterName], n = this[e.getterName](); if (this[`featuresNative${e.capitalName}Tracks`] && s && s.addEventListener) { const r = { change: e => { var t = { type: "change", target: n, currentTarget: n, srcElement: n }; n.trigger(t), "text" === i && this[Ni.remoteText.getterName]().trigger(t) }, addtrack(e) { n.addTrack(e.track) }, removetrack(e) { n.removeTrack(e.track) } }, t = function () { var e = []; for (let i = 0; i < n.length; i++) { let t = !1; for (let e = 0; e < s.length; e++)if (s[e] === n[i]) { t = !0; break } t || e.push(n[i]) } for (; e.length;)n.removeTrack(e.shift()) }; this[e.getterName + "Listeners_"] = r, Object.keys(r).forEach(t => { const i = r[t]; s.addEventListener(t, i), this.on("dispose", e => s.removeEventListener(t, i)) }), this.on("loadstart", t), this.on("dispose", e => this.off("loadstart", t)) } } proxyNativeTracks_() { Mi.names.forEach(e => { this.proxyNativeTracksForType_(e) }) } createEl() { let t = this.options_.tag; t && (this.options_.playerElIngest || this.movingMediaElementInDOM) || (t ? (e = t.cloneNode(!0), t.parentNode && t.parentNode.insertBefore(e, t), v.disposeMediaElement(t), t = e) : (t = document.createElement("video"), e = h({}, this.options_.tag && Le(this.options_.tag)), ge && !0 === this.options_.nativeControlsForTouch || delete e.controls, Ae(t, Object.assign(e, { id: this.options_.techId, class: "vjs-tech" }))), t.playerId = this.options_.playerId), "undefined" != typeof this.options_.preload && De(t, "preload", this.options_.preload), void 0 !== this.options_.disablePictureInPicture && (t.disablePictureInPicture = this.options_.disablePictureInPicture); var e, i = ["loop", "muted", "playsinline", "autoplay"]; for (let e = 0; e < i.length; e++) { var s = i[e], n = this.options_[s]; "undefined" != typeof n && (n ? De(t, s, s) : Oe(t, s), t[s] = n) } return t } handleLateInit_(e) { if (0 !== e.networkState && 3 !== e.networkState) if (0 === e.readyState) { let e = !1; const t = function () { e = !0 }, i = (this.on("loadstart", t), function () { e || this.trigger("loadstart") }); this.on("loadedmetadata", i), void this.ready(function () { this.off("loadstart", t), this.off("loadedmetadata", i), e || this.trigger("loadstart") }) } else { const s = ["loadstart"]; s.push("loadedmetadata"), 2 <= e.readyState && s.push("loadeddata"), 3 <= e.readyState && s.push("canplay"), 4 <= e.readyState && s.push("canplaythrough"), this.ready(function () { s.forEach(function (e) { this.trigger(e) }, this) }) } } setScrubbing(e) { this.isScrubbing_ = e } scrubbing() { return this.isScrubbing_ } setCurrentTime(e) { try { this.isScrubbing_ && this.el_.fastSeek && ye ? this.el_.fastSeek(e) : this.el_.currentTime = e } catch (e) { d(e, "Video is not ready. (Video.js)") } } duration() { if (this.el_.duration === 1 / 0 && ie && oe && 0 === this.el_.currentTime) { const e = () => { 0 < this.el_.currentTime && (this.el_.duration === 1 / 0 && this.trigger("durationchange"), this.off("timeupdate", e)) }; return this.on("timeupdate", e), NaN } return this.el_.duration || NaN } width() { return this.el_.offsetWidth } height() { return this.el_.offsetHeight } proxyWebkitFullscreen_() { if ("webkitDisplayingFullscreen" in this.el_) { const e = function () { this.trigger("fullscreenchange", { isFullscreen: !1 }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1) }, t = function () { "webkitPresentationMode" in this.el_ && "picture-in-picture" !== this.el_.webkitPresentationMode && (this.one("webkitendfullscreen", e), this.trigger("fullscreenchange", { isFullscreen: !0, nativeIOSFullscreen: !0 })) }; this.on("webkitbeginfullscreen", t), this.on("dispose", () => { this.off("webkitbeginfullscreen", t), this.off("webkitendfullscreen", e) }) } } supportsFullScreen() { return "function" == typeof this.el_.webkitEnterFullScreen } enterFullScreen() { const e = this.el_; if (e.paused && e.networkState <= e.HAVE_METADATA) Gt(this.el_.play()), this.setTimeout(function () { e.pause(); try { e.webkitEnterFullScreen() } catch (e) { this.trigger("fullscreenerror", e) } }, 0); else try { e.webkitEnterFullScreen() } catch (e) { this.trigger("fullscreenerror", e) } } exitFullScreen() { this.el_.webkitDisplayingFullscreen ? this.el_.webkitExitFullScreen() : this.trigger("fullscreenerror", new Error("The video is not fullscreen")) } requestPictureInPicture() { return this.el_.requestPictureInPicture() } requestVideoFrameCallback(e) { return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(e) : super.requestVideoFrameCallback(e) } cancelVideoFrameCallback(e) { this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(e) : super.cancelVideoFrameCallback(e) } src(e) { if (void 0 === e) return this.el_.src; this.setSrc(e) } reset() { v.resetMediaElement(this.el_) } currentSrc() { return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc } setControls(e) { this.el_.controls = !!e } addTextTrack(e, t, i) { return this.featuresNativeTextTracks ? this.el_.addTextTrack(e, t, i) : super.addTextTrack(e, t, i) } createRemoteTextTrack(e) { var t; return this.featuresNativeTextTracks ? (t = document.createElement("track"), e.kind && (t.kind = e.kind), e.label && (t.label = e.label), (e.language || e.srclang) && (t.srclang = e.language || e.srclang), e.default && (t.default = e.default), e.id && (t.id = e.id), e.src && (t.src = e.src), t) : super.createRemoteTextTrack(e) } addRemoteTextTrack(e, t) { e = super.addRemoteTextTrack(e, t); return this.featuresNativeTextTracks && this.el().appendChild(e), e } removeRemoteTextTrack(t) { if (super.removeRemoteTextTrack(t), this.featuresNativeTextTracks) { var i = this.$$("track"); let e = i.length; for (; e--;)t !== i[e] && t !== i[e].track || this.el().removeChild(i[e]) } } getVideoPlaybackQuality() { var e; return "function" == typeof this.el().getVideoPlaybackQuality ? this.el().getVideoPlaybackQuality() : (e = {}, "undefined" != typeof this.el().webkitDroppedFrameCount && "undefined" != typeof this.el().webkitDecodedFrameCount && (e.droppedVideoFrames = this.el().webkitDroppedFrameCount, e.totalVideoFrames = this.el().webkitDecodedFrameCount), window.performance && (e.creationTime = window.performance.now()), e) } } J(v, "TEST_VID", function () { var e, t; if (ve()) return e = document.createElement("video"), (t = document.createElement("track")).kind = "captions", t.srclang = "en", t.label = "English", e.appendChild(t), e }), v.isSupported = function () { try { v.TEST_VID.volume = .5 } catch (e) { return !1 } return !(!v.TEST_VID || !v.TEST_VID.canPlayType) }, v.canPlayType = function (e) { return v.TEST_VID.canPlayType(e) }, v.canPlaySource = function (e, t) { return v.canPlayType(e.type) }, v.canControlVolume = function () { try { const t = v.TEST_VID.volume; v.TEST_VID.volume = t / 2 + .1; var e = t !== v.TEST_VID.volume; return e && u ? (window.setTimeout(() => { v && v.prototype && (v.prototype.featuresVolumeControl = t !== v.TEST_VID.volume) }), !1) : e } catch (e) { return !1 } }, v.canMuteVolume = function () { try { var e = v.TEST_VID.muted; return v.TEST_VID.muted = !e, v.TEST_VID.muted ? De(v.TEST_VID, "muted", "muted") : Oe(v.TEST_VID, "muted"), e !== v.TEST_VID.muted } catch (e) { return !1 } }, v.canControlPlaybackRate = function () { if (ie && oe && de < 58) return !1; try { var e = v.TEST_VID.playbackRate; return v.TEST_VID.playbackRate = e / 2 + .1, e !== v.TEST_VID.playbackRate } catch (e) { return !1 } }, v.canOverrideAttributes = function () { try { var e = () => { }; Object.defineProperty(document.createElement("video"), "src", { get: e, set: e }), Object.defineProperty(document.createElement("audio"), "src", { get: e, set: e }), Object.defineProperty(document.createElement("video"), "innerHTML", { get: e, set: e }), Object.defineProperty(document.createElement("audio"), "innerHTML", { get: e, set: e }) } catch (e) { return !1 } return !0 }, v.supportsNativeTextTracks = function () { return ye || u && oe }, v.supportsNativeVideoTracks = function () { return !(!v.TEST_VID || !v.TEST_VID.videoTracks) }, v.supportsNativeAudioTracks = function () { return !(!v.TEST_VID || !v.TEST_VID.audioTracks) }, v.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"], [["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function ([e, t]) { J(v.prototype, e, () => v[t](), !0) }), v.prototype.featuresVolumeControl = v.canControlVolume(), v.prototype.movingMediaElementInDOM = !u, v.prototype.featuresFullscreenResize = !0, v.prototype.featuresProgressEvents = !0, v.prototype.featuresTimeupdateEvents = !0, v.prototype.featuresVideoFrameCallback = !(!v.TEST_VID || !v.TEST_VID.requestVideoFrameCallback), v.disposeMediaElement = function (e) { if (e) { for (e.parentNode && e.parentNode.removeChild(e); e.hasChildNodes();)e.removeChild(e.firstChild); if (e.removeAttribute("src"), "function" == typeof e.load) try { e.load() } catch (e) { } } }, v.resetMediaElement = function (t) { if (t) { var i = t.querySelectorAll("source"); let e = i.length; for (; e--;)t.removeChild(i[e]); if (t.removeAttribute("src"), "function" == typeof t.load) try { t.load() } catch (e) { } } }, ["muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline"].forEach(function (e) { v.prototype[e] = function () { return this.el_[e] || this.el_.hasAttribute(e) } }), ["muted", "defaultMuted", "autoplay", "loop", "playsinline"].forEach(function (t) { v.prototype["set" + g(t)] = function (e) { (this.el_[t] = e) ? this.el_.setAttribute(t, t) : this.el_.removeAttribute(t) } }), ["paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "played", "networkState", "readyState", "videoWidth", "videoHeight", "crossOrigin"].forEach(function (e) { v.prototype[e] = function () { return this.el_[e] } }), ["volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "crossOrigin"].forEach(function (t) { v.prototype["set" + g(t)] = function (e) { this.el_[t] = e } }), ["pause", "load", "play"].forEach(function (e) { v.prototype[e] = function () { return this.el_[e]() } }), _.withSourceHandlers(v), v.nativeSourceHandler = {}, v.nativeSourceHandler.canPlayType = function (e) { try { return v.TEST_VID.canPlayType(e) } catch (e) { return "" } }, v.nativeSourceHandler.canHandleSource = function (e, t) { return e.type ? v.nativeSourceHandler.canPlayType(e.type) : e.src ? (e = ci(e.src), v.nativeSourceHandler.canPlayType("video/" + e)) : "" }, v.nativeSourceHandler.handleSource = function (e, t, i) { t.setSrc(e.src) }, v.nativeSourceHandler.dispose = function () { }, v.registerSourceHandler(v.nativeSourceHandler), _.registerTech("Html5", v); const er = ["progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange"], tr = { canplay: "CanPlay", canplaythrough: "CanPlayThrough", playing: "Playing", seeked: "Seeked" }, ir = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"], sr = {}, nr = (ir.forEach(e => { var t = "x" === e.charAt(0) ? "x-" + e.substring(1) : e; sr[e] = "vjs-layout-" + t }), { tiny: 210, xsmall: 320, small: 425, medium: 768, large: 1440, xlarge: 2560, huge: 1 / 0 }); class b extends f {
    constructor(e, t, i) { if (e.id = e.id || t.id || "vjs_video_" + it++, (t = Object.assign(b.getTagSettings(e), t)).initChildren = !1, t.createEl = !1, t.evented = !1, t.reportTouchActivity = !1, t.language || (s = e.closest("[lang]")) && (t.language = s.getAttribute("lang")), super(null, t, i), this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e), this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e), this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e), this.boundApplyInitTime_ = e => this.applyInitTime_(e), this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e), this.boundHandleTechClick_ = e => this.handleTechClick_(e), this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e), this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e), this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e), this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e), this.boundHandleTechTap_ = e => this.handleTechTap_(e), this.isFullscreen_ = !1, this.log = $(this.id_), this.fsApi_ = j, this.isPosterFromTech_ = !1, this.queuedCallbacks_ = [], this.isReady_ = !1, this.hasStarted_ = !1, this.userActive_ = !1, this.debugEnabled_ = !1, this.audioOnlyMode_ = !1, this.audioPosterMode_ = !1, this.audioOnlyCache_ = { playerHeight: null, hiddenChildren: [] }, !this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) throw new Error("No techOrder specified. Did you overwrite tm_videojs.options instead of just changing the properties you want to override?"); if (this.tag = e, this.tagAttributes = e && Le(e), this.language(this.options_.language), t.languages) { const n = {}; Object.getOwnPropertyNames(t.languages).forEach(function (e) { n[e.toLowerCase()] = t.languages[e] }), this.languages_ = n } else this.languages_ = b.prototype.options_.languages; this.resetCache_(), this.poster_ = t.poster || "", this.controls_ = !!t.controls, e.controls = !1, e.removeAttribute("controls"), this.changingSrc_ = !1, this.playCallbacks_ = [], this.playTerminatedQueue_ = [], e.hasAttribute("autoplay") ? this.autoplay(!0) : this.autoplay(this.options_.autoplay), t.plugins && Object.keys(t.plugins).forEach(e => { if ("function" != typeof this[e]) throw new Error(`plugin "${e}" does not exist`) }), this.scrubbing_ = !1, this.el_ = this.createEl(), It(this, { eventBusKey: "el_" }), this.fsApi_.requestFullscreen && (lt(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_)), this.fluid_ && this.on(["playerreset", "resize"], this.boundUpdateStyleEl_); var s = h(this.options_), i = (t.plugins && Object.keys(t.plugins).forEach(e => { this[e](t.plugins[e]) }), t.debug && this.debug(!0), this.options_.playerOptions = s, this.middleware_ = [], this.playbackRates(t.playbackRates), t.experimentalSvgIcons && ((i = (new window.DOMParser).parseFromString('<svg xmlns="http://www.w3.org/2000/svg">\n  <defs>\n    <symbol viewBox="0 0 16 16" id="vjs-icon-play">\n      <path d="M2 1v14l12-7z"></path>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-pause">\n       <path d="M10 4H5v16h5V4zm9 0h-5v16h5V4z"/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-audio">\n      <g><rect fill=\'none\' height=\'24\' width=\'24\'/></g><g><path d=\'M12,3c-4.97,0-9,4.03-9,9v7c0,1.1,0.9,2,2,2h4v-8H5v-1c0-3.87,3.13-7,7-7s7,3.13,7,7v1h-4v8h4c1.1,0,2-0.9,2-2v-7 C21,7.03,16.97,3,12,3z\'/></g>\n    </symbol>\n    <symbol viewBox="0 0 576 512" id="vjs-icon-captions">\n      <path d=\'M0 96C0 60.7 28.7 32 64 32H512c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96zM200 208c14.2 0 27 6.1 35.8 16c8.8 9.9 24 10.7 33.9 1.9s10.7-24 1.9-33.9c-17.5-19.6-43.1-32-71.5-32c-53 0-96 43-96 96s43 96 96 96c28.4 0 54-12.4 71.5-32c8.8-9.9 8-25-1.9-33.9s-25-8-33.9 1.9c-8.8 9.9-21.6 16-35.8 16c-26.5 0-48-21.5-48-48s21.5-48 48-48zm144 48c0-26.5 21.5-48 48-48c14.2 0 27 6.1 35.8 16c8.8 9.9 24 10.7 33.9 1.9s10.7-24 1.9-33.9c-17.5-19.6-43.1-32-71.5-32c-53 0-96 43-96 96s43 96 96 96c28.4 0 54-12.4 71.5-32c8.8-9.9 8-25-1.9-33.9s-25-8-33.9 1.9c-8.8 9.9-21.6 16-35.8 16c-26.5 0-48-21.5-48-48z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-subtitles">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM4 12h4v2H4v-2zm10 6H4v-2h10v2zm6 0h-4v-2h4v2zm0-4H10v-2h10v2z\'/>\n    </symbol>\n    <symbol viewBox="0 0 448 512" id="vjs-icon-fullscreen-enter">\n      <path d=\'M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-fullscreen-exit">\n      <path d="M16,9h5a1,1,0,0,0,0-2H17V3a1,1,0,0,0-2,0V8A1,1,0,0,0,16,9ZM8,15H3a1,1,0,0,0,0,2H7v4a1,1,0,0,0,2,0V16A1,1,0,0,0,8,15ZM8,2A1,1,0,0,0,7,3V7H3A1,1,0,0,0,3,9H8A1,1,0,0,0,9,8V3A1,1,0,0,0,8,2ZM21,15H16a1,1,0,0,0-1,1v5a1,1,0,0,0,2,0V17h4a1,1,0,0,0,0-2Z"/>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-play-circle">\n      <path d=\'M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c7.6-4.2 16.8-4.1 24.3 .5l144 88c7.1 4.4 11.5 12.1 11.5 20.5s-4.4 16.1-11.5 20.5l-144 88c-7.4 4.5-16.7 4.7-24.3 .5s-12.3-12.2-12.3-20.9V168c0-8.7 4.7-16.7 12.3-20.9z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-volume-mute">\n      <path d=\'M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-volume-low">\n      <path d="M0 0h24v24H0z" fill="none"/><path d="M7 9v6h4l5 5V4l-5 5H7z"/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-volume-medium">\n      <path d="M0 0h24v24H0z" fill="none"/><path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-volume-high">\n      <path d="M0 0h24v24H0z" fill="none"/><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-spinner">\n      <path d=\'M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">\n      <path d=\'M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-chapters">\n      <path d=\'M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-downloading">\n      <path d=\'M18.32,4.26C16.84,3.05,15.01,2.25,13,2.05v2.02c1.46,0.18,2.79,0.76,3.9,1.62L18.32,4.26z M19.93,11h2.02 c-0.2-2.01-1-3.84-2.21-5.32L18.31,7.1C19.17,8.21,19.75,9.54,19.93,11z M18.31,16.9l1.43,1.43c1.21-1.48,2.01-3.32,2.21-5.32 h-2.02C19.75,14.46,19.17,15.79,18.31,16.9z M13,19.93v2.02c2.01-0.2,3.84-1,5.32-2.21l-1.43-1.43 C15.79,19.17,14.46,19.75,13,19.93z M15.59,10.59L13,13.17V7h-2v6.17l-2.59-2.59L7,12l5,5l5-5L15.59,10.59z M11,19.93v2.02 c-5.05-0.5-9-4.76-9-9.95s3.95-9.45,9-9.95v2.02C7.05,4.56,4,7.92,4,12S7.05,19.44,11,19.93z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-file-download">\n      <path d=\'M18,15v3H6v-3H4v3c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2v-3H18z M17,11l-1.41-1.41L13,12.17V4h-2v8.17L8.41,9.59L7,11l5,5 L17,11z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-file-download-done">\n      <polygon points=\'20.13,5.41 18.72,4 9.53,13.19 5.28,8.95 3.87,10.36 9.53,16.02\'/><rect height=\'2\' width=\'14\' x=\'5\' y=\'18\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-file-download-off">\n      <path d=\'M18,15.17V15h2v2.17L18,15.17z M15.41,12.59L17,11l-1.41-1.41L14,11.17L15.41,12.59z M13,10.17V4h-2v4.17L13,10.17z M21.19,21.19l-1.78-1.78L2.81,2.81L1.39,4.22l6.19,6.19L7,11l5,5l0.59-0.59L15.17,18H6v-3H4v3c0,1.1,0.9,2,2,2h11.17l2.61,2.61 L21.19,21.19z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-share">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-cog">\n      <path d=\'M0,0h24v24H0V0z\' fill=\'none\'/><path d=\'M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z\'/>\n    </symbol>\n    <symbol viewBox="0 0 448 512" id="vjs-icon-square">\n      <path d=\'M384 80c8.8 0 16 7.2 16 16V416c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V96c0-8.8 7.2-16 16-16H384zM64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64z\'/>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-circle">\n      <path d=\'M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-circle-outline">\n      <path d=\'M12,2C6.47,2,2,6.47,2,12c0,5.53,4.47,10,10,10s10-4.47,10-10C22,6.47,17.53,2,12,2z M12,20c-4.42,0-8-3.58-8-8 c0-4.42,3.58-8,8-8s8,3.58,8,8C20,16.42,16.42,20,12,20z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-circle-inner-circle">\n      <path d=\'M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3-8c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-cancel">\n      <path d=\'M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-repeat">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-replay">\n      <path d=\'M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z\'/>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">\n      <path d=\'m17.68852 98-8.69633 8.69633 8.69633 8.69634 2.48665-2.48434-4.31928-4.31928h1.3011c4.93015 0 9.07149 1.72189 12.42399 5.16511 3.35251 3.44322 5.02876 7.63753 5.02876 12.58345h3.54972c0-2.95809-.55264-5.7293-1.657-8.3127-1.10435-2.5834-2.62238-4.84095-4.555-6.77357-1.93262-1.93262-4.19017-3.45065-6.77357-4.55501-2.5834-1.10435-5.35462-1.65699-8.31271-1.65699H15.5l4.61508-4.61509zm-8.07929 21.65879v13.86144h11.35631v5.00796H9.60923V143h12.699c.83466 0 1.55075-.29818 2.14693-.89436.59619-.59619.89436-1.30996.89436-2.14462v-7.78117c0-.83466-.29817-1.55075-.89436-2.14693-.59618-.59618-1.31227-.89436-2.14693-.89436h-8.22719v-5.09578h11.26848v-4.38399z\'/>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">\n      <path d=\'M42.314792 125.62978c0-4.99676-1.693476-9.23445-5.080438-12.71305-3.386962-3.47861-7.570851-5.21791-12.551676-5.21791h-1.314946l4.363203 4.3632-2.510335 2.51034-8.786174-8.78619L25.2206 97l2.450567 2.45057-4.662053 4.66205h1.374714c2.988489 0 5.787713.55785 8.397671 1.67355 2.609949 1.11571 4.891163 2.64981 6.843654 4.60229 1.952481 1.95248 3.486576 4.2337 4.602275 6.84365 1.115709 2.60995 1.673563 5.40917 1.673563 8.39767zM8.1829433 142v-19.65677H3.17603v-4.5433h9.642939V142Zm13.6299297 0c-1.155923 0-2.126398-.39251-2.911424-1.17755-.778861-.77885-1.168286-1.74624-1.168286-2.90215v-16.04066c0-1.15593.392524-2.1264 1.17755-2.91144.77886-.77885 1.746237-1.16827 2.90216-1.16827h7.695814c1.155914 0 2.126388.39251 2.911425 1.17755.77885.77886 1.168275 1.74623 1.168275 2.90216v16.04066c0 1.15591-.392513 2.12639-1.177549 2.91142-.778851.77885-1.746237 1.16828-2.902151 1.16828Zm.556316-4.63603h6.583172v-15.02074h-6.583172z\'/>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">\n      <path d=\'m26.046875 97-8.732422 8.73242 8.732422 8.73242 2.496094-2.49414-4.335938-4.33789h1.306641c4.950749 0 9.108097 1.72991 12.474609 5.1875 3.366504 3.4576 5.050781 7.66818 5.050781 12.63477h3.564454c0-2.97045-.555098-5.75152-1.664063-8.3457-1.108965-2.59419-2.633522-4.86205-4.574219-6.80274-1.940688-1.94069-4.208545-3.46525-6.802734-4.57422-2.59419-1.10897-5.375262-1.66406-8.345703-1.66406h-1.367188l4.634766-4.63477zM2.5546875 117.53125v4.6875H12.851562v5.25H5.8730469v4.6875h6.9785151v5.15625H2.5546875V142H13.361328c1.06088 0 1.950319-.39495 2.667969-1.18555.71765-.79059 1.076172-1.7727 1.076172-2.9414v-16.2168c0-1.1687-.358522-2.14886-1.076172-2.93945-.71765-.79059-1.607089-1.18555-2.667969-1.18555zm22.4824215.14063c-1.148936 0-2.110612.38991-2.884765 1.16406-.780292.78029-1.171875 1.74365-1.171875 2.89258v15.94336c0 1.14892.387966 2.1106 1.162109 2.88476.780302.78029 1.745595 1.17188 2.894531 1.17188h7.648438c1.148936 0 2.110613-.38795 2.884765-1.16211.780294-.78029 1.169922-1.74561 1.169922-2.89453v-15.94336c0-1.14893-.386013-2.11061-1.160156-2.88477-.780293-.78029-1.745595-1.17187-2.894531-1.17187zm.552735 4.51757h6.544922v14.92969h-6.544922z\'/>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">\n      <path d=\'m29.50843 97-2.43193 2.42962 4.6253 4.6253h-1.3642c-2.96464 0-5.74198.55386-8.3311 1.66066-2.58912 1.1068-4.85167 2.62819-6.78857 4.56508-1.93689 1.9369-3.45828 4.19945-4.56508 6.78857-1.1068 2.58911-1.66066 5.36646-1.66066 8.3311h3.55757c0-4.95687 1.67996-9.16047 5.03989-12.6113 3.35992-3.45084 7.51042-5.17654 12.45149-5.17654h1.30398l-4.32653 4.32883 2.48984 2.48984 8.71558-8.71558zm-9.78332 21.60945v13.8898h11.38144v5.01905H19.72511V142h12.72711c.83651 0 1.55186-.29884 2.14937-.89634.5975-.59751.89634-1.31286.89634-2.14936v-7.7984c0-.83651-.29884-1.55418-.89634-2.15168-.59751-.5975-1.31286-.89634-2.14937-.89634h-8.2454v-5.10706h11.29111v-4.39137z\'/>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">\n      <path d=\'m23.118923 97-2.385761 2.38349 4.537491 4.53749h-1.338298c-2.908354 0-5.632974.54335-8.172936 1.62913-2.539963 1.08579-4.759558 2.57829-6.659682 4.47842-1.900125 1.90012-3.39263 4.11972-4.478415 6.65968-1.085785 2.53996-1.629134 5.26458-1.629134 8.17294h3.490028c0-4.86277 1.648071-8.98656 4.944206-12.37188 3.296134-3.38532 7.367841-5.07826 12.215097-5.07826h1.279222l-4.244383 4.24665 2.442565 2.44257 8.550114-8.55012zm-9.520322 21.44913v4.42161h4.871497V142h4.512496v-23.55087zm18.136328 0c-1.124919 0-2.06632.37811-2.824287 1.13608-.763982.76398-1.147437 1.70845-1.147437 2.83337v15.61197c0 1.12492.380382 2.06631 1.138349 2.82428.763983.76398 1.708456 1.14517 2.833375 1.14517h7.489021c1.12492 0 2.06632-.37811 2.82428-1.13608.76399-.76398 1.14517-1.70845 1.14517-2.83337v-15.61197c0-1.12492-.37811-2.06632-1.13608-2.82429-.76398-.76398-1.70845-1.14516-2.83337-1.14516zm.540773 4.42161h6.407468v14.61676h-6.407468z\'/>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">\n      <path d=\'m25.548631 97-2.436697 2.43438 4.634367 4.63436H26.37943c-2.970448 0-5.753239.55495-8.347429 1.66392-2.594191 1.10897-4.861176 2.63334-6.801867 4.57403-1.940693 1.94069-3.465063 4.20767-4.57403 6.80187-1.108967 2.59419-1.663916 5.37698-1.663916 8.34742h3.56454c0-4.96658 1.683258-9.17841 5.049766-12.63601 3.366507-3.4576 7.525145-5.18669 12.475891-5.18669h1.306534l-4.335002 4.33733 2.494714 2.49471 8.73266-8.73266zm-11.552266 20.53092v4.68774h10.296787v5.24934h-6.978237v4.68774h6.978237v5.15652H13.996365V142h10.807333c1.060879 0 1.94879-.39527 2.666443-1.18586.717653-.79059 1.076789-1.77158 1.076789-2.94028v-16.2168c0-1.1687-.359136-2.14969-1.076789-2.94028-.717653-.79059-1.605564-1.18586-2.666443-1.18586zm21.173741.16708c-1.148937 0-2.110436.38851-2.884586 1.16266-.780294.78029-1.171935 1.74493-1.171935 2.89387v15.94296c0 1.14894.388502 2.11043 1.162652 2.88458.780294.78029 1.744932 1.16962 2.893869 1.16962h7.648904c1.14894 0 2.11044-.38619 2.88459-1.16033.78029-.7803 1.16961-1.74493 1.16961-2.89387v-15.94296c0-1.14894-.38618-2.11044-1.16033-2.88459-.78029-.78029-1.74493-1.17194-2.89387-1.17194zm.552317 4.51602h6.541957v14.93115h-6.541957z\'/>\n    </symbol>\n    <symbol viewBox="0 0 512 512" xmlns:sketch=\'http://www.bohemiancoding.com/sketch/ns\' id="vjs-icon-audio-description">\n      <g id=\'Page-1\' stroke=\'none\' stroke-width=\'1\' sketch:type=\'MSPage\'><g id=\'AD\' sketch:type=\'MSArtboardGroup\'><g id=\'g24\' sketch:type=\'MSLayerGroup\' transform=\'translate(226.904216, 162.124958)\'><path d=\'M0.385466989,219.226204 L0.385466989,0.867948105 C50.7660025,-0.149278544 89.4938709,-2.16027378 118.016886,17.9940357 C145.39121,37.3362698 166.750707,74.9591545 162.906445,123.318579 C158.839382,174.474203 121.571663,217.457893 73.1311827,221.793795 C49.0460488,223.949377 1.1583283,221.793795 1.1583283,221.793795 C1.1583283,221.793795 0.318395733,220.441758 0.385466989,219.226204 M49.1404882,164.421786 C80.5703101,165.681697 102.34881,147.788744 105.636072,119.036417 C110.038491,80.5268177 84.4473371,55.4838492 47.5943801,58.2399576 L47.5943801,161.852062 C47.5585317,163.318404 48.1702678,164.071194 49.1404882,164.421786\' id=\'path26\' sketch:type=\'MSShapeGroup\'></path></g><g id=\'g28\' sketch:type=\'MSLayerGroup\' transform=\'translate(383.779991, 168.926023)\'><path d=\'M0,212.402042 C13.3360014,216.111401 17.386874,201.342635 23.2151349,190.99422 C35.936702,168.422877 45.5086182,139.400143 45.6604922,106.220214 C45.8813648,58.6259492 27.3172746,23.7033002 10.059532,0.0383859113 L1.54919183,0.0383859113 C0.96289654,3.91152436 3.77564916,7.35260805 5.41542574,10.3142944 C18.5814362,34.0755999 30.7818519,66.8674044 30.9556975,104.507776 C31.1545985,147.683822 16.7932549,183.786198 0,212.402042\' id=\'path30\' sketch:type=\'MSShapeGroup\'></path></g><g id=\'g32\' sketch:type=\'MSLayerGroup\' transform=\'translate(425.153705, 168.926023)\'><path d=\'M0,212.402042 C13.3360014,216.111401 17.3841758,201.340502 23.2151349,190.99422 C35.936702,168.422877 45.5066909,139.400143 45.6604922,106.220214 C45.8813648,58.6259492 27.3172746,23.7033002 10.059532,0.0383859113 L1.54919183,0.0383859113 C0.96289654,3.91152436 3.77487823,7.35346107 5.41542574,10.3142944 C18.5814362,34.0755999 30.7822374,66.8674044 30.9556975,104.507776 C31.1545985,147.683822 16.7932549,183.786198 0,212.402042\' id=\'path34\' sketch:type=\'MSShapeGroup\'></path></g><g id=\'g36\' sketch:type=\'MSLayerGroup\' transform=\'translate(466.260868, 168.926023)\'><path d=\'M0,212.402042 C13.3360014,216.111401 17.3841758,201.340502 23.2151349,190.99422 C35.936702,168.422877 45.5066909,139.400143 45.6604922,106.220214 C45.8813648,58.6259492 27.3172746,23.7033002 10.059532,0.0383859113 L1.54919183,0.0383859113 C0.96289654,3.91152436 3.77487823,7.35303456 5.41542574,10.3142944 C18.5814362,34.0755999 30.7818519,66.8674044 30.9556975,104.507776 C31.1545985,147.683822 16.7932549,183.786198 0,212.402042\' id=\'path38\' sketch:type=\'MSShapeGroup\'></path></g><path d=\'M4.4765625,383.005158 L72.5800993,383.005158 L91.1530552,354.521486 L155.321745,354.386058 C155.321745,354.386058 155.386889,373.799083 155.386889,383.005158 L204.142681,383.005158 L204.142681,160.308263 L145.326586,160.308263 C139.673713,169.845383 4.4765625,383.005158 4.4765625,383.005158 L4.4765625,383.005158 Z M157.144233,237.722611 L157.144233,308.881058 L116.6914,308.610203 L157.144233,237.722611 L157.144233,237.722611 Z\' id=\'path22\' sketch:type=\'MSShapeGroup\'></path></g></g>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-next-item">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-previous-item">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M6 6h2v12H6zm3.5 6l8.5 6V6z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-shuffle">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-cast">\n      <path d=\'M0 0h24v24H0z\' fill=\'none\'/><path d=\'M0 0h24v24H0z\' fill=\'none\' opacity=\'.1\'/><path d=\'M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z\'/>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-picture-in-picture-enter">\n      <path d=\'M0 0h24v24H0V0z\' fill=\'none\'/><path d=\'M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z\'/>\n    </symbol>\n    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">\n      <path d=\'M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z\'/><path fill=\'none\' d=\'M-1-3h24v24H-1z\'/>\n    </symbol>\n    <symbol viewBox="0 0 320 512" id="vjs-icon-facebook">\n      <path d=\'M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z\'/>\n    </symbol>\n    <symbol viewBox="0 0 448 512" id="vjs-icon-linkedin">\n      <path d=\'M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z\'/>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-twitter">\n      <path d=\'M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z\'/>\n    </symbol>\n    <symbol viewBox="0 0 320 512" id="vjs-icon-tumblr">\n      <path d=\'M309.8 480.3c-13.6 14.5-50 31.7-97.4 31.7-120.8 0-147-88.8-147-140.6v-144H17.9c-5.5 0-10-4.5-10-10v-68c0-7.2 4.5-13.6 11.3-16 62-21.8 81.5-76 84.3-117.1.8-11 6.5-16.3 16.1-16.3h70.9c5.5 0 10 4.5 10 10v115.2h83c5.5 0 10 4.4 10 9.9v81.7c0 5.5-4.5 10-10 10h-83.4V360c0 34.2 23.7 53.6 68 35.8 4.8-1.9 9-3.2 12.7-2.2 3.5.9 5.8 3.4 7.4 7.9l22 64.3c1.8 5 3.3 10.6-.4 14.5z\'/>\n    </symbol>\n    <symbol viewBox="0 0 496 512" id="vjs-icon-pinterest">\n      <path d=\'M496 256c0 137-111 248-248 248-25.6 0-50.2-3.9-73.4-11.1 10.1-16.5 25.2-43.5 30.8-65 3-11.6 15.4-59 15.4-59 8.1 15.4 31.7 28.5 56.8 28.5 74.8 0 128.7-68.8 128.7-154.3 0-81.9-66.9-143.2-152.9-143.2-107 0-163.9 71.8-163.9 150.1 0 36.4 19.4 81.7 50.3 96.1 4.7 2.2 7.2 1.2 8.3-3.3.8-3.4 5-20.3 6.9-28.1.6-2.5.3-4.7-1.7-7.1-10.1-12.5-18.3-35.3-18.3-56.6 0-54.7 41.4-107.6 112-107.6 60.9 0 103.6 41.5 103.6 100.9 0 67.1-33.9 113.6-78 113.6-24.3 0-42.6-20.1-36.7-44.8 7-29.5 20.5-61.3 20.5-82.6 0-19-10.2-34.9-31.4-34.9-24.9 0-44.9 25.7-44.9 60.2 0 22 7.4 36.8 7.4 36.8s-24.5 103.8-29 123.2c-5 21.4-3 51.6-.9 71.2C65.4 450.9 0 361.1 0 256 0 119 111 8 248 8s248 111 248 248z\'/>\n    </symbol>\n  </defs>\n</svg>', "image/svg+xml")).querySelector("parsererror") ? (d.warn("Failed to load SVG Icons. Falling back to Font Icons."), this.options_.experimentalSvgIcons = null) : ((s = i.documentElement).style.display = "none", this.el_.appendChild(s), this.addClass("vjs-svg-icons-enabled"))), this.initChildren(), this.isAudio("audio" === e.nodeName.toLowerCase()), this.controls() ? this.addClass("vjs-controls-enabled") : this.addClass("vjs-controls-disabled"), this.el_.setAttribute("role", "region"), this.isAudio() ? this.el_.setAttribute("aria-label", this.localize("Audio Player")) : this.el_.setAttribute("aria-label", this.localize("Video Player")), this.isAudio() && this.addClass("vjs-audio"), ge && this.addClass("vjs-touch-enabled"), u || this.addClass("vjs-workinghover"), b.players[this.id_] = this, R.split(".")[0]); this.addClass("vjs-v" + i), this.userActive(!0), this.reportUserActivity(), this.one("play", e => this.listenForUserActivity_(e)), this.on("keydown", e => this.handleKeyDown(e)), this.on("languagechange", e => this.handleLanguagechange(e)), this.breakpoints(this.options_.breakpoints), this.responsive(this.options_.responsive), this.on("ready", () => { this.audioPosterMode(this.options_.audioPosterMode), this.audioOnlyMode(this.options_.audioOnlyMode) }) } dispose() { var e; this.trigger("dispose"), this.off("dispose"), p(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), p(document, "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), b.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), e = this, cs[e.id()] = null, a.names.forEach(e => { e = this[a[e].getterName](); e && e.off && e.off() }), super.dispose({ restoreEl: this.options_.restoreEl }) } createEl() { let t = this.tag, i, e = this.playerElIngest_ = t.parentNode && t.parentNode.hasAttribute && t.parentNode.hasAttribute("data-vjs-player"); const s = "video-js" === this.tag.tagName.toLowerCase(), n = (e ? i = this.el_ = t.parentNode : s || (i = this.el_ = super.createEl("div")), Le(t)); if (s) { for (i = this.el_ = t, t = this.tag = document.createElement("video"); i.children.length;)t.appendChild(i.firstChild); Ce(i, "video-js") || ke(i, "video-js"), i.appendChild(t), e = this.playerElIngest_ = i, Object.keys(i).forEach(e => { try { t[e] = i[e] } catch (e) { } }) } t.setAttribute("tabindex", "-1"), n.tabindex = "-1", oe && ce && (t.setAttribute("role", "application"), n.role = "application"), t.removeAttribute("width"), t.removeAttribute("height"), "width" in n && delete n.width, "height" in n && delete n.height, Object.getOwnPropertyNames(n).forEach(function (e) { s && "class" === e || i.setAttribute(e, n[e]), s && t.setAttribute(e, n[e]) }), t.playerId = t.id, t.id += "_html5_api", t.className = "vjs-tech", (t.player = i.player = this).addClass("vjs-paused"), !0 !== window.TM_VIDEOJS_NO_DYNAMIC_STYLE && (this.styleEl_ = et("vjs-styles-dimensions"), r = $e(".vjs-styles-defaults"), (a = $e("head")).insertBefore(this.styleEl_, r ? r.nextSibling : a.firstChild)), this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin); var r, a, o = t.getElementsByTagName("a"); for (let e = 0; e < o.length; e++) { var l = o.item(e); ke(l, "vjs-hidden"), l.setAttribute("hidden", "hidden") } return t.initNetworkState_ = t.networkState, t.parentNode && !e && t.parentNode.insertBefore(i, t), Ee(t, i), this.children_.unshift(t), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = i } crossOrigin(e) { if ("undefined" == typeof e) return this.techGet_("crossOrigin"); null !== e && "anonymous" !== e && "use-credentials" !== e ? d.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`) : (this.techCall_("setCrossOrigin", e), this.posterImage && this.posterImage.crossOrigin(e)) } width(e) { return this.dimension("width", e) } height(e) { return this.dimension("height", e) } dimension(e, t) { var i, s = e + "_"; if (void 0 === t) return this[s] || 0; "" === t || "auto" === t ? (this[s] = void 0, this.updateStyleEl_()) : (i = parseFloat(t), isNaN(i) ? d.error(`Improper value "${t}" supplied for for ` + e) : (this[s] = i, this.updateStyleEl_())) } fluid(e) { if (void 0 === e) return !!this.fluid_; var t; this.fluid_ = !!e, vt(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), e ? (this.addClass("vjs-fluid"), this.fill(!1), e = this, t = () => { this.on(["playerreset", "resize"], this.boundUpdateStyleEl_) }, vt(e) ? t() : (e.eventedCallbacks || (e.eventedCallbacks = []), e.eventedCallbacks.push(t))) : this.removeClass("vjs-fluid"), this.updateStyleEl_() } fill(e) { if (void 0 === e) return !!this.fill_; this.fill_ = !!e, e ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill") } aspectRatio(e) { if (void 0 === e) return this.aspectRatio_; if (!/^\d+\:\d+$/.test(e)) throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9."); this.aspectRatio_ = e, this.fluid(!0), this.updateStyleEl_() } updateStyleEl_() {
      if (!0 === window.TM_VIDEOJS_NO_DYNAMIC_STYLE) { const e = "number" == typeof this.width_ ? this.width_ : this.options_.width, t = "number" == typeof this.height_ ? this.height_ : this.options_.height; var n = this.tech_ && this.tech_.el(); void (n && (0 <= e && (n.width = e), 0 <= t) && (n.height = t)) } else {
        let e, t, i, s; n = (i = void 0 !== this.aspectRatio_ && "auto" !== this.aspectRatio_ ? this.aspectRatio_ : 0 < this.videoWidth() ? this.videoWidth() + ":" + this.videoHeight() : "16:9").split(":"), n = n[1] / n[0]; e = void 0 !== this.width_ ? this.width_ : void 0 !== this.height_ ? this.height_ / n : this.videoWidth() || 300, t = void 0 !== this.height_ ? this.height_ : e * n, s = /^[^a-zA-Z]/.test(this.id()) ? "dimensions-" + this.id() : this.id() + "-dimensions", this.addClass(s), tt(this.styleEl_, `
      .${s} {
        width: ${e}px;
        height: ${t}px;
      }

      .${s}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${100 * n}%;
      }
    `)
      }
    } loadTech_(e, t) { this.tech_ && this.unloadTech_(); var i = g(e), s = e.charAt(0).toLowerCase() + e.slice(1); "Html5" !== i && this.tag && (_.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = i, this.isReady_ = !1; let n = this.autoplay(); const r = { source: t, autoplay: n = "string" == typeof this.autoplay() || !0 === this.autoplay() && this.options_.normalizeAutoplay ? !1 : n, nativeControlsForTouch: this.options_.nativeControlsForTouch, playerId: this.id(), techId: this.id() + `_${s}_api`, playsinline: this.options_.playsinline, preload: this.options_.preload, loop: this.options_.loop, disablePictureInPicture: this.options_.disablePictureInPicture, muted: this.options_.muted, poster: this.poster(), language: this.language(), playerElIngest: this.playerElIngest_ || !1, "vtt.js": this.options_["vtt.js"], canOverridePoster: !!this.options_.techCanOverridePoster, enableSourceset: this.options_.enableSourceset }; a.names.forEach(e => { e = a[e]; r[e.getterName] = this[e.privateName] }), Object.assign(r, this.options_[i]), Object.assign(r, this.options_[s]), Object.assign(r, this.options_[e.toLowerCase()]), this.tag && (r.tag = this.tag), t && t.src === this.cache_.src && 0 < this.cache_.currentTime && (r.startTime = this.cache_.currentTime); s = _.getTech(e); if (!s) throw new Error(`No Tech named '${i}' exists! '${i}' should be registered using tm_videojs.registerTech()'`); this.tech_ = new s(r), this.tech_.ready(m(this, this.handleTechReady_), !0), Yt(this.textTracksJson_ || [], this.tech_), er.forEach(t => { this.on(this.tech_, t, e => this[`handleTech${g(t)}_`](e)) }), Object.keys(tr).forEach(t => { this.on(this.tech_, t, e => { 0 === this.tech_.playbackRate() && this.tech_.seeking() ? this.queuedCallbacks_.push({ callback: this[`handleTech${tr[t]}_`].bind(this), event: e }) : this[`handleTech${tr[t]}_`](e) }) }), this.on(this.tech_, "loadstart", e => this.handleTechLoadStart_(e)), this.on(this.tech_, "sourceset", e => this.handleTechSourceset_(e)), this.on(this.tech_, "waiting", e => this.handleTechWaiting_(e)), this.on(this.tech_, "ended", e => this.handleTechEnded_(e)), this.on(this.tech_, "seeking", e => this.handleTechSeeking_(e)), this.on(this.tech_, "play", e => this.handleTechPlay_(e)), this.on(this.tech_, "pause", e => this.handleTechPause_(e)), this.on(this.tech_, "durationchange", e => this.handleTechDurationChange_(e)), this.on(this.tech_, "fullscreenchange", (e, t) => this.handleTechFullscreenChange_(e, t)), this.on(this.tech_, "fullscreenerror", (e, t) => this.handleTechFullscreenError_(e, t)), this.on(this.tech_, "enterpictureinpicture", e => this.handleTechEnterPictureInPicture_(e)), this.on(this.tech_, "leavepictureinpicture", e => this.handleTechLeavePictureInPicture_(e)), this.on(this.tech_, "error", e => this.handleTechError_(e)), this.on(this.tech_, "posterchange", e => this.handleTechPosterChange_(e)), this.on(this.tech_, "textdata", e => this.handleTechTextData_(e)), this.on(this.tech_, "ratechange", e => this.handleTechRateChange_(e)), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode === this.el() || "Html5" === i && this.tag || Ee(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null) } unloadTech_() { a.names.forEach(e => { e = a[e]; this[e.privateName] = this[e.getterName]() }), this.textTracksJson_ = Kt(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1 } tech(e) { return void 0 === e && d.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/tm_videojs/video.js/issues/2617 for more info.\n"), this.tech_ } addTechControlsListeners_() { this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_) } removeTechControlsListeners_() { this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_) } handleTechReady_() { this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_() } handleTechLoadStart_() { this.removeClass("vjs-ended", "vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() && this.hasStarted(!1), this.trigger("loadstart"), this.manualAutoplay_(!0 === this.autoplay() && this.options_.normalizeAutoplay ? "play" : this.autoplay()) } manualAutoplay_(t) { if (this.tech_ && "string" == typeof t) { var i = () => { const e = this.muted(), t = (this.muted(!0), () => { this.muted(e) }); this.playTerminatedQueue_.push(t); var i = this.play(); if (Wt(i)) return i.catch(e => { throw t(), new Error("Rejection at manualAutoplay. Restoring muted value. " + (e || "")) }) }; let e; if ("any" !== t || this.muted() ? e = "muted" !== t || this.muted() ? this.play() : i() : Wt(e = this.play()) && (e = e.catch(i)), Wt(e)) return e.then(() => { this.trigger({ type: "autoplay-success", autoplay: t }) }).catch(() => { this.trigger({ type: "autoplay-failure", autoplay: t }) }) } } updateSourceCaches_(e = "") { let t = e, i = ""; "string" != typeof t && (t = e.src, i = e.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], t && !i && (i = ((e, t) => { if (!t) return ""; if (e.cache_.source.src === t && e.cache_.source.type) return e.cache_.source.type; var i = e.cache_.sources.filter(e => e.src === t); if (i.length) return i[0].type; var s = e.$$("source"); for (let e = 0; e < s.length; e++) { var n = s[e]; if (n.type && n.src && n.src === t) return n.type } return ws(t) })(this, t)), this.cache_.source = h({}, e, { src: t, type: i }); var e = this.cache_.sources.filter(e => e.src && e.src === t), s = [], n = this.$$("source"), r = []; for (let e = 0; e < n.length; e++) { var a = Le(n[e]); s.push(a), a.src && a.src === t && r.push(a.src) } r.length && !e.length ? this.cache_.sources = s : e.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = t } handleTechSourceset_(t) { if (!this.changingSrc_) { let e = e => this.updateSourceCaches_(e); var i = this.currentSource().src, s = t.src; (e = !i || /^blob:/.test(i) || !/^blob:/.test(s) || this.lastSource_ && (this.lastSource_.tech === s || this.lastSource_.player === i) ? e : () => { })(s), t.src || this.tech_.any(["sourceset", "loadstart"], e => { "sourceset" !== e.type && (e = this.techGet_("currentSrc"), this.lastSource_.tech = e, this.updateSourceCaches_(e)) }) } this.lastSource_ = { player: this.currentSource().src, tech: t.src }, this.trigger({ src: t.src, type: "sourceset" }) } hasStarted(e) { if (void 0 === e) return this.hasStarted_; e !== this.hasStarted_ && (this.hasStarted_ = e, this.hasStarted_ ? this.addClass("vjs-has-started") : this.removeClass("vjs-has-started")) } handleTechPlay_() { this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play") } handleTechRateChange_() { 0 < this.tech_.playbackRate() && 0 === this.cache_.lastPlaybackRate && (this.queuedCallbacks_.forEach(e => e.callback(e.event)), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange") } handleTechWaiting_() { this.addClass("vjs-waiting"), this.trigger("waiting"); const e = this.currentTime(), t = () => { e !== this.currentTime() && (this.removeClass("vjs-waiting"), this.off("timeupdate", t)) }; this.on("timeupdate", t) } handleTechCanPlay_() { this.removeClass("vjs-waiting"), this.trigger("canplay") } handleTechCanPlayThrough_() { this.removeClass("vjs-waiting"), this.trigger("canplaythrough") } handleTechPlaying_() { this.removeClass("vjs-waiting"), this.trigger("playing") } handleTechSeeking_() { this.addClass("vjs-seeking"), this.trigger("seeking") } handleTechSeeked_() { this.removeClass("vjs-seeking", "vjs-ended"), this.trigger("seeked") } handleTechPause_() { this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause") } handleTechEnded_() { this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended") } handleTechDurationChange_() { this.duration(this.techGet_("duration")) } handleTechClick_(e) { !this.controls_ || void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.click && !1 === this.options_.userActions.click || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" == typeof this.options_.userActions.click ? this.options_.userActions.click.call(this, e) : this.paused() ? Gt(this.play()) : this.pause()) } handleTechDoubleClick_(t) { !this.controls_ || Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), e => e.contains(t.target)) || void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.doubleClick && !1 === this.options_.userActions.doubleClick || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" == typeof this.options_.userActions.doubleClick ? this.options_.userActions.doubleClick.call(this, t) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen()) } handleTechTap_() { this.userActive(!this.userActive()) } handleTechTouchStart_() { this.userWasActive = this.userActive() } handleTechTouchMove_() { this.userWasActive && this.reportUserActivity() } handleTechTouchEnd_(e) { e.cancelable && e.preventDefault() } toggleFullscreenClass_() { this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen") } documentFullscreenChange_(t) { t = t.target.player; if (!t || t === this) { t = this.el(); let e = document[this.fsApi_.fullscreenElement] === t; !e && t.matches && (e = t.matches(":" + this.fsApi_.fullscreen)), this.isFullscreen(e) } } handleTechFullscreenChange_(e, t) { t && (t.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", () => { this.removeClass("vjs-ios-native-fs") })), this.isFullscreen(t.isFullscreen)) } handleTechFullscreenError_(e, t) { this.trigger("fullscreenerror", t) } togglePictureInPictureClass_() { this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture") } handleTechEnterPictureInPicture_(e) { this.isInPictureInPicture(!0) } handleTechLeavePictureInPicture_(e) { this.isInPictureInPicture(!1) } handleTechError_() { var e = this.tech_.error(); this.error(e) } handleTechTextData_() { let e = 1 < arguments.length ? arguments[1] : null; this.trigger("textdata", e) } getCache() { return this.cache_ } resetCache_() { this.cache_ = { currentTime: 0, initTime: 0, inactivityTimeout: this.options_.inactivityTimeout, duration: NaN, lastVolume: 1, lastPlaybackRate: this.defaultPlaybackRate(), media: null, src: "", source: {}, sources: [], playbackRates: [], volume: 1 } } techCall_(t, i) { this.ready(function () { if (t in ys) return e = this.middleware_, this.tech_[t](e.reduce(vs(t), i)); if (t in _s) return gs(this.middleware_, this.tech_, t, i); var e; try { this.tech_ && this.tech_[t](i) } catch (e) { throw d(e), e } }, !0) } techGet_(t) { if (this.tech_ && this.tech_.isReady_) { if (t in fs) return e = this.middleware_, i = this.tech_, e.reduceRight(vs(t), i[t]()); if (t in _s) return gs(this.middleware_, this.tech_, t); var e, i; try { return this.tech_[t]() } catch (e) { throw void 0 === this.tech_[t] ? d(`Video.js: ${t} method not defined for ${this.techName_} playback technology.`, e) : "TypeError" === e.name ? (d(`Video.js: ${t} unavailable on ${this.techName_} playback technology element.`, e), this.tech_.isReady_ = !1) : d(e), e } } } play() { return new Promise(e => { this.play_(e) }) } play_(e = Gt) { this.playCallbacks_.push(e); var t, e = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc())), i = Boolean(ye || u); this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), this.isReady_ && e ? (t = this.techGet_("play"), i && this.hasClass("vjs-ended") && this.resetProgressBar_(), null === t ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(t)) : (this.waitToPlay_ = e => { this.play_() }, this.one(["ready", "loadstart"], this.waitToPlay_), !e && i && this.load()) } runPlayTerminatedQueue_() { var e = this.playTerminatedQueue_.slice(0); this.playTerminatedQueue_ = [], e.forEach(function (e) { e() }) } runPlayCallbacks_(t) { var e = this.playCallbacks_.slice(0); this.playCallbacks_ = [], this.playTerminatedQueue_ = [], e.forEach(function (e) { e(t) }) } pause() { this.techCall_("pause") } paused() { return !1 !== this.techGet_("paused") } played() { return this.techGet_("played") || Ut(0, 0) } scrubbing(e) { if ("undefined" == typeof e) return this.scrubbing_; this.scrubbing_ = !!e, this.techCall_("setScrubbing", this.scrubbing_), e ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing") } currentTime(e) { if (void 0 === e) return this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime; e < 0 && (e = 0), this.isReady_ && !this.changingSrc_ && this.tech_ && this.tech_.isReady_ ? (this.techCall_("setCurrentTime", e), this.cache_.initTime = 0, isFinite(e) && (this.cache_.currentTime = Number(e))) : (this.cache_.initTime = e, this.off("canplay", this.boundApplyInitTime_), this.one("canplay", this.boundApplyInitTime_)) } applyInitTime_() { this.currentTime(this.cache_.initTime) } duration(e) { if (void 0 === e) return void 0 !== this.cache_.duration ? this.cache_.duration : NaN; (e = (e = parseFloat(e)) < 0 ? 1 / 0 : e) !== this.cache_.duration && ((this.cache_.duration = e) === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(e) || this.trigger("durationchange")) } remainingTime() { return this.duration() - this.currentTime() } remainingTimeDisplay() { return Math.floor(this.duration()) - Math.floor(this.currentTime()) } buffered() { let e = this.techGet_("buffered"); return e = e && e.length ? e : Ut(0, 0) } bufferedPercent() { return zt(this.buffered(), this.duration()) } bufferedEnd() { var e = this.buffered(), t = this.duration(); let i = e.end(e.length - 1); return i = i > t ? t : i } volume(e) { let t; if (void 0 === e) return t = parseFloat(this.techGet_("volume")), isNaN(t) ? 1 : t; t = Math.max(0, Math.min(1, e)), this.cache_.volume = t, this.techCall_("setVolume", t), 0 < t && this.lastVolume_(t) } muted(e) { if (void 0 === e) return this.techGet_("muted") || !1; this.techCall_("setMuted", e) } defaultMuted(e) { return void 0 !== e && this.techCall_("setDefaultMuted", e), this.techGet_("defaultMuted") || !1 } lastVolume_(e) { if (void 0 === e || 0 === e) return this.cache_.lastVolume; this.cache_.lastVolume = e } supportsFullScreen() { return this.techGet_("supportsFullScreen") || !1 } isFullscreen(e) { var t; if (void 0 === e) return this.isFullscreen_; t = this.isFullscreen_, this.isFullscreen_ = Boolean(e), this.isFullscreen_ !== t && this.fsApi_.prefixed && this.trigger("fullscreenchange"), this.toggleFullscreenClass_() } requestFullscreen(a) { this.isInPictureInPicture() && this.exitPictureInPicture(); const o = this; return new Promise((e, i) => { function s() { o.off("fullscreenerror", n), o.off("fullscreenchange", t) } function t() { s(), e() } function n(e, t) { s(), i(t) } o.one("fullscreenchange", t), o.one("fullscreenerror", n); var r = o.requestFullscreenHelper_(a); r && (r.then(s, s), r.then(e, i)) }) } requestFullscreenHelper_(e) { let t; if (this.fsApi_.prefixed || (t = this.options_.fullscreen && this.options_.fullscreen.options || {}, void 0 !== e && (t = e)), this.fsApi_.requestFullscreen) return (e = this.el_[this.fsApi_.requestFullscreen](t)) && e.then(() => this.isFullscreen(!0), () => this.isFullscreen(!1)), e; this.tech_.supportsFullScreen() && !0 == !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow() } exitFullscreen() { const a = this; return new Promise((e, i) => { function s() { a.off("fullscreenerror", n), a.off("fullscreenchange", t) } function t() { s(), e() } function n(e, t) { s(), i(t) } a.one("fullscreenchange", t), a.one("fullscreenerror", n); var r = a.exitFullscreenHelper_(); r && (r.then(s, s), r.then(e, i)) }) } exitFullscreenHelper_() { var e; if (this.fsApi_.requestFullscreen) return (e = document[this.fsApi_.exitFullscreen]()) && Gt(e.then(() => this.isFullscreen(!1))), e; this.tech_.supportsFullScreen() && !0 == !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow() } enterFullWindow() { this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = document.documentElement.style.overflow, lt(document, "keydown", this.boundFullWindowOnEscKey_), document.documentElement.style.overflow = "hidden", ke(document.body, "vjs-full-window"), this.trigger("enterFullWindow") } fullWindowOnEscKey(e) { n.isEventKey(e, "Esc") && !0 === this.isFullscreen() && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen()) } exitFullWindow() { this.isFullscreen(!1), this.isFullWindow = !1, p(document, "keydown", this.boundFullWindowOnEscKey_), document.documentElement.style.overflow = this.docOrigOverflow, Ie(document.body, "vjs-full-window"), this.trigger("exitFullWindow") } disablePictureInPicture(e) { if (void 0 === e) return this.techGet_("disablePictureInPicture"); this.techCall_("setDisablePictureInPicture", e), this.options_.disablePictureInPicture = e, this.trigger("disablepictureinpicturechanged") } isInPictureInPicture(e) { if (void 0 === e) return !!this.isInPictureInPicture_; this.isInPictureInPicture_ = !!e, this.togglePictureInPictureClass_() } requestPictureInPicture() { if (this.options_.enableDocumentPictureInPicture && window.documentPictureInPicture) { const t = document.createElement(this.el().tagName); return t.classList = this.el().classList, t.classList.add("vjs-pip-container"), this.posterImage && t.appendChild(this.posterImage.el().cloneNode(!0)), this.titleBar && t.appendChild(this.titleBar.el().cloneNode(!0)), t.appendChild(o("p", { className: "vjs-pip-text" }, {}, this.localize("Playing in picture-in-picture"))), window.documentPictureInPicture.requestWindow({ width: this.videoWidth(), height: this.videoHeight(), copyStyleSheets: !0 }).then(e => (this.el_.parentNode.insertBefore(t, this.el_), e.document.body.append(this.el_), e.document.body.classList.add("vjs-pip-window"), this.player_.isInPictureInPicture(!0), this.player_.trigger("enterpictureinpicture"), e.addEventListener("unload", e => { e = e.target.querySelector(".video-js"); t.replaceWith(e), this.player_.isInPictureInPicture(!1), this.player_.trigger("leavepictureinpicture") }), e)) } return "pictureInPictureEnabled" in document && !1 === this.disablePictureInPicture() ? this.techGet_("requestPictureInPicture") : Promise.reject("No PiP mode is available") } exitPictureInPicture() { return window.documentPictureInPicture && window.documentPictureInPicture.window ? (window.documentPictureInPicture.window.close(), Promise.resolve()) : "pictureInPictureEnabled" in document ? document.exitPictureInPicture() : void 0 } handleKeyDown(e) { var t, i, s = this.options_["userActions"]; s && s.hotkeys && (t = this.el_.ownerDocument.activeElement, i = t.tagName.toLowerCase(), t.isContentEditable || ("input" === i ? -1 === ["button", "checkbox", "hidden", "radio", "reset", "submit"].indexOf(t.type) : -1 !== ["textarea"].indexOf(i)) || ("function" == typeof s.hotkeys ? s.hotkeys.call(this, e) : this.handleHotkeys(e))) } handleHotkeys(e) { var { fullscreenKey: t = e => n.isEventKey(e, "f"), muteKey: i = e => n.isEventKey(e, "m"), playPauseKey: s = e => n.isEventKey(e, "k") || n.isEventKey(e, "Space") } = this.options_.userActions ? this.options_.userActions.hotkeys : {}; t.call(this, e) ? (e.preventDefault(), e.stopPropagation(), t = f.getComponent("FullscreenToggle"), !1 !== document[this.fsApi_.fullscreenEnabled] && t.prototype.handleClick.call(this, e)) : i.call(this, e) ? (e.preventDefault(), e.stopPropagation(), f.getComponent("MuteToggle").prototype.handleClick.call(this, e)) : s.call(this, e) && (e.preventDefault(), e.stopPropagation(), f.getComponent("PlayToggle").prototype.handleClick.call(this, e)) } canPlayType(s) { var n; for (let t = 0, i = this.options_.techOrder; t < i.length; t++) { var r = i[t]; let e = _.getTech(r); if (e = e || f.getComponent(r)) { if (e.isSupported() && (n = e.canPlayType(s))) return n } else d.error(`The "${r}" tech is undefined. Skipped browser support check for that tech.`) } return "" } selectSource(e) { function t(e, i, s) { let n; return e.some(t => i.some(e => { if (n = s(t, e)) return !0 })), n } var i = this.options_.techOrder.map(e => [e, _.getTech(e)]).filter(([e, t]) => t ? t.isSupported() : (d.error(`The "${e}" tech is undefined. Skipped browser support check for that tech.`), !1)); let s; var n, r = ([e, t], i) => { if (t.canPlaySource(i, this.options_[e.toLowerCase()])) return { source: i, tech: e } }; return (s = this.options_.sourceOrder ? t(e, i, (n = r, (e, t) => n(t, e))) : t(i, e, r)) || !1 } handleSrc_(e, s) { if ("undefined" == typeof e) return this.cache_.src || ""; this.resetRetryOnError_ && this.resetRetryOnError_(); const n = Ts(e); if (n.length) { if (this.changingSrc_ = !0, s || (this.cache_.sources = n), this.updateSourceCaches_(n[0]), ms(this, n[0], (e, t) => { var i; if (this.middleware_ = t, s || (this.cache_.sources = n), this.updateSourceCaches_(e), this.src_(e)) return 1 < n.length ? this.handleSrc_(n.slice(1)) : (this.changingSrc_ = !1, this.setTimeout(function () { this.error({ code: 4, message: this.options_.notSupportedMessage }) }, 0), void this.triggerReady()); i = this.tech_, t.forEach(e => e.setTech && e.setTech(i)) }), 1 < n.length) { const t = () => { this.error(null), this.handleSrc_(n.slice(1), !0) }, i = () => { this.off("error", t) }; this.one("error", t), this.one("playing", i), this.resetRetryOnError_ = () => { this.off("error", t), this.off("playing", i) } } } else this.setTimeout(function () { this.error({ code: 4, message: this.options_.notSupportedMessage }) }, 0) } src(e) { return this.handleSrc_(e, !1) } src_(e) { var t = this.selectSource([e]); return !t || (Pt(t.tech, this.techName_) ? this.ready(function () { this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", e) : this.techCall_("src", e.src), this.changingSrc_ = !1 }, !0) : (this.changingSrc_ = !0, this.loadTech_(t.tech, t.source), this.tech_.ready(() => { this.changingSrc_ = !1 })), !1) } load() { this.tech_ && this.tech_.vhs ? this.src(this.currentSource()) : this.techCall_("load") } reset() { this.paused() ? this.doReset_() : Gt(this.play().then(() => this.doReset_())) } doReset_() { this.tech_ && this.tech_.clearTracks("text"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), vt(this) && this.trigger("playerreset") } resetControlBarUI_() { this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_() } resetProgressBar_() { this.currentTime(0); var { currentTimeDisplay: e, durationDisplay: t, progressControl: i, remainingTimeDisplay: s } = this.controlBar || {}, i = (i || {})["seekBar"]; e && e.updateContent(), t && t.updateContent(), s && s.updateContent(), i && (i.update(), i.loadProgressBar) && i.loadProgressBar.update() } resetPlaybackRate_() { this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_() } resetVolumeBar_() { this.volume(1), this.trigger("volumechange") } currentSources() { var e = this.currentSource(), t = []; return 0 !== Object.keys(e).length && t.push(e), this.cache_.sources || t } currentSource() { return this.cache_.source || {} } currentSrc() { return this.currentSource() && this.currentSource().src || "" } currentType() { return this.currentSource() && this.currentSource().type || "" } preload(e) { if (void 0 === e) return this.techGet_("preload"); this.techCall_("setPreload", e), this.options_.preload = e } autoplay(e) { if (void 0 === e) return this.options_.autoplay || !1; let t; "string" == typeof e && /(any|play|muted)/.test(e) || !0 === e && this.options_.normalizeAutoplay ? (this.options_.autoplay = e, this.manualAutoplay_("string" == typeof e ? e : "play"), t = !1) : this.options_.autoplay = !!e, t = "undefined" == typeof t ? this.options_.autoplay : t, this.tech_ && this.techCall_("setAutoplay", t) } playsinline(e) { return void 0 !== e && (this.techCall_("setPlaysinline", e), this.options_.playsinline = e), this.techGet_("playsinline") } loop(e) { if (void 0 === e) return this.techGet_("loop"); this.techCall_("setLoop", e), this.options_.loop = e } poster(e) { if (void 0 === e) return this.poster_; (e = e || "") !== this.poster_ && (this.poster_ = e, this.techCall_("setPoster", e), this.isPosterFromTech_ = !1, this.trigger("posterchange")) } handleTechPosterChange_() { var e; (!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster && (e = this.tech_.poster() || "") !== this.poster_ && (this.poster_ = e, this.isPosterFromTech_ = !0, this.trigger("posterchange")) } controls(e) { if (void 0 === e) return !!this.controls_; this.controls_ !== (e = !!e) && (this.controls_ = e, this.usingNativeControls() && this.techCall_("setControls", e), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_())) } usingNativeControls(e) { if (void 0 === e) return !!this.usingNativeControls_; this.usingNativeControls_ !== (e = !!e) && (this.usingNativeControls_ = e, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols"))) } error(t) { if (void 0 === t) return this.error_ || null; if (B("beforeerror").forEach(e => { e = e(this, t); K(e) && !Array.isArray(e) || "string" == typeof e || "number" == typeof e || null === e ? t = e : this.log.error("please return a value that MediaError expects in beforeerror hooks") }), this.options_.suppressNotSupportedError && t && 4 === t.code) { const e = function () { this.error(t) }; this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], e), void this.one("loadstart", function () { this.off(["click", "touchstart"], e) }) } else null === t ? (this.error_ = null, this.removeClass("vjs-error"), this.errorDisplay && this.errorDisplay.close()) : (this.error_ = new i(t), this.addClass("vjs-error"), d.error(`(CODE:${this.error_.code} ${i.errorTypes[this.error_.code]})`, this.error_.message, this.error_), this.trigger("error"), B("error").forEach(e => e(this, this.error_))) } reportUserActivity(e) { this.userActivity_ = !0 } userActive(e) { if (void 0 === e) return this.userActive_; (e = !!e) !== this.userActive_ && (this.userActive_ = e, this.userActive_ ? (this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), this.trigger("useractive")) : (this.tech_ && this.tech_.one("mousemove", function (e) { e.stopPropagation(), e.preventDefault() }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive"))) } listenForUserActivity_() { let t, i, s; const n = m(this, this.reportUserActivity); function e(e) { n(), this.clearInterval(t) } this.on("mousedown", function () { n(), this.clearInterval(t), t = this.setInterval(n, 250) }), this.on("mousemove", function (e) { e.screenX === i && e.screenY === s || (i = e.screenX, s = e.screenY, n()) }), this.on("mouseup", e), this.on("mouseleave", e); var r = this.getChild("controlBar"); !r || u || ie || (r.on("mouseenter", function (e) { 0 !== this.player().options_.inactivityTimeout && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0 }), r.on("mouseleave", function (e) { this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout })), this.on("keydown", n), this.on("keyup", n); let a; this.setInterval(function () { var e; this.userActivity_ && (this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(a), (e = this.options_.inactivityTimeout) <= 0 || (a = this.setTimeout(function () { this.userActivity_ || this.userActive(!1) }, e))) }, 250) } playbackRate(e) { if (void 0 === e) return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1; this.techCall_("setPlaybackRate", e) } defaultPlaybackRate(e) { return void 0 !== e ? this.techCall_("setDefaultPlaybackRate", e) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1 } isAudio(e) { if (void 0 === e) return !!this.isAudio_; this.isAudio_ = !!e } enableAudioOnlyUI_() { this.addClass("vjs-audio-only-mode"); var e = this.children(); const t = this.getChild("ControlBar"); var i = t && t.currentHeight(); e.forEach(e => { e !== t && e.el_ && !e.hasClass("vjs-hidden") && (e.hide(), this.audioOnlyCache_.hiddenChildren.push(e)) }), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.height(i), this.trigger("audioonlymodechange") } disableAudioOnlyUI_() { this.removeClass("vjs-audio-only-mode"), this.audioOnlyCache_.hiddenChildren.forEach(e => e.show()), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange") } audioOnlyMode(e) { return "boolean" != typeof e || e === this.audioOnlyMode_ ? this.audioOnlyMode_ : (this.audioOnlyMode_ = e) ? (e = [], this.isInPictureInPicture() && e.push(this.exitPictureInPicture()), this.isFullscreen() && e.push(this.exitFullscreen()), this.audioPosterMode() && e.push(this.audioPosterMode(!1)), Promise.all(e).then(() => this.enableAudioOnlyUI_())) : Promise.resolve().then(() => this.disableAudioOnlyUI_()) } enablePosterModeUI_() { (this.tech_ && this.tech_).hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange") } disablePosterModeUI_() { (this.tech_ && this.tech_).show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange") } audioPosterMode(e) { return "boolean" != typeof e || e === this.audioPosterMode_ ? this.audioPosterMode_ : (this.audioPosterMode_ = e) ? (this.audioOnlyMode() ? this.audioOnlyMode(!1) : Promise.resolve()).then(() => { this.enablePosterModeUI_() }) : Promise.resolve().then(() => { this.disablePosterModeUI_() }) } addTextTrack(e, t, i) { if (this.tech_) return this.tech_.addTextTrack(e, t, i) } addRemoteTextTrack(e, t) { if (this.tech_) return this.tech_.addRemoteTextTrack(e, t) } removeRemoteTextTrack(e = {}) { let t = e["track"]; if (t = t || e, this.tech_) return this.tech_.removeRemoteTextTrack(t) } getVideoPlaybackQuality() { return this.techGet_("getVideoPlaybackQuality") } videoWidth() { return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0 } videoHeight() { return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0 } language(e) { if (void 0 === e) return this.language_; this.language_ !== String(e).toLowerCase() && (this.language_ = String(e).toLowerCase(), vt(this)) && this.trigger("languagechange") } languages() { return h(b.prototype.options_.languages, this.languages_) } toJSON() { var t = h(this.options_), i = t.tracks; t.tracks = []; for (let e = 0; e < i.length; e++) { var s = i[e]; (s = h(s)).player = void 0, t.tracks[e] = s } return t } createModal(e, t) { (t = t || {}).content = e || ""; const i = new Jt(this, t); return this.addChild(i), i.on("dispose", () => { this.removeChild(i) }), i.open(), i } updateCurrentBreakpoint_() { if (this.responsive()) { var t = this.currentBreakpoint(), i = this.currentWidth(); for (let e = 0; e < ir.length; e++) { var s = ir[e]; if (i <= this.breakpoints_[s]) { if (t === s) return; t && this.removeClass(sr[t]), this.addClass(sr[s]), this.breakpoint_ = s; break } } } } removeCurrentBreakpoint_() { var e = this.currentBreakpointClass(); this.breakpoint_ = "", e && this.removeClass(e) } breakpoints(e) { return void 0 !== e && (this.breakpoint_ = "", this.breakpoints_ = Object.assign({}, nr, e), this.updateCurrentBreakpoint_()), Object.assign(this.breakpoints_) } responsive(e) { return void 0 === e ? this.responsive_ : (e = Boolean(e)) !== this.responsive_ ? ((this.responsive_ = e) ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), e) : void 0 } currentBreakpoint() { return this.breakpoint_ } currentBreakpointClass() { return sr[this.breakpoint_] || "" } loadMedia(e, t) { var i, s, n, r, a, o, l; e && "object" == typeof e && (i = this.crossOrigin(), { artist: e, artwork: s, description: n, poster: r, src: a, textTracks: o, title: l } = (this.reset(), this.cache_.media = h(e), this.cache_.media), !s && r && (this.cache_.media.artwork = [{ src: r, type: ws(r) }]), i && this.crossOrigin(i), a && this.src(a), r && this.poster(r), Array.isArray(o) && o.forEach(e => this.addRemoteTextTrack(e, !1)), this.titleBar && this.titleBar.update({ title: l, description: n || e || "" }), this.ready(t)) } getMedia() { var e, t; return this.cache_.media ? h(this.cache_.media) : (e = this.poster(), t = { src: this.currentSources(), textTracks: Array.prototype.map.call(this.remoteTextTracks(), e => ({ kind: e.kind, label: e.label, language: e.language, src: e.src })) }, e && (t.poster = e, t.artwork = [{ src: t.poster, type: ws(t.poster) }]), t) } static getTagSettings(e) { var t, i = { sources: [], tracks: [] }, s = Le(e), n = s["data-setup"]; if (Ce(e, "vjs-fill") && (s.fill = !0), Ce(e, "vjs-fluid") && (s.fluid = !0), null !== n && ([n, t] = $t(n || "{}"), n && d.error(n), Object.assign(s, t)), Object.assign(i, s), e.hasChildNodes()) { var r = e.childNodes; for (let e = 0, t = r.length; e < t; e++) { var a = r[e], o = a.nodeName.toLowerCase(); "source" === o ? i.sources.push(Le(a)) : "track" === o && i.tracks.push(Le(a)) } } return i } debug(e) { if (void 0 === e) return this.debugEnabled_; e ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1) } playbackRates(e) { if (void 0 === e) return this.cache_.playbackRates; Array.isArray(e) && e.every(e => "number" == typeof e) && (this.cache_.playbackRates = e, this.trigger("playbackrateschange")) }
  } a.names.forEach(function (e) { const t = a[e]; b.prototype[t.getterName] = function () { return this.tech_ ? this.tech_[t.getterName]() : (this[t.privateName] = this[t.privateName] || new t.ListClass, this[t.privateName]) } }), b.prototype.crossorigin = b.prototype.crossOrigin, b.players = {}; Rn = window.navigator; b.prototype.options_ = { techOrder: _.defaultTechOrder_, html5: {}, enableSourceset: !0, inactivityTimeout: 2e3, playbackRates: [], liveui: !1, children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"], language: Rn && (Rn.languages && Rn.languages[0] || Rn.userLanguage || Rn.language) || "en", languages: {}, notSupportedMessage: "No compatible source was found for this media.", normalizeAutoplay: !1, fullscreen: { options: { navigationUI: "hide" } }, breakpoints: {}, responsive: !1, audioOnlyMode: !1, audioPosterMode: !1 }, ["ended", "seeking", "seekable", "networkState", "readyState"].forEach(function (e) { b.prototype[e] = function () { return this.techGet_(e) } }), er.forEach(function (e) { b.prototype[`handleTech${g(e)}_`] = function () { return this.trigger(e) } }), f.registerComponent("Player", b); function rr(t, i) { function s() { cr(this, { name: t, plugin: i, instance: null }, !0); var e = i.apply(this, arguments); return ur(this, t), cr(this, { name: t, plugin: i, instance: e }), e } return Object.keys(i).forEach(function (e) { s[e] = i[e] }), s } const ar = "plugin", or = "activePlugins_", lr = {}, dr = e => lr.hasOwnProperty(e), hr = e => dr(e) ? lr[e] : void 0, ur = (e, t) => { e[or] = e[or] || {}, e[or][t] = !0 }, cr = (e, t, i) => { i = (i ? "before" : "") + "pluginsetup"; e.trigger(i, t), e.trigger(i + ":" + t.name, t) }, pr = (i, s) => (s.prototype.name = i, function (...e) { cr(this, { name: i, plugin: s, instance: null }, !0); const t = new s(this, ...e); return this[i] = () => t, cr(this, t.getEventHash()), t }); class mr { constructor(e) { if (this.constructor === mr) throw new Error("Plugin must be sub-classed; not directly instantiated."); this.player = e, this.log || (this.log = this.player.log.createLogger(this.name)), It(this), delete this.trigger, At(this, this.constructor.defaultState), ur(e, this.name), this.dispose = this.dispose.bind(this), e.on("dispose", this.dispose) } version() { return this.constructor.VERSION } getEventHash(e = {}) { return e.name = this.name, e.plugin = this.constructor, e.instance = this, e } trigger(e, t = {}) { return dt(this.eventBusEl_, e, this.getEventHash(t)) } handleStateChanged(e) { } dispose() { var { name: e, player: t } = this; this.trigger("dispose"), this.off(), t.off("dispose", this.dispose), t[or][e] = !1, this.player = this.state = null, t[e] = pr(e, lr[e]) } static isBasic(e) { e = "string" == typeof e ? hr(e) : e; return "function" == typeof e && !mr.prototype.isPrototypeOf(e.prototype) } static registerPlugin(e, t) { if ("string" != typeof e) throw new Error(`Illegal plugin name, "${e}", must be a string, was ${typeof e}.`); if (dr(e)) d.warn(`A plugin named "${e}" already exists. You may want to avoid re-registering plugins!`); else if (b.prototype.hasOwnProperty(e)) throw new Error(`Illegal plugin name, "${e}", cannot share a name with an existing player method!`); if ("function" != typeof t) throw new Error(`Illegal plugin for "${e}", must be a function, was ${typeof t}.`); return lr[e] = t, e !== ar && (mr.isBasic(t) ? b.prototype[e] = rr(e, t) : b.prototype[e] = pr(e, t)), t } static deregisterPlugin(e) { if (e === ar) throw new Error("Cannot de-register base plugin."); dr(e) && (delete lr[e], delete b.prototype[e]) } static getPlugins(e = Object.keys(lr)) { let i; return e.forEach(e => { var t = hr(e); t && ((i = i || {})[e] = t) }), i } static getPluginVersion(e) { e = hr(e); return e && e.VERSION || "" } } function gr(e, i, s, n) { { var r = i + ` is deprecated and will be removed in ${e}.0; please use ${s} instead.`, a = n; let t = !1; return function (...e) { return t || false && d.warn(r), t = !0, a.apply(this, e) } } } mr.getPlugin = hr, mr.BASE_PLUGIN_NAME = ar, mr.registerPlugin(ar, mr), b.prototype.usingPlugin = function (e) { return !!this[or] && !0 === this[or][e] }, b.prototype.hasPlugin = function (e) { return !!dr(e) }; const fr = e => 0 === e.indexOf("#") ? e.slice(1) : e; function T(e, t, i) { let s = T.getPlayer(e); if (s) t && d.warn(`Player "${e}" is already initialised. Options will not be applied.`), i && s.ready(i); else { const n = "string" == typeof e ? $e("#" + fr(e)) : e; if (!be(n)) throw new TypeError("The element or ID supplied is not valid. (tm_videojs)"); e = n.getRootNode() instanceof window.ShadowRoot ? n.getRootNode() : n.ownerDocument.body, e = (n.ownerDocument.defaultView && e.contains(n) || d.warn("The element supplied is not included in the DOM"), !0 === (t = t || {}).restoreEl && (t.restoreEl = (n.parentNode && n.parentNode.hasAttribute("data-vjs-player") ? n.parentNode : n).cloneNode(!0)), B("beforesetup").forEach(e => { e = e(n, h(t)); !K(e) || Array.isArray(e) ? d.error("please return an object in beforesetup hooks") : t = h(t, e) }), f.getComponent("Player")); s = new e(n, t, i), B("setup").forEach(e => e(s)) } return s } T.hooks_ = U, T.hooks = B, T.hook = function (e, t) { B(e, t) }, T.hookOnce = function (s, e) { B(s, [].concat(e).map(t => { const i = (...e) => (F(s, i), t(...e)); return i })) }, T.removeHook = F, !0 !== window.TM_VIDEOJS_NO_DYNAMIC_STYLE && ve() && !(Ri = $e(".vjs-styles-defaults")) && (Ri = et("vjs-styles-defaults"), (Nn = $e("head")) && Nn.insertBefore(Ri, Nn.firstChild), tt(Ri, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `)), Je(1, T), T.VERSION = R, T.options = b.prototype.options_, T.getPlayers = () => b.players, T.getPlayer = e => { var t = b.players; let i; if ("string" == typeof e) { var s = fr(e), n = t[s]; if (n) return n; i = $e("#" + s) } else i = e; if (be(i)) { var { player: n, playerId: s } = i; if (n || t[s]) return n || t[s] } }, T.getAllPlayers = () => Object.keys(b.players).map(e => b.players[e]).filter(Boolean), T.players = b.players, T.getComponent = f.getComponent, T.registerComponent = (e, t) => (_.isTech(t) && d.warn(`The ${e} tech was registered as a component. It should instead be registered using tm_videojs.registerTech(name, tech)`), f.registerComponent.call(f, e, t)), T.getTech = _.getTech, T.registerTech = _.registerTech, T.use = function (e, t) { us[e] = us[e] || [], us[e].push(t) }, Object.defineProperty(T, "middleware", { value: {}, writeable: !1, enumerable: !0 }), Object.defineProperty(T.middleware, "TERMINATOR", { value: ps, writeable: !1, enumerable: !0 }), T.browser = e, T.obj = Z, T.mergeOptions = gr(9, "tm_videojs.mergeOptions", "tm_videojs.obj.merge", h), T.defineLazyProperty = gr(9, "tm_videojs.defineLazyProperty", "tm_videojs.obj.defineLazyProperty", J), T.bind = gr(9, "tm_videojs.bind", "native Function.prototype.bind", m), T.registerPlugin = mr.registerPlugin, T.deregisterPlugin = mr.deregisterPlugin, T.plugin = (e, t) => (d.warn("tm_videojs.plugin() is deprecated; use tm_videojs.registerPlugin() instead"), mr.registerPlugin(e, t)), T.getPlugins = mr.getPlugins, T.getPlugin = mr.getPlugin, T.getPluginVersion = mr.getPluginVersion, T.addLanguage = function (e, t) { return e = ("" + e).toLowerCase(), T.options.languages = h(T.options.languages, { [e]: t }), T.options.languages[e] }, T.log = d, T.createLogger = $, T.time = qt, T.createTimeRange = gr(9, "tm_videojs.createTimeRange", "tm_videojs.time.createTimeRanges", Ut), T.createTimeRanges = gr(9, "tm_videojs.createTimeRanges", "tm_videojs.time.createTimeRanges", Ut), T.formatTime = gr(9, "tm_videojs.formatTime", "tm_videojs.time.formatTime", Vt), T.setFormatTime = gr(9, "tm_videojs.setFormatTime", "tm_videojs.time.setFormatTime", jt), T.resetFormatTime = gr(9, "tm_videojs.resetFormatTime", "tm_videojs.time.resetFormatTime", Ht), T.parseUrl = gr(9, "tm_videojs.parseUrl", "tm_videojs.url.parseUrl", di), T.isCrossOrigin = gr(9, "tm_videojs.isCrossOrigin", "tm_videojs.url.isCrossOrigin", ui), T.EventTarget = yt, T.any = ut, T.on = lt, T.one = ht, T.off = p, T.trigger = dt, T.xhr = Ti, T.TextTrack = Li, T.AudioTrack = Pi, T.VideoTrack = Di, ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(e => { T[e] = function () { return d.warn(`tm_videojs.${e}() is deprecated; use tm_videojs.dom.${e}() instead`), Xe[e].apply(null, arguments) } }), T.computedStyle = gr(9, "tm_videojs.computedStyle", "tm_videojs.dom.computedStyle", Ge), T.dom = Xe, T.fn = gt, T.num = mi, T.str = Dt, T.url = pi, Mt(function (e, t) {
    /*! @name tm_videojs-contrib-quality-levels @version 4.0.0 @license Apache-2.0 */
    e.exports = function (e) { function t(e) { return e && typeof e === "object" && "default" in e ? e : { default: e } } var i = t(e); class s { constructor(e) { let t = this; t.id = e.id; t.label = t.id; t.width = e.width; t.height = e.height; t.bitrate = e.bandwidth; t.frameRate = e.frameRate; t.enabled_ = e.enabled; Object.defineProperty(t, "enabled", { get() { return t.enabled_() }, set(e) { t.enabled_(e) } }); return t } } class r extends i["default"].EventTarget { constructor() { super(); let e = this; e.levels_ = []; e.selectedIndex_ = -1; Object.defineProperty(e, "selectedIndex", { get() { return e.selectedIndex_ } }); Object.defineProperty(e, "length", { get() { return e.levels_.length } }); e[Symbol.iterator] = () => e.levels_.values(); return e } addQualityLevel(e) { let t = this.getQualityLevelById(e.id); if (t) return t; const i = this.levels_.length; t = new s(e); if (!("" + i in this)) Object.defineProperty(this, i, { get() { return this.levels_[i] } }); this.levels_.push(t); this.trigger({ qualityLevel: t, type: "addqualitylevel" }); return t } removeQualityLevel(i) { let s = null; for (let e = 0, t = this.length; e < t; e++)if (this[e] === i) { s = this.levels_.splice(e, 1)[0]; if (this.selectedIndex_ === e) this.selectedIndex_ = -1; else if (this.selectedIndex_ > e) this.selectedIndex_--; break } if (s) this.trigger({ qualityLevel: i, type: "removequalitylevel" }); return s } getQualityLevelById(i) { for (let e = 0, t = this.length; e < t; e++) { const s = this[e]; if (s.id === i) return s } return null } dispose() { this.selectedIndex_ = -1; this.levels_.length = 0 } } r.prototype.allowedEvents_ = { change: "change", addqualitylevel: "addqualitylevel", removequalitylevel: "removequalitylevel" }; for (const l in r.prototype.allowedEvents_) r.prototype["on" + l] = null; var a = "4.0.0"; const n = function (e, t) { const i = e.qualityLevels; const s = new r; const n = function () { s.dispose(); e.qualityLevels = i; e.off("dispose", n) }; e.on("dispose", n); e.qualityLevels = () => s; e.qualityLevels.VERSION = a; return s }, o = function (e) { return n(this, i["default"].obj.merge({}, e)) }; return i["default"].registerPlugin("qualityLevels", o), o.VERSION = a, o }(T)
  }); var yr = Mt(function (e, t) { var i, r, s, n, a; i = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r = /^(?=([^\/?#]*))\1([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, n = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a = { buildAbsoluteURL: function (e, t, i) { if (i = i || {}, e = e.trim(), !(t = t.trim())) { if (!i.alwaysNormalize) return e; var s = a.parseURL(e); if (s) return s.path = a.normalizePath(s.path), a.buildURLFromParts(s); throw new Error("Error trying to parse base URL.") } s = a.parseURL(t); if (!s) throw new Error("Error trying to parse relative URL."); if (s.scheme) return i.alwaysNormalize ? (s.path = a.normalizePath(s.path), a.buildURLFromParts(s)) : t; t = a.parseURL(e); if (!t) throw new Error("Error trying to parse base URL."); !t.netLoc && t.path && "/" !== t.path[0] && (e = r.exec(t.path), t.netLoc = e[1], t.path = e[2]), t.netLoc && !t.path && (t.path = "/"); var n, e = { scheme: t.scheme, netLoc: s.netLoc, path: null, params: s.params, query: s.query, fragment: s.fragment }; return s.netLoc || (e.netLoc = t.netLoc, "/" !== s.path[0] && (s.path ? (n = (n = t.path).substring(0, n.lastIndexOf("/") + 1) + s.path, e.path = a.normalizePath(n)) : (e.path = t.path, s.params || (e.params = t.params, s.query) || (e.query = t.query)))), null === e.path && (e.path = i.alwaysNormalize ? a.normalizePath(s.path) : s.path), a.buildURLFromParts(e) }, parseURL: function (e) { e = i.exec(e); return e ? { scheme: e[1] || "", netLoc: e[2] || "", path: e[3] || "", params: e[4] || "", query: e[5] || "", fragment: e[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(s, ""); e.length !== (e = e.replace(n, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }, e.exports = a }), _r = "http://example.com", Mn = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { return !!this.listeners[e] && (t = this.listeners[e].indexOf(t), this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(t, 1), -1 < t) }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var i = t.length, s = 0; s < i; ++s)t[s].call(this, arguments[1]); else for (var n = Array.prototype.slice.call(arguments, 1), r = t.length, a = 0; a < r; ++a)t[a].apply(this, n) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (t) { this.on("data", function (e) { t.push(e) }) }, e }(); function vr(e) { e = e; for (var t = window.atob ? window.atob(e) : Buffer.from(e, "base64").toString("binary"), i = new Uint8Array(t.length), s = 0; s < t.length; s++)i[s] = t.charCodeAt(s); return i }
/*! @name m3u8-parser @version 6.0.0 @license Apache-2.0 */class br extends Mn { constructor() { super(), this.buffer = "" } push(e) { let t; for (this.buffer += e, t = this.buffer.indexOf("\n"); -1 < t; t = this.buffer.indexOf("\n"))this.trigger("data", this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1) } } function Tr(e) { var e = /([0-9.]*)?@?([0-9.]*)?/.exec(e || ""), t = {}; return e[1] && (t.length = parseInt(e[1], 10)), e[2] && (t.offset = parseInt(e[2], 10)), t } function Sr(t) { var i = {}; if (t) { var s, n = t.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))')); let e = n.length; for (; e--;)"" !== n[e] && ((s = /([^=]*)=(.*)/.exec(n[e]).slice(1))[0] = s[0].replace(/^\s+|\s+$/g, ""), s[1] = s[1].replace(/^\s+|\s+$/g, ""), s[1] = s[1].replace(/^['"](.*)['"]$/g, "$1"), i[s[0]] = s[1]) } return i } const wr = String.fromCharCode(9); class Er extends Mn { constructor() { super(), this.customParsers = [], this.tagMappers = [] } push(i) { let s, n; 0 !== (i = i.trim()).length && ("#" !== i[0] ? this.trigger("data", { type: "uri", uri: i }) : this.tagMappers.reduce((e, t) => { t = t(i); return t === i ? e : e.concat([t]) }, [i]).forEach(t => { for (let e = 0; e < this.customParsers.length; e++)if (this.customParsers[e].call(this, t)) return; var e, i; 0 !== t.indexOf("#EXT") ? this.trigger("data", { type: "comment", text: t.slice(1) }) : (t = t.replace("\r", ""), (s = /^#EXTM3U/.exec(t)) ? this.trigger("data", { type: "tag", tagType: "m3u" }) : (s = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(t)) ? (n = { type: "tag", tagType: "inf" }, s[1] && (n.duration = parseFloat(s[1])), s[2] && (n.title = s[2]), this.trigger("data", n)) : (s = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(t)) ? (n = { type: "tag", tagType: "targetduration" }, s[1] && (n.duration = parseInt(s[1], 10)), this.trigger("data", n)) : (s = /^#EXT-X-VERSION:([0-9.]*)?/.exec(t)) ? (n = { type: "tag", tagType: "version" }, s[1] && (n.version = parseInt(s[1], 10)), this.trigger("data", n)) : (s = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(t)) ? (n = { type: "tag", tagType: "media-sequence" }, s[1] && (n.number = parseInt(s[1], 10)), this.trigger("data", n)) : (s = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(t)) ? (n = { type: "tag", tagType: "discontinuity-sequence" }, s[1] && (n.number = parseInt(s[1], 10)), this.trigger("data", n)) : (s = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(t)) ? (n = { type: "tag", tagType: "playlist-type" }, s[1] && (n.playlistType = s[1]), this.trigger("data", n)) : (s = /^#EXT-X-BYTERANGE:(.*)?$/.exec(t)) ? (n = yi(Tr(s[1]), { type: "tag", tagType: "byterange" }), this.trigger("data", n)) : (s = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(t)) ? (n = { type: "tag", tagType: "allow-cache" }, s[1] && (n.allowed = !/NO/.test(s[1])), this.trigger("data", n)) : (s = /^#EXT-X-MAP:(.*)$/.exec(t)) ? (n = { type: "tag", tagType: "map" }, s[1] && ((i = Sr(s[1])).URI && (n.uri = i.URI), i.BYTERANGE) && (n.byterange = Tr(i.BYTERANGE)), this.trigger("data", n)) : (s = /^#EXT-X-STREAM-INF:(.*)$/.exec(t)) ? (n = { type: "tag", tagType: "stream-inf" }, s[1] && (n.attributes = Sr(s[1]), n.attributes.RESOLUTION && (i = {}, (e = n.attributes.RESOLUTION.split("x"))[0] && (i.width = parseInt(e[0], 10)), e[1] && (i.height = parseInt(e[1], 10)), n.attributes.RESOLUTION = i), n.attributes.BANDWIDTH && (n.attributes.BANDWIDTH = parseInt(n.attributes.BANDWIDTH, 10)), n.attributes["FRAME-RATE"] && (n.attributes["FRAME-RATE"] = parseFloat(n.attributes["FRAME-RATE"])), n.attributes["PROGRAM-ID"]) && (n.attributes["PROGRAM-ID"] = parseInt(n.attributes["PROGRAM-ID"], 10)), this.trigger("data", n)) : (s = /^#EXT-X-MEDIA:(.*)$/.exec(t)) ? (n = { type: "tag", tagType: "media" }, s[1] && (n.attributes = Sr(s[1])), this.trigger("data", n)) : (s = /^#EXT-X-ENDLIST/.exec(t)) ? this.trigger("data", { type: "tag", tagType: "endlist" }) : (s = /^#EXT-X-DISCONTINUITY/.exec(t)) ? this.trigger("data", { type: "tag", tagType: "discontinuity" }) : (s = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(t)) ? (n = { type: "tag", tagType: "program-date-time" }, s[1] && (n.dateTimeString = s[1], n.dateTimeObject = new Date(s[1])), this.trigger("data", n)) : (s = /^#EXT-X-KEY:(.*)$/.exec(t)) ? (n = { type: "tag", tagType: "key" }, s[1] && (n.attributes = Sr(s[1]), n.attributes.IV) && ("0x" === n.attributes.IV.substring(0, 2).toLowerCase() && (n.attributes.IV = n.attributes.IV.substring(2)), n.attributes.IV = n.attributes.IV.match(/.{8}/g), n.attributes.IV[0] = parseInt(n.attributes.IV[0], 16), n.attributes.IV[1] = parseInt(n.attributes.IV[1], 16), n.attributes.IV[2] = parseInt(n.attributes.IV[2], 16), n.attributes.IV[3] = parseInt(n.attributes.IV[3], 16), n.attributes.IV = new Uint32Array(n.attributes.IV)), this.trigger("data", n)) : (s = /^#EXT-X-START:(.*)$/.exec(t)) ? (n = { type: "tag", tagType: "start" }, s[1] && (n.attributes = Sr(s[1]), n.attributes["TIME-OFFSET"] = parseFloat(n.attributes["TIME-OFFSET"]), n.attributes.PRECISE = /YES/.test(n.attributes.PRECISE)), this.trigger("data", n)) : (s = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(t)) ? (n = { type: "tag", tagType: "cue-out-cont" }, s[1] ? n.data = s[1] : n.data = "", this.trigger("data", n)) : (s = /^#EXT-X-CUE-OUT:(.*)?$/.exec(t)) ? (n = { type: "tag", tagType: "cue-out" }, s[1] ? n.data = s[1] : n.data = "", this.trigger("data", n)) : (s = /^#EXT-X-CUE-IN:(.*)?$/.exec(t)) ? (n = { type: "tag", tagType: "cue-in" }, s[1] ? n.data = s[1] : n.data = "", this.trigger("data", n)) : (s = /^#EXT-X-SKIP:(.*)$/.exec(t)) && s[1] ? ((n = { type: "tag", tagType: "skip" }).attributes = Sr(s[1]), n.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (n.attributes["SKIPPED-SEGMENTS"] = parseInt(n.attributes["SKIPPED-SEGMENTS"], 10)), n.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (n.attributes["RECENTLY-REMOVED-DATERANGES"] = n.attributes["RECENTLY-REMOVED-DATERANGES"].split(wr)), this.trigger("data", n)) : (s = /^#EXT-X-PART:(.*)$/.exec(t)) && s[1] ? ((n = { type: "tag", tagType: "part" }).attributes = Sr(s[1]), ["DURATION"].forEach(function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) }), ["INDEPENDENT", "GAP"].forEach(function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = /YES/.test(n.attributes[e])) }), n.attributes.hasOwnProperty("BYTERANGE") && (n.attributes.byterange = Tr(n.attributes.BYTERANGE)), this.trigger("data", n)) : (s = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(t)) && s[1] ? ((n = { type: "tag", tagType: "server-control" }).attributes = Sr(s[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) }), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = /YES/.test(n.attributes[e])) }), this.trigger("data", n)) : (s = /^#EXT-X-PART-INF:(.*)$/.exec(t)) && s[1] ? ((n = { type: "tag", tagType: "part-inf" }).attributes = Sr(s[1]), ["PART-TARGET"].forEach(function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) }), this.trigger("data", n)) : (s = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(t)) && s[1] ? ((n = { type: "tag", tagType: "preload-hint" }).attributes = Sr(s[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function (e) { var t; n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseInt(n.attributes[e], 10), t = "BYTERANGE-LENGTH" === e ? "length" : "offset", n.attributes.byterange = n.attributes.byterange || {}, n.attributes.byterange[t] = n.attributes[e], delete n.attributes[e]) }), this.trigger("data", n)) : (s = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(t)) && s[1] ? ((n = { type: "tag", tagType: "rendition-report" }).attributes = Sr(s[1]), ["LAST-MSN", "LAST-PART"].forEach(function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseInt(n.attributes[e], 10)) }), this.trigger("data", n)) : this.trigger("data", { type: "tag", data: t.slice(4) })) })) } addParser({ expression: t, customType: i, dataParser: s, segment: n }) { "function" != typeof s && (s = e => e), this.customParsers.push(e => { if (t.exec(e)) return this.trigger("data", { type: "custom", data: s(e), customType: i, segment: n }), !0 }) } addTagMapper({ expression: t, map: i }) { this.tagMappers.push(e => t.test(e) ? i(e) : e) } } function Cr(t) { const i = {}; return Object.keys(t).forEach(function (e) { i[e.toLowerCase().replace(/-(\w)/g, e => e[1].toUpperCase())] = t[e] }), i } function kr(e) { var t, i, s, n, r, { serverControl: e, targetDuration: a, partTargetDuration: o } = e; e && (t = "#EXT-X-SERVER-CONTROL", i = "holdBack", s = "partHoldBack", n = a && 3 * a, r = o && 2 * o, a && !e.hasOwnProperty(i) && (e[i] = n, this.trigger("info", { message: t + ` defaulting HOLD-BACK to targetDuration * 3 (${n}).` })), n && e[i] < n && (this.trigger("warn", { message: t + ` clamping HOLD-BACK (${e[i]}) to targetDuration * 3 (${n})` }), e[i] = n), o && !e.hasOwnProperty(s) && (e[s] = 3 * o, this.trigger("info", { message: t + ` defaulting PART-HOLD-BACK to partTargetDuration * 3 (${e[s]}).` })), o) && e[s] < r && (this.trigger("warn", { message: t + ` clamping PART-HOLD-BACK (${e[s]}) to partTargetDuration * 2 (${r}).` }), e[s] = r) } class Ir extends Mn { constructor() { super(), this.lineStream = new br, this.parseStream = new Er, this.lineStream.pipe(this.parseStream); const e = this, s = []; let a = {}, n, o, l = !1; const d = { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }; let h = 0, u = (this.manifest = { allowCache: !0, discontinuityStarts: [], segments: [] }, 0), c = 0; this.on("end", () => { a.uri || !a.parts && !a.preloadHints || (!a.map && n && (a.map = n), !a.key && o && (a.key = o), a.timeline || "number" != typeof h || (a.timeline = h), this.manifest.preloadSegment = a) }), this.parseStream.on("data", function (r) { let t, i; ({ tag() { ({ version() { r.version && (this.manifest.version = r.version) }, "allow-cache"() { this.manifest.allowCache = r.allowed, "allowed" in r || (this.trigger("info", { message: "defaulting allowCache to YES" }), this.manifest.allowCache = !0) }, byterange() { var e = {}; "length" in r && ((a.byterange = e).length = r.length, "offset" in r || (r.offset = u)), "offset" in r && ((a.byterange = e).offset = r.offset), u = e.offset + e.length }, endlist() { this.manifest.endList = !0 }, inf() { "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", { message: "defaulting media sequence to zero" })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", { message: "defaulting discontinuity sequence to zero" })), 0 < r.duration && (a.duration = r.duration), 0 === r.duration && (a.duration = .01, this.trigger("info", { message: "updating zero segment duration to a small value" })), this.manifest.segments = s }, key() { if (r.attributes) if ("NONE" === r.attributes.METHOD) o = null; else if (r.attributes.URI) if ("com.apple.streamingkeydelivery" === r.attributes.KEYFORMAT) this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.apple.fps.1_0"] = { attributes: r.attributes }; else if ("com.microsoft.playready" === r.attributes.KEYFORMAT) this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.microsoft.playready"] = { uri: r.attributes.URI }; else { if ("urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" === r.attributes.KEYFORMAT) return -1 === ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(r.attributes.METHOD) ? void this.trigger("warn", { message: "invalid key method provided for Widevine" }) : ("SAMPLE-AES-CENC" === r.attributes.METHOD && this.trigger("warn", { message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead" }), "data:text/plain;base64," !== r.attributes.URI.substring(0, 23) ? void this.trigger("warn", { message: "invalid key URI provided for Widevine" }) : r.attributes.KEYID && "0x" === r.attributes.KEYID.substring(0, 2) ? (this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.widevine.alpha"] = { attributes: { schemeIdUri: r.attributes.KEYFORMAT, keyId: r.attributes.KEYID.substring(2) }, pssh: vr(r.attributes.URI.split(",")[1]) })) : void this.trigger("warn", { message: "invalid key ID provided for Widevine" })); r.attributes.METHOD || this.trigger("warn", { message: "defaulting key method to AES-128" }), o = { method: r.attributes.METHOD || "AES-128", uri: r.attributes.URI }, "undefined" != typeof r.attributes.IV && (o.iv = r.attributes.IV) } else this.trigger("warn", { message: "ignoring key declaration without URI" }); else this.trigger("warn", { message: "ignoring key declaration without attribute list" }) }, "media-sequence"() { isFinite(r.number) ? this.manifest.mediaSequence = r.number : this.trigger("warn", { message: "ignoring invalid media sequence: " + r.number }) }, "discontinuity-sequence"() { isFinite(r.number) ? (this.manifest.discontinuitySequence = r.number, h = r.number) : this.trigger("warn", { message: "ignoring invalid discontinuity sequence: " + r.number }) }, "playlist-type"() { /VOD|EVENT/.test(r.playlistType) ? this.manifest.playlistType = r.playlistType : this.trigger("warn", { message: "ignoring unknown playlist type: " + r.playlist }) }, map() { n = {}, r.uri && (n.uri = r.uri), r.byterange && (n.byterange = r.byterange), o && (n.key = o) }, "stream-inf"() { this.manifest.playlists = s, this.manifest.mediaGroups = this.manifest.mediaGroups || d, r.attributes ? (a.attributes || (a.attributes = {}), yi(a.attributes, r.attributes)) : this.trigger("warn", { message: "ignoring empty stream-inf attributes" }) }, media() { var e; this.manifest.mediaGroups = this.manifest.mediaGroups || d, r.attributes && r.attributes.TYPE && r.attributes["GROUP-ID"] && r.attributes.NAME ? ((e = this.manifest.mediaGroups[r.attributes.TYPE])[r.attributes["GROUP-ID"]] = e[r.attributes["GROUP-ID"]] || {}, t = e[r.attributes["GROUP-ID"]], (i = { default: /yes/i.test(r.attributes.DEFAULT) }).default ? i.autoselect = !0 : i.autoselect = /yes/i.test(r.attributes.AUTOSELECT), r.attributes.LANGUAGE && (i.language = r.attributes.LANGUAGE), r.attributes.URI && (i.uri = r.attributes.URI), r.attributes["INSTREAM-ID"] && (i.instreamId = r.attributes["INSTREAM-ID"]), r.attributes.CHARACTERISTICS && (i.characteristics = r.attributes.CHARACTERISTICS), r.attributes.FORCED && (i.forced = /yes/i.test(r.attributes.FORCED)), t[r.attributes.NAME] = i) : this.trigger("warn", { message: "ignoring incomplete or missing media group" }) }, discontinuity() { h += 1, a.discontinuity = !0, this.manifest.discontinuityStarts.push(s.length) }, "program-date-time"() { "undefined" == typeof this.manifest.dateTimeString && (this.manifest.dateTimeString = r.dateTimeString, this.manifest.dateTimeObject = r.dateTimeObject), a.dateTimeString = r.dateTimeString, a.dateTimeObject = r.dateTimeObject }, targetduration() { !isFinite(r.duration) || r.duration < 0 ? this.trigger("warn", { message: "ignoring invalid target duration: " + r.duration }) : (this.manifest.targetDuration = r.duration, kr.call(this, this.manifest)) }, start() { !r.attributes || isNaN(r.attributes["TIME-OFFSET"]) ? this.trigger("warn", { message: "ignoring start declaration without appropriate attribute list" }) : this.manifest.start = { timeOffset: r.attributes["TIME-OFFSET"], precise: r.attributes.PRECISE } }, "cue-out"() { a.cueOut = r.data }, "cue-out-cont"() { a.cueOutCont = r.data }, "cue-in"() { a.cueIn = r.data }, skip() { this.manifest.skip = Cr(r.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", r.attributes, ["SKIPPED-SEGMENTS"]) }, part() { l = !0; var e = this.manifest.segments.length, t = Cr(r.attributes), t = (a.parts = a.parts || [], a.parts.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = c), c = t.byterange.offset + t.byterange.length), a.parts.length - 1); this.warnOnMissingAttributes_(`#EXT-X-PART #${t} for segment #` + e, r.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach((e, t) => { e.hasOwnProperty("lastPart") || this.trigger("warn", { message: `#EXT-X-RENDITION-REPORT #${t} lacks required attribute(s): LAST-PART` }) }) }, "server-control"() { var e = this.manifest.serverControl = Cr(r.attributes); e.hasOwnProperty("canBlockReload") || (e.canBlockReload = !1, this.trigger("info", { message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false" })), kr.call(this, this.manifest), e.canSkipDateranges && !e.hasOwnProperty("canSkipUntil") && this.trigger("warn", { message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set" }) }, "preload-hint"() { var t = this.manifest.segments.length, i = Cr(r.attributes), e = i.type && "PART" === i.type, s = (a.preloadHints = a.preloadHints || [], a.preloadHints.push(i), !i.byterange || i.byterange.hasOwnProperty("offset") || (i.byterange.offset = e ? c : 0, e && (c = i.byterange.offset + i.byterange.length)), a.preloadHints.length - 1); if (this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${s} for segment #` + t, r.attributes, ["TYPE", "URI"]), i.type) for (let e = 0; e < a.preloadHints.length - 1; e++) { var n = a.preloadHints[e]; n.type && n.type === i.type && this.trigger("warn", { message: `#EXT-X-PRELOAD-HINT #${s} for segment #${t} has the same TYPE ${i.type} as preload hint #` + e }) } }, "rendition-report"() { var e = Cr(r.attributes), e = (this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(e), this.manifest.renditionReports.length - 1), t = ["LAST-MSN", "URI"]; l && t.push("LAST-PART"), this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + e, r.attributes, t) }, "part-inf"() { this.manifest.partInf = Cr(r.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", r.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), kr.call(this, this.manifest) } }[r.tagType] || function () { }).call(e) }, uri() { a.uri = r.uri, s.push(a), !this.manifest.targetDuration || "duration" in a || (this.trigger("warn", { message: "defaulting segment duration to the target duration" }), a.duration = this.manifest.targetDuration), o && (a.key = o), a.timeline = h, n && (a.map = n), c = 0, a = {} }, comment() { }, custom() { r.segment ? (a.custom = a.custom || {}, a.custom[r.customType] = r.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[r.customType] = r.data) } })[r.type].call(e) }) } warnOnMissingAttributes_(e, t, i) { const s = []; i.forEach(function (e) { t.hasOwnProperty(e) || s.push(e) }), s.length && this.trigger("warn", { message: e + " lacks required attribute(s): " + s.join(", ") }) } push(e) { this.lineStream.push(e) } end() { this.lineStream.push("\n"), this.trigger("end") } addParser(e) { this.parseStream.addParser(e) } addTagMapper(e) { this.parseStream.addTagMapper(e) } } function xr(e) { return Nr.audio.test((e = void 0 === e ? "" : e).trim().toLowerCase()) } function Ar(e) { return void 0 === e && (e = ""), window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(jr(e)) || !1 } function Lr(e) { return (e = void 0 === e ? "" : e).toLowerCase().split(",").every(function (e) { e = e.trim(); for (var t = 0; t < Ur.length; t++) { var i = Ur[t]; if (Nr["muxer" + i].test(e)) return !0 } return !1 }) } function Pr(e) { return Vr.test(e) ? "hls" : qr.test(e) ? "dash" : "application/vnd.tm_videojs.vhs+json" === e ? "vhs-json" : null } function Dr(e, t) { for (var i = void 0 !== (t = (void 0 === t ? {} : t).le) && t, s = (e = w(e = "bigint" != typeof e && "number" != typeof e || "number" == typeof e && e != e ? 0 : e), t = e, Math.ceil(t.toString(2).length / 8)), n = new Uint8Array(new ArrayBuffer(s)), r = 0; r < s; r++) { var a = i ? r : Math.abs(r + 1 - n.length); n[a] = Number(e / $r[r] & w(255)), e < 0 && (n[a] = Math.abs(~n[a]), n[a] -= 0 === r ? 1 : 2) } return n } function Or(e, t) { if ("string" != typeof (e = "string" != typeof e && e && "function" == typeof e.toString ? e.toString() : e)) return new Uint8Array; t || (e = unescape(encodeURIComponent(e))); for (var i = new Uint8Array(e.length), s = 0; s < e.length; s++)i[s] = e.charCodeAt(s); return i } function Mr(e, t) { if (/^[a-z]+:/i.test(t)) return t; /^data:/.test(e) && (e = window.location && window.location.href || ""); var i = "function" == typeof window.URL, s = /^\/\//.test(e), n = !window.location && !/\/\//i.test(e); return i ? e = new window.URL(e, window.location || Gr) : /\/\//i.test(e) || (e = yr.buildAbsoluteURL(window.location && window.location.href || "", e)), i ? (i = new URL(t, e), n ? i.href.slice(Gr.length) : s ? i.href.slice(i.protocol.length) : i.href) : yr.buildAbsoluteURL(e, t) } var Nr = { mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/, webm: /^(vp0?[89]|av0?1|opus|vorbis)/, ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/, video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/, audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/, text: /^(stpp.ttml.im1t)/, muxerVideo: /^(avc0?1)/, muxerAudio: /^(mp4a)/, muxerText: /a^/ }, Rr = ["video", "audio", "text"], Ur = ["Video", "Audio", "Text"], Br = function (e) { return e && e.replace(/avc1\.(\d+)\.(\d+)/i, function (e, t, i) { return "avc1." + ("00" + Number(t).toString(16)).slice(-2) + "00" + ("00" + Number(i).toString(16)).slice(-2) }) }, Fr = function (e) { var e = (e = void 0 === e ? "" : e).split(","), r = []; return e.forEach(function (s) { var n; s = s.trim(), Rr.forEach(function (e) { var t, i = Nr[e].exec(s.toLowerCase()); !i || i.length <= 1 || (n = e, i = s.substring(0, i[1].length), t = s.replace(i, ""), r.push({ type: i, details: t, mediaType: e })) }), n || r.push({ type: s, details: "", mediaType: "unknown" }) }), r }, jr = function (e) { var t, i, s; if (e && "string" == typeof e) return i = "video", 1 === (t = e.toLowerCase().split(",").map(function (e) { return Br(e.trim()) })).length && xr(t[0]) ? i = "audio" : 1 === t.length && (s = t[0], Nr.text.test((s = void 0 === s ? "" : s).trim().toLowerCase())) && (i = "application"), s = "mp4", t.every(function (e) { return Nr.mp4.test(e) }) ? s = "mp4" : t.every(function (e) { return Nr.webm.test(e) }) ? s = "webm" : t.every(function (e) { return Nr.ogg.test(e) }) && (s = "ogg"), i + "/" + s + ';codecs="' + e + '"' }, Hr = "mp4a.40.2", Vr = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, qr = /^application\/dash\+xml/i, zr = function (e) { return "function" === ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer }, S = function (e) { return e instanceof Uint8Array ? e : (Array.isArray(e) || zr(e) || e instanceof ArrayBuffer || (e = "number" != typeof e || "number" == typeof e && e != e ? 0 : [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0)) }, w = window.BigInt || Number, $r = [w("0x1"), w("0x100"), w("0x10000"), w("0x1000000"), w("0x100000000"), w("0x10000000000"), w("0x1000000000000"), w("0x100000000000000"), w("0x10000000000000000")], Wr = (Ot = new Uint16Array([65484]), 255 !== (Ot = new Uint8Array(Ot.buffer, Ot.byteOffset, Ot.byteLength))[0] && Ot[0], function (s, e) { var e = void 0 === e ? {} : e, t = e.signed, t = void 0 !== t && t, e = e.le, n = void 0 !== e && e, e = (s = S(s), n ? "reduce" : "reduceRight"), e = (s[e] || Array.prototype[e]).call(s, function (e, t, i) { i = n ? i : Math.abs(i + 1 - s.length); return e + w(t) * $r[i] }, w(0)); return t && (t = $r[s.length] / w(2) - w(1)) < (e = w(e)) && (e = (e = e - t - t) - w(2)), Number(e) }), E = function (i, e, t) { var t = void 0 === t ? {} : t, s = t.offset, n = void 0 === s ? 0 : s, s = t.mask, r = void 0 === s ? [] : s, t = (i = S(i), (e = S(e)).every || Array.prototype.every); return e.length && i.length - n >= e.length && t.call(e, function (e, t) { return e === (r[t] ? r[t] & i[n + t] : i[n + t]) }) }, Gr = "http://example.com"; function Xr(e) { e = e; for (var t = window.atob ? window.atob(e) : Buffer.from(e, "base64").toString("binary"), i = new Uint8Array(t.length), s = 0; s < t.length; s++)i[s] = t.charCodeAt(s); return i } function Kr(e, t) { return (t = void 0 === t ? Object : t) && "function" == typeof t.freeze ? t.freeze(e) : e } var Yr = Kr({ HTML: "text/html", isHTML: function (e) { return e === Yr.HTML }, XML_APPLICATION: "application/xml", XML_TEXT: "text/xml", XML_XHTML_APPLICATION: "application/xhtml+xml", XML_SVG_IMAGE: "image/svg+xml" }), Qr = Kr({ HTML: "http://www.w3.org/1999/xhtml", isHTML: function (e) { return e === Qr.HTML }, SVG: "http://www.w3.org/2000/svg", XML: "http://www.w3.org/XML/1998/namespace", XMLNS: "http://www.w3.org/2000/xmlns/" }), Jr = { assign: function (e, t) { if (null === e || "object" != typeof e) throw new TypeError("target is not an object"); for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, find: function (e, t, i) { if (void 0 === i && (i = Array.prototype), e && "function" == typeof i.find) return i.find.call(e, t); for (var s = 0; s < e.length; s++)if (Object.prototype.hasOwnProperty.call(e, s)) { var n = e[s]; if (t.call(void 0, n, s, e)) return n } }, freeze: Kr, MIME_TYPE: Yr, NAMESPACE: Qr }, Zr = Jr.find, ea = Jr.NAMESPACE; function ta(e) { return "" !== e } function ia(e, t) { return e.hasOwnProperty(t) || (e[t] = !0), e } function sa(e) { return e ? (e = (e = e) ? e.split(/[\t\n\f\r ]+/).filter(ta) : [], Object.keys(e.reduce(ia, {}))) : [] } function na(e, t) { for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]) } function ra(e, t) { var i = e.prototype; function s() { } i instanceof t || (s.prototype = t.prototype, na(i, s = new s), e.prototype = i = s), i.constructor != e && (i.constructor = e) } var r = {}, t = (r.ELEMENT_NODE = 1, r.ATTRIBUTE_NODE = 2, r.TEXT_NODE = 3, r.CDATA_SECTION_NODE = 4, r.ENTITY_REFERENCE_NODE = 5, r.ENTITY_NODE = 6, r.PROCESSING_INSTRUCTION_NODE = 7, r.COMMENT_NODE = 8, r.DOCUMENT_NODE = 9, r.DOCUMENT_TYPE_NODE = 10, r.DOCUMENT_FRAGMENT_NODE = 11, r.NOTATION_NODE = 12, {}), C = {}, aa = (t.INDEX_SIZE_ERR = (C[1] = "Index size error", 1), t.DOMSTRING_SIZE_ERR = (C[2] = "DOMString size error", 2), t.HIERARCHY_REQUEST_ERR = (C[3] = "Hierarchy request error", 3)), oa = (t.WRONG_DOCUMENT_ERR = (C[4] = "Wrong document", 4), t.INVALID_CHARACTER_ERR = (C[5] = "Invalid character", 5), t.NO_DATA_ALLOWED_ERR = (C[6] = "No data allowed", 6), t.NO_MODIFICATION_ALLOWED_ERR = (C[7] = "No modification allowed", 7), t.NOT_FOUND_ERR = (C[8] = "Not found", 8)); t.NOT_SUPPORTED_ERR = (C[9] = "Not supported", 9), t.INUSE_ATTRIBUTE_ERR = (C[10] = "Attribute in use", 10); function k(e, t) { var i; return t instanceof Error ? i = t : (i = this, Error.call(this, C[e]), this.message = C[e], Error.captureStackTrace && Error.captureStackTrace(this, k)), i.code = e, t && (this.message = this.message + ": " + t), i } function la() { } function da(e, t) { this._node = e, this._refresh = t, ha(this) } function ha(e) { var t, i = e._node._inc || e._node.ownerDocument._inc; e._inc != i && (t = e._refresh(e._node), Xa(e, "length", t.length), na(t, e), e._inc = i) } function ua() { } function ca(e, t) { for (var i = e.length; i--;)if (e[i] === t) return i } function pa(e, t, i, s) { s ? t[ca(t, s)] = i : t[t.length++] = i, e && (t = (i.ownerElement = e).ownerDocument) && (s && va(t, e, s), s = e, e = i, (i = t) && i._inc++, e.namespaceURI === ea.XMLNS) && (s._nsMap[e.prefix ? e.localName : ""] = e.value) } function ma(e, t, i) { var s = ca(t, i); if (!(0 <= s)) throw new k(oa, new Error(e.tagName + "@" + i)); for (var n, r = t.length - 1; s < r;)t[s] = t[++s]; t.length = r, e && (n = e.ownerDocument) && (va(n, e, i), i.ownerElement = null) } function ga() { } function I() { } function fa(e) { return ("<" == e ? "&lt;" : ">" == e && "&gt;") || ("&" == e ? "&amp;" : '"' == e && "&quot;") || "&#" + e.charCodeAt() + ";" } function ya(e, t) { if (t(e)) return 1; if (e = e.firstChild) do { if (ya(e, t)) return 1 } while (e = e.nextSibling) } function _a() { this.ownerDocument = this } function va(e, t, i) { e && e._inc++, i.namespaceURI === ea.XMLNS && delete t._nsMap[i.prefix ? i.localName : ""] } function ba(e, t, i) { if (e && e._inc) { e._inc++; var s = t.childNodes; if (i) s[s.length++] = i; else { for (var n = t.firstChild, r = 0; n;)n = (s[r++] = n).nextSibling; s.length = r, delete s[s.length] } } } function Ta(e, t) { var i = t.previousSibling, s = t.nextSibling; return i ? i.nextSibling = s : e.firstChild = s, s ? s.previousSibling = i : e.lastChild = i, t.parentNode = null, t.previousSibling = null, t.nextSibling = null, ba(e.ownerDocument, e), t } function Sa(e) { return e && e.nodeType === I.DOCUMENT_TYPE_NODE } function wa(e) { return e && e.nodeType === I.ELEMENT_NODE } function Ea(e) { return e && e.nodeType === I.TEXT_NODE } function Ca(e, t) { var i, e = e.childNodes || []; if (!Zr(e, wa) && !Sa(t)) return i = Zr(e, Sa), !(t && i && e.indexOf(i) > e.indexOf(t)) } function ka(e, t) { var i, e = e.childNodes || []; if (!Zr(e, function (e) { return wa(e) && e !== t })) return i = Zr(e, Sa), !(t && i && e.indexOf(i) > e.indexOf(t)) } function Ia(e, t, i) { if (!(s = e) || s.nodeType !== I.DOCUMENT_NODE && s.nodeType !== I.DOCUMENT_FRAGMENT_NODE && s.nodeType !== I.ELEMENT_NODE) throw new k(aa, "Unexpected parent node type " + e.nodeType); var s; if (i && i.parentNode !== e) throw new k(oa, "child not in parent"); if (!(s = t) || !(wa(s) || Ea(s) || Sa(s) || s.nodeType === I.DOCUMENT_FRAGMENT_NODE || s.nodeType === I.COMMENT_NODE || s.nodeType === I.PROCESSING_INSTRUCTION_NODE) || Sa(t) && e.nodeType !== I.DOCUMENT_NODE) throw new k(aa, "Unexpected node type " + t.nodeType + " for parent node type " + e.nodeType) } function xa(e, t, i) { var s = e.childNodes || [], n = t.childNodes || []; if (t.nodeType === I.DOCUMENT_FRAGMENT_NODE) { var r = n.filter(wa); if (1 < r.length || Zr(n, Ea)) throw new k(aa, "More than one element or text in fragment"); if (1 === r.length && !Ca(e, i)) throw new k(aa, "Element in fragment can not be inserted before doctype") } if (wa(t) && !Ca(e, i)) throw new k(aa, "Only one element can be added and only after doctype"); if (Sa(t)) { if (Zr(s, Sa)) throw new k(aa, "Only one doctype is allowed"); n = Zr(s, wa); if (i && s.indexOf(n) < s.indexOf(i)) throw new k(aa, "Doctype can only be inserted before an element"); if (!i && n) throw new k(aa, "Doctype can not be appended since element is present") } } function Aa(e, t, i) { var s = e.childNodes || [], n = t.childNodes || []; if (t.nodeType === I.DOCUMENT_FRAGMENT_NODE) { var r = n.filter(wa); if (1 < r.length || Zr(n, Ea)) throw new k(aa, "More than one element or text in fragment"); if (1 === r.length && !ka(e, i)) throw new k(aa, "Element in fragment can not be inserted before doctype") } if (wa(t) && !ka(e, i)) throw new k(aa, "Only one element can be added and only after doctype"); if (Sa(t)) { if (Zr(s, function (e) { return Sa(e) && e !== i })) throw new k(aa, "Only one doctype is allowed"); n = Zr(s, wa); if (i && s.indexOf(n) < s.indexOf(i)) throw new k(aa, "Doctype can only be inserted before an element") } } function La(e, t, i, s) { Ia(e, t, i), e.nodeType === I.DOCUMENT_NODE && (s || xa)(e, t, i); s = t.parentNode; if (s && s.removeChild(t), 11 === t.nodeType) { var n = t.firstChild; if (null == n) return t; var r = t.lastChild } else n = r = t; s = i ? i.previousSibling : e.lastChild; for (n.previousSibling = s, r.nextSibling = i, s ? s.nextSibling = n : e.firstChild = n, null == i ? e.lastChild = r : i.previousSibling = r; n.parentNode = e, n !== r && (n = n.nextSibling);); return ba(e.ownerDocument || e, e), 11 == t.nodeType && (t.firstChild = t.lastChild = null), t } function Pa() { this._nsMap = {} } function Da() { } function Oa() { } function Ma() { } function Na() { } function Ra() { } function Ua() { } function Ba() { } function Fa() { } function ja() { } function Ha() { } function Va() { } function qa() { } function za(e, t) { var i, s = [], n = 9 == this.nodeType && this.documentElement || this, r = n.prefix, a = n.namespaceURI; return Ga(this, s, e, t, i = a && null == r && null == n.lookupPrefix(a) ? [{ namespace: a, prefix: null }] : i), s.join("") } function $a(e, t, i) { var s = e.prefix || "", n = e.namespaceURI; if (n && ("xml" !== s || n !== ea.XML) && n !== ea.XMLNS) { for (var r = i.length; r--;) { var a = i[r]; if (a.prefix === s) return a.namespace !== n } return 1 } } function Wa(e, t, i) { e.push(" ", t, '="', i.replace(/[<>&"\t\n\r]/g, fa), '"') } function Ga(e, t, i, s, n) { if (n = n || [], s) { if (!(e = s(e))) return; if ("string" == typeof e) return void t.push(e) } switch (e.nodeType) { case 1: var r = e.attributes, a = r.length, o = e.firstChild, l = e.tagName, d = l; if (!(i = ea.isHTML(e.namespaceURI) || i) && !e.prefix && e.namespaceURI) { for (var h, u = 0; u < r.length; u++)if ("xmlns" === r.item(u).name) { h = r.item(u).value; break } if (!h) for (var c = n.length - 1; 0 <= c; c--)if ("" === (p = n[c]).prefix && p.namespace === e.namespaceURI) { h = p.namespace; break } if (h !== e.namespaceURI) for (var p, c = n.length - 1; 0 <= c; c--)if ((p = n[c]).namespace === e.namespaceURI) { p.prefix && (d = p.prefix + ":" + l); break } } t.push("<", d); for (var m = 0; m < a; m++)"xmlns" == (g = r.item(m)).prefix ? n.push({ prefix: g.localName, namespace: g.value }) : "xmlns" == g.nodeName && n.push({ prefix: "", namespace: g.value }); for (var g, f, y, m = 0; m < a; m++)$a(g = r.item(m), 0, n) && (Wa(t, (f = g.prefix || "") ? "xmlns:" + f : "xmlns", y = g.namespaceURI), n.push({ prefix: f, namespace: y })), Ga(g, t, i, s, n); if (l === d && $a(e, 0, n) && (Wa(t, (f = e.prefix || "") ? "xmlns:" + f : "xmlns", y = e.namespaceURI), n.push({ prefix: f, namespace: y })), o || i && !/^(?:meta|link|img|br|hr|input)$/i.test(l)) { if (t.push(">"), i && /^script$/i.test(l)) for (; o;)o.data ? t.push(o.data) : Ga(o, t, i, s, n.slice()), o = o.nextSibling; else for (; o;)Ga(o, t, i, s, n.slice()), o = o.nextSibling; t.push("</", d, ">") } else t.push("/>"); return; case 9: case 11: for (o = e.firstChild; o;)Ga(o, t, i, s, n.slice()), o = o.nextSibling; return; case 2: return Wa(t, e.name, e.value); case 3: return t.push(e.data.replace(/[<&>]/g, fa)); case 4: return t.push("<![CDATA[", e.data, "]]>"); case 8: return t.push("\x3c!--", e.data, "--\x3e"); case 10: var _ = e.publicId, v = e.systemId; return t.push("<!DOCTYPE ", e.name), void (_ ? (t.push(" PUBLIC ", _), v && "." != v && t.push(" ", v), t.push(">")) : v && "." != v ? t.push(" SYSTEM ", v, ">") : ((_ = e.internalSubset) && t.push(" [", _, "]"), t.push(">"))); case 7: return t.push("<?", e.target, " ", e.data, "?>"); case 5: return t.push("&", e.nodeName, ";"); default: t.push("??", e.nodeName) } } function Xa(e, t, i) { e[t] = i } t.INVALID_STATE_ERR = (C[11] = "Invalid state", 11), t.SYNTAX_ERR = (C[12] = "Syntax error", 12), t.INVALID_MODIFICATION_ERR = (C[13] = "Invalid modification", 13), t.NAMESPACE_ERR = (C[14] = "Invalid namespace", 14), t.INVALID_ACCESS_ERR = (C[15] = "Invalid access", 15), k.prototype = Error.prototype, na(t, k), la.prototype = { length: 0, item: function (e) { return this[e] || null }, toString: function (e, t) { for (var i = [], s = 0; s < this.length; s++)Ga(this[s], i, e, t); return i.join("") }, filter: function (e) { return Array.prototype.filter.call(this, e) }, indexOf: function (e) { return Array.prototype.indexOf.call(this, e) } }, da.prototype.item = function (e) { return ha(this), this[e] }, ra(da, la), ua.prototype = { length: 0, item: la.prototype.item, getNamedItem: function (e) { for (var t = this.length; t--;) { var i = this[t]; if (i.nodeName == e) return i } }, setNamedItem: function (e) { var t = e.ownerElement; if (t && t != this._ownerElement) throw new k(10); t = this.getNamedItem(e.nodeName); return pa(this._ownerElement, this, e, t), t }, setNamedItemNS: function (e) { var t = e.ownerElement; if (t && t != this._ownerElement) throw new k(10); return t = this.getNamedItemNS(e.namespaceURI, e.localName), pa(this._ownerElement, this, e, t), t }, removeNamedItem: function (e) { e = this.getNamedItem(e); return ma(this._ownerElement, this, e), e }, removeNamedItemNS: function (e, t) { e = this.getNamedItemNS(e, t); return ma(this._ownerElement, this, e), e }, getNamedItemNS: function (e, t) { for (var i = this.length; i--;) { var s = this[i]; if (s.localName == t && s.namespaceURI == e) return s } return null } }, ga.prototype = { hasFeature: function (e, t) { return !0 }, createDocument: function (e, t, i) { var s = new _a; return s.implementation = this, s.childNodes = new la, s.doctype = i || null, i && s.appendChild(i), t && (i = s.createElementNS(e, t), s.appendChild(i)), s }, createDocumentType: function (e, t, i) { var s = new Ua; return s.name = e, s.nodeName = e, s.publicId = t || "", s.systemId = i || "", s } }, I.prototype = { firstChild: null, lastChild: null, previousSibling: null, nextSibling: null, attributes: null, parentNode: null, childNodes: null, ownerDocument: null, nodeValue: null, namespaceURI: null, prefix: null, localName: null, insertBefore: function (e, t) { return La(this, e, t) }, replaceChild: function (e, t) { La(this, e, t, Aa), t && this.removeChild(t) }, removeChild: function (e) { return Ta(this, e) }, appendChild: function (e) { return this.insertBefore(e, null) }, hasChildNodes: function () { return null != this.firstChild }, cloneNode: function (e) { return function e(t, i, s) { var n = new i.constructor; for (var r in i) { var a; Object.prototype.hasOwnProperty.call(i, r) && "object" != typeof (a = i[r]) && a != n[r] && (n[r] = a) } i.childNodes && (n.childNodes = new la); n.ownerDocument = t; switch (n.nodeType) { case 1: var o = i.attributes, l = n.attributes = new ua, d = o.length; l._ownerElement = n; for (var h = 0; h < d; h++)n.setAttributeNode(e(t, o.item(h), !0)); break; case 2: s = !0 }if (s) for (var u = i.firstChild; u;)n.appendChild(e(t, u, s)), u = u.nextSibling; return n }(this.ownerDocument || this, this, e) }, normalize: function () { for (var e = this.firstChild; e;) { var t = e.nextSibling; t && 3 == t.nodeType && 3 == e.nodeType ? (this.removeChild(t), e.appendData(t.data)) : (e.normalize(), e = t) } }, isSupported: function (e, t) { return this.ownerDocument.implementation.hasFeature(e, t) }, hasAttributes: function () { return 0 < this.attributes.length }, lookupPrefix: function (e) { for (var t = this; t;) { var i = t._nsMap; if (i) for (var s in i) if (Object.prototype.hasOwnProperty.call(i, s) && i[s] === e) return s; t = 2 == t.nodeType ? t.ownerDocument : t.parentNode } return null }, lookupNamespaceURI: function (e) { for (var t = this; t;) { var i = t._nsMap; if (i && Object.prototype.hasOwnProperty.call(i, e)) return i[e]; t = 2 == t.nodeType ? t.ownerDocument : t.parentNode } return null }, isDefaultNamespace: function (e) { return null == this.lookupPrefix(e) } }, na(r, I), na(r, I.prototype), _a.prototype = { nodeName: "#document", nodeType: 9, doctype: null, documentElement: null, _inc: 1, insertBefore: function (e, t) { if (11 == e.nodeType) for (var i = e.firstChild; i;) { var s = i.nextSibling; this.insertBefore(i, t), i = s } else La(this, e, t), null === (e.ownerDocument = this).documentElement && 1 === e.nodeType && (this.documentElement = e); return e }, removeChild: function (e) { return this.documentElement == e && (this.documentElement = null), Ta(this, e) }, replaceChild: function (e, t) { La(this, e, t, Aa), e.ownerDocument = this, t && this.removeChild(t), wa(e) && (this.documentElement = e) }, importNode: function (e, t) { return function e(t, i, s) { var n; switch (i.nodeType) { case 1: (n = i.cloneNode(!1)).ownerDocument = t; case 11: break; case 2: s = !0 }n = n || i.cloneNode(!1); n.ownerDocument = t; n.parentNode = null; if (s) for (var r = i.firstChild; r;)n.appendChild(e(t, r, s)), r = r.nextSibling; return n }(this, e, t) }, getElementById: function (t) { var i = null; return ya(this.documentElement, function (e) { if (1 == e.nodeType && e.getAttribute("id") == t) return i = e, !0 }), i }, getElementsByClassName: function (a) { var o = sa(a); return new da(this, function (n) { var r = []; return 0 < o.length && ya(n.documentElement, function (e) { var t, i, s; e !== n && 1 === e.nodeType && (t = e.getAttribute("class")) && ((i = a === t) || (t = sa(t), i = o.every((s = t, function (e) { return s && -1 !== s.indexOf(e) }))), i) && r.push(e) }), r }) }, createElement: function (e) { var t = new Pa; return t.ownerDocument = this, t.nodeName = e, t.tagName = e, t.localName = e, t.childNodes = new la, (t.attributes = new ua)._ownerElement = t }, createDocumentFragment: function () { var e = new Ha; return e.ownerDocument = this, e.childNodes = new la, e }, createTextNode: function (e) { var t = new Ma; return t.ownerDocument = this, t.appendData(e), t }, createComment: function (e) { var t = new Na; return t.ownerDocument = this, t.appendData(e), t }, createCDATASection: function (e) { var t = new Ra; return t.ownerDocument = this, t.appendData(e), t }, createProcessingInstruction: function (e, t) { var i = new Va; return i.ownerDocument = this, i.tagName = i.target = e, i.nodeValue = i.data = t, i }, createAttribute: function (e) { var t = new Da; return t.ownerDocument = this, t.name = e, t.nodeName = e, t.localName = e, t.specified = !0, t }, createEntityReference: function (e) { var t = new ja; return t.ownerDocument = this, t.nodeName = e, t }, createElementNS: function (e, t) { var i = new Pa, s = t.split(":"), n = i.attributes = new ua; return i.childNodes = new la, i.ownerDocument = this, i.nodeName = t, i.tagName = t, i.namespaceURI = e, 2 == s.length ? (i.prefix = s[0], i.localName = s[1]) : i.localName = t, n._ownerElement = i }, createAttributeNS: function (e, t) { var i = new Da, s = t.split(":"); return i.ownerDocument = this, i.nodeName = t, i.name = t, i.namespaceURI = e, i.specified = !0, 2 == s.length ? (i.prefix = s[0], i.localName = s[1]) : i.localName = t, i } }, ra(_a, I), _a.prototype.getElementsByTagName = (Pa.prototype = { nodeType: 1, hasAttribute: function (e) { return null != this.getAttributeNode(e) }, getAttribute: function (e) { e = this.getAttributeNode(e); return e && e.value || "" }, getAttributeNode: function (e) { return this.attributes.getNamedItem(e) }, setAttribute: function (e, t) { e = this.ownerDocument.createAttribute(e); e.value = e.nodeValue = "" + t, this.setAttributeNode(e) }, removeAttribute: function (e) { e = this.getAttributeNode(e); e && this.removeAttributeNode(e) }, appendChild: function (e) { return 11 === e.nodeType ? this.insertBefore(e, null) : (t = this, (e = e).parentNode && e.parentNode.removeChild(e), e.parentNode = t, e.previousSibling = t.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : t.firstChild = e, t.lastChild = e, ba(t.ownerDocument, t, e), e); var t }, setAttributeNode: function (e) { return this.attributes.setNamedItem(e) }, setAttributeNodeNS: function (e) { return this.attributes.setNamedItemNS(e) }, removeAttributeNode: function (e) { return this.attributes.removeNamedItem(e.nodeName) }, removeAttributeNS: function (e, t) { e = this.getAttributeNodeNS(e, t); e && this.removeAttributeNode(e) }, hasAttributeNS: function (e, t) { return null != this.getAttributeNodeNS(e, t) }, getAttributeNS: function (e, t) { e = this.getAttributeNodeNS(e, t); return e && e.value || "" }, setAttributeNS: function (e, t, i) { e = this.ownerDocument.createAttributeNS(e, t); e.value = e.nodeValue = "" + i, this.setAttributeNode(e) }, getAttributeNodeNS: function (e, t) { return this.attributes.getNamedItemNS(e, t) }, getElementsByTagName: function (s) { return new da(this, function (t) { var i = []; return ya(t, function (e) { e === t || 1 != e.nodeType || "*" !== s && e.tagName != s || i.push(e) }), i }) }, getElementsByTagNameNS: function (s, n) { return new da(this, function (t) { var i = []; return ya(t, function (e) { e === t || 1 !== e.nodeType || "*" !== s && e.namespaceURI !== s || "*" !== n && e.localName != n || i.push(e) }), i }) } }).getElementsByTagName, _a.prototype.getElementsByTagNameNS = Pa.prototype.getElementsByTagNameNS, ra(Pa, I), Da.prototype.nodeType = 2, ra(Da, I), Oa.prototype = { data: "", substringData: function (e, t) { return this.data.substring(e, e + t) }, appendData: function (e) { e = this.data + e, this.nodeValue = this.data = e, this.length = e.length }, insertData: function (e, t) { this.replaceData(e, 0, t) }, appendChild: function (e) { throw new Error(C[aa]) }, deleteData: function (e, t) { this.replaceData(e, t, "") }, replaceData: function (e, t, i) { var s = this.data.substring(0, e), e = this.data.substring(e + t); this.nodeValue = this.data = i = s + i + e, this.length = i.length } }, ra(Oa, I), Ma.prototype = { nodeName: "#text", nodeType: 3, splitText: function (e) { var t = (i = this.data).substring(e), i = i.substring(0, e), e = (this.data = this.nodeValue = i, this.length = i.length, this.ownerDocument.createTextNode(t)); return this.parentNode && this.parentNode.insertBefore(e, this.nextSibling), e } }, ra(Ma, Oa), Na.prototype = { nodeName: "#comment", nodeType: 8 }, ra(Na, Oa), Ra.prototype = { nodeName: "#cdata-section", nodeType: 4 }, ra(Ra, Oa), Ua.prototype.nodeType = 10, ra(Ua, I), Ba.prototype.nodeType = 12, ra(Ba, I), Fa.prototype.nodeType = 6, ra(Fa, I), ja.prototype.nodeType = 5, ra(ja, I), Ha.prototype.nodeName = "#document-fragment", Ha.prototype.nodeType = 11, ra(Ha, I), Va.prototype.nodeType = 7, ra(Va, I), qa.prototype.serializeToString = function (e, t, i) { return za.call(e, t, i) }, I.prototype.toString = za; try { Object.defineProperty && (Object.defineProperty(da.prototype, "length", { get: function () { return ha(this), this.$$length } }), Object.defineProperty(I.prototype, "textContent", { get: function () { return function e(t) { switch (t.nodeType) { case 1: case 11: var i = []; for (t = t.firstChild; t;)7 !== t.nodeType && 8 !== t.nodeType && i.push(e(t)), t = t.nextSibling; return i.join(""); default: return t.nodeValue } }(this) }, set: function (e) { switch (this.nodeType) { case 1: case 11: for (; this.firstChild;)this.removeChild(this.firstChild); (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e)); break; default: this.data = e, this.value = e, this.nodeValue = e } } }), Xa = function (e, t, i) { e["$$" + t] = i }) } catch (e) { } var On = { DocumentType: Ua, DOMException: k, DOMImplementation: ga, Element: Pa, Node: I, NodeList: la, XMLSerializer: qa }, Ka = Mt(function (e, t) { var i = Jr.freeze; t.XML_ENTITIES = i({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' }), t.HTML_ENTITIES = i({ lt: "<", gt: ">", amp: "&", quot: '"', apos: "'", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", times: "×", divide: "÷", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", euro: "€", trade: "™", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦" }), t.entityMap = t.HTML_ENTITIES }), Ya = (Ka.XML_ENTITIES, Ka.HTML_ENTITIES, Ka.entityMap, Jr.NAMESPACE), Fn = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Bn = new RegExp("[\\-\\.0-9" + Fn.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), Qa = new RegExp("^" + Fn.source + Bn.source + "*(?::" + Fn.source + Bn.source + "*)?$"), Ja = 0, Za = 1, eo = 2, to = 3, io = 4, so = 5, no = 6, ro = 7; function ao(e, t) { this.message = e, this.locator = t, Error.captureStackTrace && Error.captureStackTrace(this, ao) } function oo() { } function lo(e, t) { return t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber, t } function ho(e, t, i) { for (var s = e.tagName, n = null, r = e.length; r--;) { var a = e[r], o = a.qName, l = a.value, o = 0 < (h = o.indexOf(":")) ? (d = a.prefix = o.slice(0, h), u = o.slice(h + 1), "xmlns" === d && u) : (d = null, "xmlns" === (u = o) && ""); a.localName = u, !1 !== o && (null == n && (n = {}, uo(i, i = {})), i[o] = n[o] = l, a.uri = Ya.XMLNS, t.startPrefixMapping(o, l)) } for (var d, r = e.length; r--;)(d = (a = e[r]).prefix) && ("xml" === d && (a.uri = Ya.XML), "xmlns" !== d) && (a.uri = i[d || ""]); var h, u = 0 < (h = s.indexOf(":")) ? (d = e.prefix = s.slice(0, h), e.localName = s.slice(h + 1)) : (d = null, e.localName = s), c = e.uri = i[d || ""]; if (t.startElement(c, u, s, e), !e.closed) return e.currentNSMap = i, e.localNSMap = n, 1; if (t.endElement(c, u, s), n) for (d in n) Object.prototype.hasOwnProperty.call(n, d) && t.endPrefixMapping(d) } function uo(e, t) { for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]) } function co() { this.attributeNames = {} } (ao.prototype = new Error).name = ao.name, oo.prototype = { parse: function (e, t, i) { var s = this.domBuilder; s.startDocument(), uo(t, t = {}), function (i, e, s, n, r) { function a(e) { var t = e.slice(1, -1); return Object.hasOwnProperty.call(s, t) ? s[t] : "#" === t.charAt(0) ? 65535 < (t = parseInt(t.substr(1).replace("x", "0x"))) ? (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) : String.fromCharCode(t) : (r.error("entity not found:" + e), e) } function t(e) { var t; m < e && (t = i.substring(m, e).replace(/&#?\w+;/g, a), u && o(m), n.characters(t, 0, e - m), m = e) } function o(e, t) { for (; d <= e && (t = h.exec(i));)l = t.index, d = l + t[0].length, u.lineNumber++; u.columnNumber = e - l + 1 } var l = 0, d = 0, h = /.*(?:\r\n?|\n)|.*$/g, u = n.locator, c = [{ currentNSMap: e }], p = {}, m = 0; for (; ;) { try { var g, f, y = i.indexOf("<", m); if (y < 0) return i.substr(m).match(/^\s*$/) || (g = n.doc, f = g.createTextNode(i.substr(m)), g.appendChild(f), n.currentElement = f); switch (m < y && t(y), i.charAt(y + 1)) { case "/": var _ = i.indexOf(">", y + 3), v = i.substring(y + 2, _).replace(/[ \t\n\r]+$/g, ""), b = c.pop(), T = (_ < 0 ? (v = i.substring(y + 2).replace(/[\s<].*/, ""), r.error("end tag name: " + v + " is not complete:" + b.tagName), _ = y + 1 + v.length) : v.match(/\s</) && (v = v.replace(/[\s<].*/, ""), r.error("end tag name: " + v + " maybe not complete"), _ = y + 1 + v.length), b.localNSMap), S = b.tagName == v; if (S || b.tagName && b.tagName.toLowerCase() == v.toLowerCase()) { if (n.endElement(b.uri, b.localName, v), T) for (var w in T) Object.prototype.hasOwnProperty.call(T, w) && n.endPrefixMapping(w); S || r.fatalError("end tag name: " + v + " is not match the current start tagName:" + b.tagName) } else c.push(b); _++; break; case "?": u && o(y), _ = function (e, t, i) { var s = e.indexOf("?>", t); if (s) { e = e.substring(t, s).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/); if (e) return e[0].length, i.processingInstruction(e[1], e[2]), s + 2 } return -1 }(i, y, n); break; case "!": u && o(y), _ = function (e, t, i, s) { { if ("-" === e.charAt(t + 2)) return "-" === e.charAt(t + 3) ? (r = e.indexOf("--\x3e", t + 4), t < r ? (i.comment(e, t + 4, r - t - 4), r + 3) : (s.error("Unclosed comment"), -1)) : -1; if ("CDATA[" == e.substr(t + 3, 6)) return r = e.indexOf("]]>", t + 9), i.startCDATA(), i.characters(e, t + 9, r - t - 9), i.endCDATA(), r + 3; var n, s = function (e, t) { var i, s = [], n = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g; n.lastIndex = t, n.exec(e); for (; i = n.exec(e);)if (s.push(i), i[1]) return s }(e, t), r = s.length; if (1 < r && /!doctype/i.test(s[0][0])) return e = s[1][0], n = t = !1, 3 < r && (/^public$/i.test(s[2][0]) ? (t = s[3][0], n = 4 < r && s[4][0]) : /^system$/i.test(s[2][0]) && (n = s[3][0])), s = s[r - 1], i.startDTD(e, t, n), i.endDTD(), s.index + s[0].length } return -1 }(i, y, n, r); break; default: u && o(y); var E = new co, C = c[c.length - 1].currentNSMap, _ = function (e, t, s, i, n, r) { function a(e, t, i) { s.attributeNames.hasOwnProperty(e) && r.fatalError("Attribute " + e + " redefined"), s.addValue(e, t.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, n), i) } var o, l = ++t, d = Ja; for (; ;) { var h = e.charAt(l); switch (h) { case "=": if (d === Za) o = e.slice(t, l); else if (d !== eo) throw new Error("attribute equal must after attrName"); d = to; break; case "'": case '"': if (d === to || d === Za) { if (d === Za && (r.warning('attribute value must after "="'), o = e.slice(t, l)), t = l + 1, !(0 < (l = e.indexOf(h, t)))) throw new Error("attribute value no end '" + h + "' match"); u = e.slice(t, l), a(o, u, t - 1) } else { if (d != io) throw new Error('attribute value must after "="'); u = e.slice(t, l), a(o, u, t), r.warning('attribute "' + o + '" missed start quot(' + h + ")!!"), t = l + 1 } d = so; break; case "/": switch (d) { case Ja: s.setTagName(e.slice(t, l)); case so: case no: case ro: d = ro, s.closed = !0; case io: case Za: case eo: break; default: throw new Error("attribute invalid close char('/')") }break; case "": return r.error("unexpected end of input"), d == Ja && s.setTagName(e.slice(t, l)), l; case ">": switch (d) { case Ja: s.setTagName(e.slice(t, l)); case so: case no: case ro: break; case io: case Za: "/" === (u = e.slice(t, l)).slice(-1) && (s.closed = !0, u = u.slice(0, -1)); case eo: d === eo && (u = o), d == io ? (r.warning('attribute "' + u + '" missed quot(")!'), a(o, u, t)) : (Ya.isHTML(i[""]) && u.match(/^(?:disabled|checked|selected)$/i) || r.warning('attribute "' + u + '" missed value!! "' + u + '" instead!!'), a(u, u, t)); break; case to: throw new Error("attribute value missed!!") }return l; case "": h = " "; default: if (h <= " ") switch (d) { case Ja: s.setTagName(e.slice(t, l)), d = no; break; case Za: o = e.slice(t, l), d = eo; break; case io: var u = e.slice(t, l); r.warning('attribute "' + u + '" missed quot(")!!'), a(o, u, t); case so: d = no } else switch (d) { case eo: s.tagName, Ya.isHTML(i[""]) && o.match(/^(?:disabled|checked|selected)$/i) || r.warning('attribute "' + o + '" missed value!! "' + o + '" instead2!!'), a(o, o, t), t = l, d = Za; break; case so: r.warning('attribute space is required"' + o + '"!!'); case no: d = Za, t = l; break; case to: d = io, t = l; break; case ro: throw new Error("elements closed character '/' and '>' must be connected to") } }l++ } }(i, y, E, C, a, r), k = E.length; if (!E.closed && function (e, t, i, s) { var n = s[i]; null == n && ((n = e.lastIndexOf("</" + i + ">")) < t && (n = e.lastIndexOf("</" + i)), s[i] = n); return n < t }(i, _, E.tagName, p) && (E.closed = !0, s.nbsp || r.warning("unclosed xml attribute")), u && k) { for (var I = lo(u, {}), x = 0; x < k; x++) { var A = E[x]; o(A.offset), A.locator = lo(u, {}) } n.locator = I, ho(E, n, C) && c.push(E), n.locator = u } else ho(E, n, C) && c.push(E); Ya.isHTML(E.uri) && !E.closed ? _ = function (e, t, i, s, n) { if (/^(?:script|textarea)$/i.test(i)) { var r = e.indexOf("</" + i + ">", t), e = e.substring(t + 1, r); if (/[&<]/.test(e)) return /^script$/i.test(i) ? n.characters(e, 0, e.length) : (e = e.replace(/&#?\w+;/g, s), n.characters(e, 0, e.length)), r } return t + 1 }(i, _, E.tagName, a, n) : _++ } } catch (e) { if (e instanceof ao) throw e; r.error("element parse error: " + e), _ = -1 } m < _ ? m = _ : t(Math.max(y, m) + 1) } }(e, t, i, s, this.errorHandler), s.endDocument() } }, co.prototype = { setTagName: function (e) { if (!Qa.test(e)) throw new Error("invalid tagName:" + e); this.tagName = e }, addValue: function (e, t, i) { if (!Qa.test(e)) throw new Error("invalid attribute:" + e); this.attributeNames[e] = this.length, this[this.length++] = { qName: e, value: t, offset: i } }, length: 0, getLocalName: function (e) { return this[e].localName }, getLocator: function (e) { return this[e].locator }, getQName: function (e) { return this[e].qName }, getURI: function (e) { return this[e].uri }, getValue: function (e) { return this[e].value } }; var Un = { XMLReader: oo, ParseError: ao }, po = On.DOMImplementation, mo = Jr.NAMESPACE, go = Un.ParseError, fo = Un.XMLReader; function yo(e) { return e.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n") } function _o(e) { this.options = e || { locator: {} } } function vo() { this.cdata = !1 } function bo(e, t) { t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber } function To(e) { if (e) return "\n@" + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]" } function So(e, t, i) { return "string" == typeof e ? e.substr(t, i) : e.length >= t + i || t ? new java.lang.String(e, t, i) + "" : e } function wo(e, t) { (e.currentElement || e.doc).appendChild(t) } _o.prototype.parseFromString = function (e, t) { var i = this.options, s = new fo, n = i.domBuilder || new vo, r = i.errorHandler, a = i.locator, o = i.xmlns || {}, t = /\/x?html?$/.test(t), l = t ? Ka.HTML_ENTITIES : Ka.XML_ENTITIES, r = (a && n.setDocumentLocator(a), s.errorHandler = function (s, e, n) { if (!s) { if (e instanceof vo) return e; s = e } var r = {}, a = s instanceof Function; function t(t) { var i = s[t]; !i && a && (i = 2 == s.length ? function (e) { s(t, e) } : s), r[t] = i ? function (e) { i("[xmldom " + t + "]\t" + e + To(n)) } : function () { } } return n = n || {}, t("warning"), t("error"), t("fatalError"), r }(r, n, a), s.domBuilder = i.domBuilder || n, t && (o[""] = mo.HTML), o.xml = o.xml || mo.XML, i.normalizeLineEndings || yo); return e && "string" == typeof e ? s.parse(r(e), o, l) : s.errorHandler.error("invalid doc source"), n.doc }, vo.prototype = { startDocument: function () { this.doc = (new po).createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId) }, startElement: function (e, t, i, s) { var n = this.doc, r = n.createElementNS(e, i || t), a = s.length; wo(this, r), this.currentElement = r, this.locator && bo(this.locator, r); for (var o = 0; o < a; o++) { var e = s.getURI(o), l = s.getValue(o), i = s.getQName(o), d = n.createAttributeNS(e, i); this.locator && bo(s.getLocator(o), d), d.value = d.nodeValue = l, r.setAttributeNode(d) } }, endElement: function (e, t, i) { var s = this.currentElement; s.tagName, this.currentElement = s.parentNode }, startPrefixMapping: function (e, t) { }, endPrefixMapping: function (e) { }, processingInstruction: function (e, t) { e = this.doc.createProcessingInstruction(e, t); this.locator && bo(this.locator, e), wo(this, e) }, ignorableWhitespace: function (e, t, i) { }, characters: function (e, t, i) { var s; (e = So.apply(this, arguments)) && (s = this.cdata ? this.doc.createCDATASection(e) : this.doc.createTextNode(e), this.currentElement ? this.currentElement.appendChild(s) : /^\s*$/.test(e) && this.doc.appendChild(s), this.locator) && bo(this.locator, s) }, skippedEntity: function (e) { }, endDocument: function () { this.doc.normalize() }, setDocumentLocator: function (e) { (this.locator = e) && (e.lineNumber = 0) }, comment: function (e, t, i) { e = So.apply(this, arguments); e = this.doc.createComment(e); this.locator && bo(this.locator, e), wo(this, e) }, startCDATA: function () { this.cdata = !0 }, endCDATA: function () { this.cdata = !1 }, startDTD: function (e, t, i) { var s = this.doc.implementation; s && s.createDocumentType && (s = s.createDocumentType(e, t, i), this.locator && bo(this.locator, s), wo(this, s), this.doc.doctype = s) }, warning: function (e) { }, error: function (e) { }, fatalError: function (e) { throw new go(e, this.locator) } }, "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (e) { vo.prototype[e] = function () { return null } }); var Eo = { __DOMHandler: vo, normalizeLineEndings: yo, DOMParser: _o }.DOMParser;
  /*! @name mpd-parser @version 1.1.1 @license Apache-2.0 */
  const Co = e => !!e && "object" == typeof e, x = (...e) => e.reduce((t, i) => ("object" == typeof i && Object.keys(i).forEach(e => { Array.isArray(t[e]) && Array.isArray(i[e]) ? t[e] = t[e].concat(i[e]) : Co(t[e]) && Co(i[e]) ? t[e] = x(t[e], i[e]) : t[e] = i[e] }), t), {}), ko = t => Object.keys(t).map(e => t[e]), Io = e => e.reduce((e, t) => e.concat(t), []), xo = t => { if (!t.length) return []; var i = []; for (let e = 0; e < t.length; e++)i.push(t[e]); return i }; var Ao = { INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD", DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST", DASH_INVALID_XML: "DASH_INVALID_XML", NO_BASE_URL: "NO_BASE_URL", MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION", SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED", UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME" }; const Lo = ({ baseUrl: s = "", source: n = "", range: r = "", indexRange: a = "" }) => { s = { uri: n, resolvedUri: Mr(s || "", n) }; if (r || a) { n = (r || a).split("-"); let e = window.BigInt ? window.BigInt(n[0]) : parseInt(n[0], 10), t = window.BigInt ? window.BigInt(n[1]) : parseInt(n[1], 10); e < Number.MAX_SAFE_INTEGER && "bigint" == typeof e && (e = Number(e)), t < Number.MAX_SAFE_INTEGER && "bigint" == typeof t && (t = Number(t)); let i; "bigint" == typeof (i = "bigint" == typeof t || "bigint" == typeof e ? window.BigInt(t) - window.BigInt(e) + window.BigInt(1) : t - e + 1) && i < Number.MAX_SAFE_INTEGER && (i = Number(i)), s.byterange = { length: i, offset: e } } return s }, Po = e => (e && "number" != typeof e && (e = parseInt(e, 10)), isNaN(e) ? null : e), Do = { static(e) { var { duration: t, timescale: i = 1, sourceDuration: s, periodDuration: n } = e, e = Po(e.endNumber), t = t / i; return "number" == typeof e ? { start: 0, end: e } : "number" == typeof n ? { start: 0, end: n / t } : { start: 0, end: s / t } }, dynamic(e) { var { NOW: t, clientOffset: i, availabilityStartTime: s, timescale: n = 1, duration: r, periodStart: a = 0, minimumUpdatePeriod: o = 0, timeShiftBufferDepth: l = 1 / 0 } = e, e = Po(e.endNumber), t = (t + i) / 1e3, i = s + a, s = Math.ceil((t + o - i) * n / r), a = Math.floor((t - i - l) * n / r), o = Math.floor((t - i) * n / r); return { start: Math.max(0, a), end: "number" == typeof e ? e : Math.min(s, o) } } }, Oo = e => { var r, { type: t, duration: i, timescale: s = 1, periodDuration: n, sourceDuration: a } = e, { start: o, end: l } = Do[t](e), o = ((t, i) => { var s = []; for (let e = t; e < i; e++)s.push(e); return s })(o, l).map((r = e, e => { var { duration: t, timescale: i = 1, periodStart: s, startNumber: n = 1 } = r; return { number: n + e, duration: t / i, timeline: s, time: e * t } })); return "static" === t && (o[l = o.length - 1].duration = ("number" == typeof n ? n : a) - i / s * l), o }, Mo = e => { var { baseUrl: t, initialization: i = {}, sourceDuration: s, indexRange: n = "", periodStart: r, presentationTime: a, number: o = 0, duration: l } = e; if (t) return i = Lo({ baseUrl: t, source: i.sourceURL, range: i.range }), (t = Lo({ baseUrl: t, source: t, indexRange: n })).map = i, l ? (n = Oo(e)).length && (t.duration = n[0].duration, t.timeline = n[0].timeline) : s && (t.duration = s, t.timeline = r), t.presentationTime = a || r, t.number = o, [t]; throw new Error(Ao.NO_BASE_URL) }, No = (e, i, s) => { var n = e.sidx.map || null, r = e.sidx.duration, a = e.timeline || 0, t = e.sidx.byterange, t = t.offset + t.length, o = i.timescale, l = i.references.filter(e => 1 !== e.referenceType), d = [], h = e.endList ? "static" : "dynamic", u = e.sidx.timeline; let c = u, p = e.mediaSequence || 0, m; m = "bigint" == typeof i.firstOffset ? window.BigInt(t) + i.firstOffset : t + i.firstOffset; for (let t = 0; t < l.length; t++) { var g = i.references[t], f = g.referencedSize, g = g.subsegmentDuration; let e; e = "bigint" == typeof m ? m + window.BigInt(f) - window.BigInt(1) : m + f - 1; var y = m + "-" + e, y = { baseUrl: s, timescale: o, timeline: a, periodStart: u, presentationTime: c, number: p, duration: g, sourceDuration: r, indexRange: y, type: h }, y = Mo(y)[0]; n && (y.map = n), d.push(y), "bigint" == typeof m ? m += window.BigInt(f) : m += f, c += g / o, p++ } return e.segments = d, e }, Ro = ["AUDIO", "SUBTITLES"], Uo = e => { return e = e, i = ({ timeline: e }) => e, ko(e.reduce((t, e) => (e.forEach(e => { t[i(e)] = e }), t), {})).sort((e, t) => e.timeline > t.timeline ? 1 : -1); var i }, Bo = e => { let n = []; var r, a; return r = e, e = Ro, a = (e, t, i, s) => { n = n.concat(e.playlists || []) }, e.forEach(function (e) { for (var t in r.mediaGroups[e]) for (var i in r.mediaGroups[e][t]) { var s = r.mediaGroups[e][t][i]; a(s, e, t, i) } }), n }, Fo = ({ playlist: i, mediaSequence: e }) => { i.mediaSequence = e, i.segments.forEach((e, t) => { e.number = i.mediaSequence + t }) }, jo = ({ oldManifest: e, newManifest: t }) => { var n, r, i = e.playlists.concat(Bo(e)), s = t.playlists.concat(Bo(t)); return t.timelineStarts = Uo([e.timelineStarts, t.timelineStarts]), { oldPlaylists: n, newPlaylists: e, timelineStarts: r } = [{ oldPlaylists: i, newPlaylists: s, timelineStarts: t.timelineStarts }][0], e.forEach(t => { t.discontinuitySequence = r.findIndex(function ({ timeline: e }) { return e === t.timeline }); var e = ((t, i) => { for (let e = 0; e < t.length; e++)if (t[e].attributes.NAME === i) return t[e]; return null })(n, t.attributes.NAME); if (e && !t.sidx) { const s = t.segments[0]; var i = e.segments.findIndex(function (e) { return Math.abs(e.presentationTime - s.presentationTime) < 1 / 60 }); -1 === i ? (Fo({ playlist: t, mediaSequence: e.mediaSequence + e.segments.length }), t.segments[0].discontinuity = !0, t.discontinuityStarts.unshift(0), (!e.segments.length && t.timeline > e.timeline || e.segments.length && t.timeline > e.segments[e.segments.length - 1].timeline) && t.discontinuitySequence--) : (e.segments[i].discontinuity && !s.discontinuity && (s.discontinuity = !0, t.discontinuityStarts.unshift(0), t.discontinuitySequence--), Fo({ playlist: t, mediaSequence: e.segments[i].number })) } }), t }, Ho = e => e && e.uri + "-" + (e => { let t; return t = "bigint" == typeof e.offset || "bigint" == typeof e.length ? window.BigInt(e.offset) + window.BigInt(e.length) - window.BigInt(1) : e.offset + e.length - 1, e.offset + "-" + t })(e.byterange), Vo = e => { return ko(e.reduce((e, t) => { var i = t.attributes.id + (t.attributes.lang || ""); return e[i] ? (t.segments && (t.segments[0] && (t.segments[0].discontinuity = !0), e[i].segments.push(...t.segments)), t.attributes.contentProtection && (e[i].attributes.contentProtection = t.attributes.contentProtection)) : (e[i] = t, e[i].attributes.timelineStarts = []), e[i].attributes.timelineStarts.push({ start: t.attributes.periodStart, timeline: t.attributes.periodStart }), e }, {})).map(e => { var t, s; return e.discontinuityStarts = (t = e.segments || [], s = "discontinuity", t.reduce((e, t, i) => (t[s] && e.push(i), e), [])), e }) }, qo = (e, t) => { var i = Ho(e.sidx), t = i && t[i] && t[i].sidx; return t && No(e, t, e.sidx.resolvedUri), e }, zo = (e, o = {}) => e.reduce((e, t) => { var i, s, n, r, a = t.attributes.label || t.attributes.lang || "text"; return e[a] || (e[a] = { language: a, default: !1, autoselect: !1, playlists: [], uri: "" }), e[a].playlists.push(qo(({ attributes: a, segments: t, mediaSequence: i, discontinuityStarts: s, discontinuitySequence: n } = [t][0], "undefined" == typeof t && (t = [{ uri: a.baseUrl, timeline: a.periodStart, resolvedUri: a.baseUrl || "", duration: a.sourceDuration, number: 0 }], a.duration = a.sourceDuration), r = { NAME: a.id, BANDWIDTH: a.bandwidth, "PROGRAM-ID": 1 }, a.codecs && (r.CODECS = a.codecs), { attributes: r, uri: "", endList: "static" === a.type, timeline: a.periodStart, resolvedUri: a.baseUrl || "", targetDuration: a.duration, timelineStarts: a.timelineStarts, discontinuityStarts: s, discontinuitySequence: n, mediaSequence: i, segments: t }), o)), e }, {}), $o = ({ attributes: e, segments: t, sidx: i, discontinuityStarts: s }) => { s = { attributes: { NAME: e.id, AUDIO: "audio", SUBTITLES: "subs", RESOLUTION: { width: e.width, height: e.height }, CODECS: e.codecs, BANDWIDTH: e.bandwidth, "PROGRAM-ID": 1 }, uri: "", endList: "static" === e.type, timeline: e.periodStart, resolvedUri: "", targetDuration: e.duration, discontinuityStarts: s, timelineStarts: e.timelineStarts, segments: t }; return e.frameRate && (s.attributes["FRAME-RATE"] = e.frameRate), e.contentProtection && (s.contentProtection = e.contentProtection), i && (s.sidx = i), s }, Wo = ({ attributes: e }) => "video/mp4" === e.mimeType || "video/webm" === e.mimeType || "video" === e.contentType, Go = ({ attributes: e }) => "audio/mp4" === e.mimeType || "audio/webm" === e.mimeType || "audio" === e.contentType, Xo = ({ attributes: e }) => "text/vtt" === e.mimeType || "text" === e.contentType, Ko = i => i ? Object.keys(i).reduce((e, t) => { t = i[t]; return e.concat(t.playlists) }, []) : [], Yo = ({ dashPlaylists: e, locations: t, sidxMapping: i = {}, previousManifest: s, eventStream: n }) => { var r, a, o, l, d, h, u, c; return e.length ? ({ sourceDuration: l, type: h, suggestedPresentationDelay: u, minimumUpdatePeriod: d } = e[0].attributes, r = Vo(e.filter(Wo)).map($o), a = Vo(e.filter(Go)), o = Vo(e.filter(Xo)), e = e.map(e => e.attributes.captionServices).filter(Boolean), l = { allowCache: !0, discontinuityStarts: [], segments: [], endList: !0, mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: "", duration: l, playlists: ((e, t = {}) => { if (Object.keys(t).length) for (const i in e) e[i] = qo(e[i], t); return e })(r, i) }, 0 <= d && (l.minimumUpdatePeriod = 1e3 * d), t && (l.locations = t), "dynamic" === h && (l.suggestedPresentationDelay = u), n && 0 < n.length && (l.eventStream = n), d = 0 === l.playlists.length, t = a.length ? ((e, r = {}, a) => { let o; e = e.reduce((e, t) => { var i = t.attributes.role && t.attributes.role.value || "", s = t.attributes.lang || ""; let n = t.attributes.label || "main"; e[n = s && !t.attributes.label ? t.attributes.lang + (i ? ` (${i})` : "") : n] || (e[n] = { language: s, autoselect: !0, default: "main" === i, playlists: [], uri: "" }); s = qo((({ attributes: e, segments: t, sidx: i, mediaSequence: s, discontinuitySequence: n, discontinuityStarts: r }, a) => { n = { attributes: { NAME: e.id, BANDWIDTH: e.bandwidth, CODECS: e.codecs, "PROGRAM-ID": 1 }, uri: "", endList: "static" === e.type, timeline: e.periodStart, resolvedUri: "", targetDuration: e.duration, discontinuitySequence: n, discontinuityStarts: r, timelineStarts: e.timelineStarts, mediaSequence: s, segments: t }; return e.contentProtection && (n.contentProtection = e.contentProtection), i && (n.sidx = i), a && (n.attributes.AUDIO = "audio", n.attributes.SUBTITLES = "subs"), n })(t, a), r); return e[n].playlists.push(s), "undefined" == typeof o && "main" === i && ((o = t).default = !0), e }, {}); return o || (e[Object.keys(e)[0]].default = !0), e })(a, i, d) : null, h = o.length ? zo(o, i) : null, n = (u = r.concat(Ko(t), Ko(h))).map(({ timelineStarts: e }) => e), l.timelineStarts = Uo(n), c = l.timelineStarts, u.forEach(t => { t.mediaSequence = 0, t.discontinuitySequence = c.findIndex(function ({ timeline: e }) { return e === t.timeline }), t.segments && t.segments.forEach((e, t) => { e.number = t }) }), t && (l.mediaGroups.AUDIO.audio = t), h && (l.mediaGroups.SUBTITLES.subs = h), e.length && (l.mediaGroups["CLOSED-CAPTIONS"].cc = e.reduce((s, e) => (e && e.forEach(e => { var { channel: t, language: i } = e; s[i] = { autoselect: !1, default: !1, instreamId: t, language: i }, e.hasOwnProperty("aspectRatio") && (s[i].aspectRatio = e.aspectRatio), e.hasOwnProperty("easyReader") && (s[i].easyReader = e.easyReader), e.hasOwnProperty("3D") && (s[i]["3D"] = e["3D"]) }), s), {})), s ? jo({ oldManifest: s, newManifest: l }) : l) : {} }, Qo = (s, n) => { var { type: r, minimumUpdatePeriod: a = 0, media: o = "", sourceDuration: l, timescale: d = 1, startNumber: h = 1, periodStart: u } = s, c = []; let p = -1; for (let i = 0; i < n.length; i++) { var m = n[i], g = m.d, f = m.r || 0, m = m.t || 0; p < 0 && (p = m), m && m > p && (p = m); let e; e = f < 0 ? (m = i + 1) === n.length ? "dynamic" === r && 0 < a && 0 < o.indexOf("$Number$") ? ((e, t, i) => { var { NOW: e, clientOffset: s, availabilityStartTime: n, timescale: r = 1, periodStart: a = 0, minimumUpdatePeriod: o = 0 } = e; return Math.ceil((((e + s) / 1e3 + o - (n + a)) * r - t) / i) })(s, p, g) : (l * d - p) / g : (n[m].t - p) / g : f + 1; var y = h + c.length + e; let t = h + c.length; for (; t < y;)c.push({ number: t, duration: g / d, time: p, timeline: u }), p += g, t++ } return c }, Jo = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, Zo = (e, t) => { return e.replace(Jo, (n = t, (e, t, i, s) => { return "$$" === e ? "$" : "undefined" == typeof n[t] ? e : (e = "" + n[t], "RepresentationID" === t || (s = i ? parseInt(s, 10) : 1) <= e.length ? e : new Array(s - e.length + 1).join("0") + e) })); var n }, el = (n, e) => { const r = { RepresentationID: n.id, Bandwidth: n.bandwidth || 0 }; var { initialization: t = { sourceURL: "", range: "" } } = n; const a = Lo({ baseUrl: n.baseUrl, source: Zo(t.sourceURL, r), range: t.range }); return t = e, ((e = n).duration || t ? e.duration ? Oo(e) : Qo(e, t) : [{ number: e.startNumber || 1, duration: e.sourceDuration, time: 0, timeline: e.periodStart }]).map(e => { r.Number = e.number, r.Time = e.time; var t = Zo(n.media || "", r), i = n.timescale || 1, s = n.presentationTimeOffset || 0, s = n.periodStart + (e.time - s) / i; return { uri: t, timeline: e.timeline, duration: e.duration, resolvedUri: Mr(n.baseUrl || "", t), map: a, number: e.number, presentationTime: s } }) }, tl = (n, e) => { const { duration: t, segmentUrls: i = [], periodStart: r } = n; if (!t && !e || t && e) throw new Error(Ao.SEGMENT_TIME_UNSPECIFIED); const a = i.map(e => { var { baseUrl: t, initialization: i = {} } = t = n, i = Lo({ baseUrl: t, source: i.sourceURL, range: i.range }); return (t = Lo({ baseUrl: t, source: e.media, range: e.mediaRange })).map = i, t }); let s; return t && (s = Oo(n)), (s = e ? Qo(n, e) : s).map((e, t) => { var i, s; if (a[t]) return t = a[t], i = n.timescale || 1, s = n.presentationTimeOffset || 0, t.timeline = e.timeline, t.duration = e.duration, t.number = e.number, t.presentationTime = r + (e.time - s) / i, t }).filter(e => e) }, il = ({ attributes: e, segmentInfo: t }) => { let i, s; t.template ? (s = el, i = x(e, t.template)) : t.base ? (s = Mo, i = x(e, t.base)) : t.list && (s = tl, i = x(e, t.list)); var n, r, a, e = { attributes: e }; return s && (n = s(i, t.segmentTimeline), i.duration ? ({ duration: r, timescale: a = 1 } = i, i.duration = r / a) : n.length ? i.duration = n.reduce((e, t) => Math.max(e, Math.ceil(t.duration)), 0) : i.duration = 0, e.attributes = i, e.segments = n, t.base) && i.indexRange && (e.sidx = n[0], e.segments = []), e }, sl = e => e.map(il), A = (e, t) => xo(e.childNodes).filter(({ tagName: e }) => e === t), nl = e => e.textContent.trim(), rl = e => { var t, i, s, n, r, e = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(e); return e ? ([e, t, i, s, n, r] = e.slice(1), 31536e3 * parseFloat(e || 0) + 2592e3 * parseFloat(t || 0) + 86400 * parseFloat(i || 0) + 3600 * parseFloat(s || 0) + 60 * parseFloat(n || 0) + parseFloat(r || 0)) : 0 }, al = { mediaPresentationDuration(e) { return rl(e) }, availabilityStartTime(e) { return /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(e = e) && (e += "Z"), Date.parse(e) / 1e3 }, minimumUpdatePeriod(e) { return rl(e) }, suggestedPresentationDelay(e) { return rl(e) }, type(e) { return e }, timeShiftBufferDepth(e) { return rl(e) }, start(e) { return rl(e) }, width(e) { return parseInt(e, 10) }, height(e) { return parseInt(e, 10) }, bandwidth(e) { return parseInt(e, 10) }, frameRate(e) { return parseFloat(e.split("/").reduce((e, t) => e / t)) }, startNumber(e) { return parseInt(e, 10) }, timescale(e) { return parseInt(e, 10) }, presentationTimeOffset(e) { return parseInt(e, 10) }, duration(e) { var t = parseInt(e, 10); return isNaN(t) ? rl(e) : t }, d(e) { return parseInt(e, 10) }, t(e) { return parseInt(e, 10) }, r(e) { return parseInt(e, 10) }, presentationTime(e) { return parseInt(e, 10) }, DEFAULT(e) { return e } }, L = e => e && e.attributes ? xo(e.attributes).reduce((e, t) => { var i = al[t.name] || al.DEFAULT; return e[t.name] = i(t.value), e }, {}) : {}, ol = { "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha", "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready", "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime" }, ll = (e, i) => i.length ? Io(e.map(function (t) { return i.map(function (e) { return Mr(t, nl(e)) }) })) : e, dl = e => { var t = A(e, "SegmentTemplate")[0], i = A(e, "SegmentList")[0], s = i && A(i, "SegmentURL").map(e => x({ tag: "SegmentURL" }, L(e))), e = A(e, "SegmentBase")[0], n = i || t, n = n && A(n, "SegmentTimeline")[0], r = i || e || t, r = r && A(r, "Initialization")[0], t = t && L(t); t && r ? t.initialization = r && L(r) : t && t.initialization && (t.initialization = { sourceURL: t.initialization }); const a = { template: t, segmentTimeline: n && A(n, "S").map(e => L(e)), list: i && x(L(i), { segmentUrls: s, initialization: L(r) }), base: e && x(L(e), { initialization: L(r) }) }; return Object.keys(a).forEach(e => { a[e] || delete a[e] }), a }, hl = o => Io(A(o.node, "EventStream").map(e => { const r = L(e), a = r.schemeIdUri; return A(e, "Event").map(e => { var t = L(e), i = t.presentationTime || 0, s = r.timescale || 1, n = t.duration || 0, i = i / s + o.attributes.start; return { schemeIdUri: a, value: r.value, id: t.id, start: i, end: i + n / s, messageData: nl(e) || t.messageData, contentEncoding: r.contentEncoding, presentationTimeOffset: r.presentationTimeOffset || 0 } }) })), ul = (l, d, h) => e => { var t = L(e), i = ll(d, A(e, "BaseURL")), s = A(e, "Role")[0], s = { role: L(s) }; let n = x(l, t, s); var r, a, o, t = A(e, "Accessibility")[0], t = "urn:scte:dash:cc:cea-608:2015" === (s = L(t)).schemeIdUri ? ("string" != typeof s.value ? [] : s.value.split(";")).map(e => { let t, i; return i = e, /^CC\d=/.test(e) ? [t, i] = e.split("=") : /^CC\d$/.test(e) && (t = e), { channel: t, language: i } }) : "urn:scte:dash:cc:cea-708:2015" === s.schemeIdUri ? ("string" != typeof s.value ? [] : s.value.split(";")).map(e => { const i = { channel: void 0, language: void 0, aspectRatio: 1, easyReader: 0, "3D": 0 }; var t, s; return /=/.test(e) ? ([t, s = ""] = e.split("="), i.channel = t, i.language = e, s.split(",").forEach(e => { var [e, t] = e.split(":"); "lang" === e ? i.language = t : "er" === e ? i.easyReader = Number(t) : "war" === e ? i.aspectRatio = Number(t) : "3D" === e && (i["3D"] = Number(t)) })) : i.language = e, i.channel && (i.channel = "SERVICE" + i.channel), i }) : void 0, s = (t && (n = x(n, { captionServices: t })), A(e, "Label")[0]), s = (s && s.childNodes.length && (t = s.childNodes[0].nodeValue.trim(), n = x(n, { label: t })), A(e, "ContentProtection").reduce((e, t) => { var i = L(t), s = (i.schemeIdUri && (i.schemeIdUri = i.schemeIdUri.toLowerCase()), ol[i.schemeIdUri]); return s && (e[s] = { attributes: i }, i = A(t, "cenc:pssh")[0]) && (t = nl(i), e[s].pssh = t && Xr(t)), e }, {})), t = (Object.keys(s).length && (n = x(n, { contentProtection: s })), dl(e)), s = A(e, "Representation"), e = x(h, t); return Io(s.map((r = n, a = i, o = e, e => { var t = A(e, "BaseURL"), t = ll(a, t); const i = x(r, L(e)), s = dl(e); return t.map(e => ({ segmentInfo: x(o, s), attributes: x(i, { baseUrl: e }) })) }))) }, cl = (e, t = {}) => { var { manifestUri: t = "", NOW: i = Date.now(), clientOffset: s = 0 } = t, n = A(e, "Period"); if (!n.length) throw new Error(Ao.INVALID_NUMBER_OF_PERIOD); var r = A(e, "Location"); const a = L(e); var o, l, t = ll([t], A(e, "BaseURL")); a.type = a.type || "static", a.sourceDuration = a.mediaPresentationDuration || 0, a.NOW = i, a.clientOffset = s, r.length && (a.locations = r.map(nl)); const d = []; return n.forEach((e, t) => { var i, s, n = L(e), t = d[t - 1]; n.start = ({ attributes: t, priorPeriodAttributes: i, mpdType: s } = [{ attributes: n, priorPeriodAttributes: t ? t.attributes : null, mpdType: a.type }][0], "number" == typeof t.start ? t.start : i && "number" == typeof i.start && "number" == typeof i.duration ? i.start + i.duration : i || "static" !== s ? null : 0), d.push({ node: e, attributes: n }) }), { locations: a.locations, representationInfo: Io(d.map((o = a, l = t, (e, t) => { var i = ll(l, A(e.node, "BaseURL")), s = x(o, { periodStart: e.attributes.start }), n = ("number" == typeof e.attributes.duration && (s.periodDuration = e.attributes.duration), A(e.node, "AdaptationSet")), e = dl(e.node); return Io(n.map(ul(s, i, e))) }))), eventStream: Io(d.map(hl)) } }, pl = e => { if ("" === e) throw new Error(Ao.DASH_EMPTY_MANIFEST); var t, i = new Eo; let s; try { t = i.parseFromString(e, "application/xml"), s = t && "MPD" === t.documentElement.tagName ? t.documentElement : null } catch (e) { } if (!s || s && 0 < s.getElementsByTagName("parsererror").length) throw new Error(Ao.DASH_INVALID_XML); return s }, ml = e => { e = pl(e); if (!(e = A(e, "UTCTiming")[0])) return null; var t = L(e); switch (t.schemeIdUri) { case "urn:mpeg:dash:utc:http-head:2014": case "urn:mpeg:dash:utc:http-head:2012": t.method = "HEAD"; break; case "urn:mpeg:dash:utc:http-xsdate:2014": case "urn:mpeg:dash:utc:http-iso:2014": case "urn:mpeg:dash:utc:http-xsdate:2012": case "urn:mpeg:dash:utc:http-iso:2012": t.method = "GET"; break; case "urn:mpeg:dash:utc:direct:2014": case "urn:mpeg:dash:utc:direct:2012": t.method = "DIRECT", t.value = Date.parse(t.value); break; default: throw new Error(Ao.UNSUPPORTED_UTC_TIMING_SCHEME) }return t }; function gl(e, t) { var i, s, n; return void 0 === t && (t = 0), (e = S(e)).length - t < 10 || !E(e, Cl, { offset: t }) ? t : (t += (void 0 === (s = t) && (s = 0), n = (i = S(i = e))[s + 5], i = i[s + 6] << 21 | i[s + 7] << 14 | i[s + 8] << 7 | i[s + 9], (16 & n) >> 4 ? 20 + i : 10 + i), gl(e, t)) } function fl(e) { return "string" == typeof e ? Or(e) : e } function yl(e, t, i) { void 0 === i && (i = !1), s = t, t = Array.isArray(s) ? s.map(fl) : [fl(s)], e = S(e); var s, n = []; if (t.length) for (var r = 0; r < e.length;) { var a = (e[r] << 24 | e[r + 1] << 16 | e[r + 2] << 8 | e[r + 3]) >>> 0, o = e.subarray(r + 4, r + 8); if (0 == a) break; a = r + a; if (a > e.length) { if (i) break; a = e.length } var l = e.subarray(r + 8, a); E(o, t[0]) && (1 === t.length ? n.push(l) : n.push.apply(n, yl(l, t.slice(1), i))), r = a } return n } function _l(e, t, i) { var s; return i >= t.length ? t.length : (s = Al(t, i, !1), E(e.bytes, s.bytes) ? i : _l(e, t, i + (e = Al(t, i + s.length)).length + e.value + s.length)) } function vl(e, t) { i = t, t = Array.isArray(i) ? i.map(function (e) { return Ll(e) }) : [Ll(i)], e = S(e); var i, s = []; if (t.length) for (var n = 0; n < e.length;) { var r = Al(e, n, !1), a = Al(e, n + r.length), o = n + r.length + a.length, l = (127 === a.value && (a.value = _l(r, e, o), a.value !== e.length) && (a.value -= o), o + a.value > e.length ? e.length : o + a.value), o = e.subarray(o, l); E(t[0], r.bytes) && (1 === t.length ? s.push(o) : s = s.concat(vl(o, t.slice(1)))), n += r.length + a.length + o.length } return s } function bl(e, t, i, s) { void 0 === s && (s = 1 / 0), e = S(e), i = [].concat(i); for (var n, r = 0, a = 0; r < e.length && (a < s || n);) { var o = void 0; if (E(e.subarray(r), Pl) ? o = 4 : E(e.subarray(r), Dl) && (o = 3), o) { if (a++, n) return Ml(e.subarray(n, r)); var l = void 0; "h264" === t ? l = 31 & e[r + o] : "h265" === t && (l = e[r + o] >> 1 & 63), -1 !== i.indexOf(l) && (n = r + o), r += o + ("h264" === t ? 1 : 2) } else r++ } return e.subarray(0, 0) } function Tl(e) { e = S(e); for (var t = 0; t < Rl.length; t++) { var i = Rl[t]; if (Ul[i](e)) return i } return "" } var Sl = Math.pow(2, 32), wl = function (e) { var t, e = new DataView(e.buffer, e.byteOffset, e.byteLength); return e.getBigUint64 ? (t = e.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : e.getUint32(0) * Sl + e.getUint32(4) }, El = function (e) { var t = new DataView(e.buffer, e.byteOffset, e.byteLength), i = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), references: [], referenceId: t.getUint32(4), timescale: t.getUint32(8) }, s = 12, n = (0 === i.version ? (i.earliestPresentationTime = t.getUint32(s), i.firstOffset = t.getUint32(s + 4), s += 8) : (i.earliestPresentationTime = wl(e.subarray(s)), i.firstOffset = wl(e.subarray(s + 8)), s += 16), t.getUint16(s += 2)); for (s += 2; 0 < n; s += 12, n--)i.references.push({ referenceType: (128 & e[s]) >>> 7, referencedSize: 2147483647 & t.getUint32(s), subsegmentDuration: t.getUint32(s + 4), startsWithSap: !!(128 & e[s + 8]), sapType: (112 & e[s + 8]) >>> 4, sapDeltaTime: 268435455 & t.getUint32(s + 8) }); return i }, Cl = S([73, 68, 51]), kl = { EBML: S([26, 69, 223, 163]), DocType: S([66, 130]), Segment: S([24, 83, 128, 103]), SegmentInfo: S([21, 73, 169, 102]), Tracks: S([22, 84, 174, 107]), Track: S([174]), TrackNumber: S([215]), DefaultDuration: S([35, 227, 131]), TrackEntry: S([174]), TrackType: S([131]), FlagDefault: S([136]), CodecID: S([134]), CodecPrivate: S([99, 162]), VideoTrack: S([224]), AudioTrack: S([225]), Cluster: S([31, 67, 182, 117]), Timestamp: S([231]), TimestampScale: S([42, 215, 177]), BlockGroup: S([160]), BlockDuration: S([155]), Block: S([161]), SimpleBlock: S([163]) }, Il = [128, 64, 32, 16, 8, 4, 2, 1], xl = function (e) { for (var t = 1, i = 0; i < Il.length && !(e & Il[i]); i++)t++; return t }, Al = function (e, t, i, s) { void 0 === i && (i = !0), void 0 === s && (s = !1); var n = xl(e[t]), r = e.subarray(t, t + n); return i && ((r = Array.prototype.slice.call(e, t, t + n))[0] ^= Il[n - 1]), { length: n, value: Wr(r, { signed: s }), bytes: r } }, Ll = function e(t) { return "string" == typeof t ? t.match(/.{1,2}/g).map(e) : "number" == typeof t ? Dr(t) : t }, Pl = S([0, 0, 0, 1]), Dl = S([0, 0, 1]), Ol = S([0, 0, 3]), Ml = function (e) { for (var t = [], i = 1; i < e.length - 2;)E(e.subarray(i, i + 3), Ol) && (t.push(i + 2), i++), i++; if (0 === t.length) return e; for (var s = e.length - t.length, n = new Uint8Array(s), r = 0, i = 0; i < s; r++, i++)r === t[0] && (r++, t.shift()), n[i] = e[r]; return n }, P = { webm: S([119, 101, 98, 109]), matroska: S([109, 97, 116, 114, 111, 115, 107, 97]), flac: S([102, 76, 97, 67]), ogg: S([79, 103, 103, 83]), ac3: S([11, 119]), riff: S([82, 73, 70, 70]), avi: S([65, 86, 73]), wav: S([87, 65, 86, 69]), "3gp": S([102, 116, 121, 112, 51, 103]), mp4: S([102, 116, 121, 112]), fmp4: S([115, 116, 121, 112]), mov: S([102, 116, 121, 112, 113, 116]), moov: S([109, 111, 111, 118]), moof: S([109, 111, 111, 102]) }, Nl = { aac: function (e) { var t = gl(e); return E(e, [255, 16], { offset: t, mask: [255, 22] }) }, mp3: function (e) { var t = gl(e); return E(e, [255, 2], { offset: t, mask: [255, 6] }) }, webm: function (e) { e = vl(e, [kl.EBML, kl.DocType])[0]; return E(e, P.webm) }, mkv: function (e) { e = vl(e, [kl.EBML, kl.DocType])[0]; return E(e, P.matroska) }, mp4: function (e) { return !Nl["3gp"](e) && !Nl.mov(e) && (!!(E(e, P.mp4, { offset: 4 }) || E(e, P.fmp4, { offset: 4 }) || E(e, P.moof, { offset: 4 }) || E(e, P.moov, { offset: 4 })) || void 0) }, mov: function (e) { return E(e, P.mov, { offset: 4 }) }, "3gp": function (e) { return E(e, P["3gp"], { offset: 4 }) }, ac3: function (e) { var t = gl(e); return E(e, P.ac3, { offset: t }) }, ts: function (e) { if (e.length < 189 && 1 <= e.length) return 71 === e[0]; for (var t = 0; t + 188 < e.length && t < 188;) { if (71 === e[t] && 71 === e[t + 188]) return !0; t += 1 } return !1 }, flac: function (e) { var t = gl(e); return E(e, P.flac, { offset: t }) }, ogg: function (e) { return E(e, P.ogg) }, avi: function (e) { return E(e, P.riff) && E(e, P.avi, { offset: 8 }) }, wav: function (e) { return E(e, P.riff) && E(e, P.wav, { offset: 8 }) }, h264: function (e) { return bl(e, "h264", 7, 3).length }, h265: function (e) { return bl(e, "h265", [32, 33], 3).length } }, Rl = Object.keys(Nl).filter(function (e) { return "ts" !== e && "h264" !== e && "h265" !== e }).concat(["ts", "h264", "h265"]), Ul = (Rl.forEach(function (e) { var t = Nl[e]; Nl[e] = function (e) { return t(S(e)) } }), Nl), Bl = 9e4;
  /*! @name @tm_videojs/http-streaming @version 3.3.1 @license Apache-2.0 */
  const Fl = function (e, t) { if (/^[a-z]+:/i.test(t)) return t; /^data:/.test(e) && (e = window.location && window.location.href || ""); var i = "function" == typeof window.URL, s = /^\/\//.test(e), n = !window.location && !/\/\//i.test(e); return i ? e = new window.URL(e, window.location || _r) : /\/\//i.test(e) || (e = yr.buildAbsoluteURL(window.location && window.location.href || "", e)), i ? (i = new URL(t, e), n ? i.href.slice(_r.length) : s ? i.href.slice(i.protocol.length) : i.href) : yr.buildAbsoluteURL(e, t) }, jl = (e, t) => t && t.responseURL && e !== t.responseURL ? t.responseURL : e, Hl = e => T.log.debug ? T.log.debug.bind(T, "VHS:", e + " >") : function () { }; function D(...e) { var t = T.obj || T; return (t.merge || t.mergeOptions).apply(t, e) } function Vl(...e) { var t = T.time || T; return (t.createTimeRanges || t.createTimeRanges).apply(t, e) } function ql(e, i) { return Ql(e, function (e, t) { return e - Yl <= i && t + Yl >= i }) } function zl(e, t) { return Ql(e, function (e) { return e - Kl >= t }) } function $l(e) { if (e && e.length && e.end) return e.end(e.length - 1) } function Wl(t, i) { let s = 0; if (t && t.length) for (let e = 0; e < t.length; e++) { var n = t.start(e), r = t.end(e); r < i || (s += n < i && i <= r ? r - i : r - n) } return s } function Gl({ defaultDuration: t, durationList: i, startIndex: s, endIndex: n }) { let r = 0; if (n < s && ([s, n] = [n, s]), s < 0) { for (let e = s; e < Math.min(0, n); e++)r += t; s = 0 } for (let e = s; e < n; e++)r += i[e].duration; return r } function Xl(e, t, i, s) { if (!e || !e.segments) return null; if (e.endList) return ld(e); if (null === t) return null; t = t || 0; let n = od(e, e.mediaSequence + e.segments.length, t); return i && (s = "number" == typeof s ? s : nd(null, e), n -= s), Math.max(0, n) } const Kl = 1 / 30, Yl = 3 * Kl, Ql = function (e, t) { var i = []; let s; if (e && e.length) for (s = 0; s < e.length; s++)t(e.start(s), e.end(s)) && i.push([e.start(s), e.end(s)]); return Vl(i) }, Jl = t => { var i = []; if (!t || !t.length) return ""; for (let e = 0; e < t.length; e++)i.push(t.start(e) + " => " + t.end(e)); return i.join(", ") }, Zl = t => { var i = []; for (let e = 0; e < t.length; e++)i.push({ start: t.start(e), end: t.end(e) }); return i }, ed = (t, e) => { if (!e.preload) return e.duration; let i = 0; return (e.parts || []).forEach(function (e) { i += e.duration }), (e.preloadHints || []).forEach(function (e) { "PART" === e.type && (i += t.partTargetDuration) }), i }, td = e => (e.segments || []).reduce((i, s, n) => (s.parts ? s.parts.forEach(function (e, t) { i.push({ duration: e.duration, segmentIndex: n, partIndex: t, part: e, segment: s }) }) : i.push({ duration: s.duration, segmentIndex: n, partIndex: null, segment: s, part: null }), i), []), id = e => { e = e.segments && e.segments.length && e.segments[e.segments.length - 1]; return e && e.parts || [] }, sd = ({ preloadSegment: e }) => { var t; if (e) return { parts: e, preloadHints: t } = e, (t || []).reduce((e, t) => e + ("PART" === t.type ? 1 : 0), 0) + (e && e.length ? e.length : 0) }, nd = (e, t) => { return t.endList ? 0 : e && e.suggestedPresentationDelay ? e.suggestedPresentationDelay : (e = 0 < id(t).length) && t.serverControl && t.serverControl.partHoldBack ? t.serverControl.partHoldBack : e && t.partTargetDuration ? 3 * t.partTargetDuration : t.serverControl && t.serverControl.holdBack ? t.serverControl.holdBack : t.targetDuration ? 3 * t.targetDuration : 0 }, rd = function (e, t) { let i = 0, s = t - e.mediaSequence, n = e.segments[s]; if (n) { if ("undefined" != typeof n.start) return { result: n.start, precise: !0 }; if ("undefined" != typeof n.end) return { result: n.end - n.duration, precise: !0 } } for (; s--;) { if ("undefined" != typeof (n = e.segments[s]).end) return { result: i + n.end, precise: !0 }; if (i += ed(e, n), "undefined" != typeof n.start) return { result: i + n.start, precise: !0 } } return { result: i, precise: !1 } }, ad = function (e, t) { let i = 0; var s; let n = t - e.mediaSequence; for (; n < e.segments.length; n++) { if ("undefined" != typeof (s = e.segments[n]).start) return { result: s.start - i, precise: !0 }; if (i += ed(e, s), "undefined" != typeof s.end) return { result: s.end - i, precise: !0 } } return { result: -1, precise: !1 } }, od = function (e, t, i) { var s; return (t = "undefined" == typeof t ? e.mediaSequence + e.segments.length : t) < e.mediaSequence ? 0 : (s = rd(e, t)).precise ? s.result : (e = ad(e, t)).precise ? e.result : s.result + i }, ld = function (e, t, i) { if (!e) return 0; if ("number" != typeof i && (i = 0), "undefined" == typeof t) { if (e.totalDuration) return e.totalDuration; if (!e.endList) return window.Infinity } return od(e, t, i) }; function dd(e) { return e.excludeUntil && e.excludeUntil > Date.now() } function hd(e) { return e.excludeUntil && e.excludeUntil === 1 / 0 } function ud(e) { var t = dd(e); return !e.disabled && !t } function cd(e, t) { return t.attributes && t.attributes[e] } function pd(e, t) { var i = e && e.mediaGroups && e.mediaGroups.AUDIO || {}; let s = !1; for (const n in i) { for (const r in i[n]) if (s = t(i[n][r])) break; if (s) break } return !!s } const md = (e, t) => { if (1 === e.playlists.length) return !0; const i = t.attributes.BANDWIDTH || Number.MAX_VALUE; return 0 === e.playlists.filter(e => !!ud(e) && (e.attributes.BANDWIDTH || 0) < i).length }, gd = (e, t) => !(!e && !t || !e && t || e && !t || e !== t && (!e.id || !t.id || e.id !== t.id) && (!e.resolvedUri || !t.resolvedUri || e.resolvedUri !== t.resolvedUri) && (!e.uri || !t.uri || e.uri !== t.uri)), fd = t => { if (!t || !t.playlists || !t.playlists.length) return pd(t, e => e.playlists && e.playlists.length || e.uri); for (let e = 0; e < t.playlists.length; e++) { const s = t.playlists[e]; var i = s.attributes && s.attributes.CODECS; if (!i || !i.split(",").every(e => xr(e))) { i = pd(t, e => gd(s, e)); if (!i) return !1 } } return !0 }; var yd = { liveEdgeDelay: nd, duration: ld, seekable: function (e, t, i) { var s = t || 0, e = Xl(e, t, !0, i); return null === e ? Vl() : Vl(s, e) }, getMediaInfoForTime: function ({ playlist: t, currentTime: i, startingSegmentIndex: s, startingPartIndex: n, startTime: r, exactManifestTimings: a }) { let o = i - r; var l = td(t); let d = 0; for (let e = 0; e < l.length; e++) { var h = l[e]; if (s === h.segmentIndex && ("number" != typeof n || "number" != typeof h.partIndex || n === h.partIndex)) { d = e; break } } if (o < 0) { if (0 < d) for (let e = d - 1; 0 <= e; e--) { var u = l[e]; if (o += u.duration, a) { if (o < 0) continue } else if (o + Kl <= 0) continue; return { partIndex: u.partIndex, segmentIndex: u.segmentIndex, startTime: r - Gl({ defaultDuration: t.targetDuration, durationList: l, startIndex: d, endIndex: e }) } } return { partIndex: l[0] && l[0].partIndex || null, segmentIndex: l[0] && l[0].segmentIndex || 0, startTime: i } } if (d < 0) { for (let e = d; e < 0; e++)if ((o -= t.targetDuration) < 0) return { partIndex: l[0] && l[0].partIndex || null, segmentIndex: l[0] && l[0].segmentIndex || 0, startTime: i }; d = 0 } for (let e = d; e < l.length; e++) { var c = l[e]; if (o -= c.duration, a) { if (0 < o) continue } else if (0 <= o - Kl) continue; return { partIndex: c.partIndex, segmentIndex: c.segmentIndex, startTime: r + Gl({ defaultDuration: t.targetDuration, durationList: l, startIndex: d, endIndex: e }) } } return { segmentIndex: l[l.length - 1].segmentIndex, partIndex: l[l.length - 1].partIndex, startTime: i } }, isEnabled: ud, isDisabled: function (e) { return e.disabled }, isExcluded: dd, isIncompatible: hd, playlistEnd: Xl, isAes: function (t) { for (let e = 0; e < t.segments.length; e++)if (t.segments[e].key) return !0; return !1 }, hasAttribute: cd, estimateSegmentRequestTime: function (e, t, i, s = 0) { return cd("BANDWIDTH", i) ? (e * i.attributes.BANDWIDTH - 8 * s) / t : NaN }, isLowestEnabledRendition: md, isAudioOnly: fd, playlistMatch: gd, segmentDurationWithParts: ed }; const _d = T["log"], vd = (e, t) => e + "-" + t, bd = (n, r) => { n.mediaGroups && ["AUDIO", "SUBTITLES"].forEach(e => { if (n.mediaGroups[e]) for (const i in n.mediaGroups[e]) for (const s in n.mediaGroups[e][i]) { var t = n.mediaGroups[e][i][s]; r(t, e, i, s) } }) }, Td = ({ playlist: e, uri: t, id: i }) => { e.id = i, e.playlistErrors_ = 0, t && (e.uri = t), e.attributes = e.attributes || {} }, Sd = (o, e, l = (e, t, i) => `placeholder-uri-${e}-${t}-` + i) => { o.uri = e; for (let e = 0; e < o.playlists.length; e++) { var t; o.playlists[e].uri || (t = "placeholder-uri-" + e, o.playlists[e].uri = t) } const i = fd(o); bd(o, (e, n, r, a) => { if (!e.playlists || !e.playlists.length) { if (i && "AUDIO" === n && !e.uri) for (let e = 0; e < o.playlists.length; e++) { var t = o.playlists[e]; if (t.attributes && t.attributes.AUDIO && t.attributes.AUDIO === r) return } e.playlists = [yi({}, e)] } e.playlists.forEach(function (e, t) { var i = l(n, r, a, e), s = vd(t, i); e.uri ? e.resolvedUri = e.resolvedUri || Fl(o.uri, e.uri) : (e.uri = 0 === t ? i : s, e.resolvedUri = e.uri), e.id = e.id || s, e.attributes = e.attributes || {}, o.playlists[e.id] = e, o.playlists[e.uri] = e }) }); { var s = o; let e = s.playlists.length; for (; e--;) { var n = s.playlists[e]; Td({ playlist: n, id: vd(e, n.uri) }), n.resolvedUri = Fl(s.uri, n.uri), s.playlists[n.id] = n, (s.playlists[n.uri] = n).attributes.BANDWIDTH || _d.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.") } } var r; r = o, bd(r, e => { e.uri && (e.resolvedUri = Fl(r.uri, e.uri)) }) }; Rn = T.EventTarget; function wd(e) { var t = e.segments || [], i = e.preloadSegment; if (i && i.parts && i.parts.length) { if (i.preloadHints) for (let e = 0; e < i.preloadHints.length; e++)if ("MAP" === i.preloadHints[e].type) return t; i.duration = e.targetDuration, i.preload = !0, t.push(i) } return t } const Ed = (t, i) => { if (!t) return i; var s = D(t, i); if (t.preloadHints && !i.preloadHints && delete s.preloadHints, t.parts && !i.parts) delete s.parts; else if (t.parts && i.parts) for (let e = 0; e < i.parts.length; e++)t.parts && t.parts[e] && (s.parts[e] = D(t.parts[e], i.parts[e])); return !t.skipped && i.skipped && (s.skipped = !1), t.preload && !i.preload && (s.preload = !1), s }, Cd = (e, t) => { !e.resolvedUri && e.uri && (e.resolvedUri = Fl(t, e.uri)), e.key && !e.key.resolvedUri && (e.key.resolvedUri = Fl(t, e.key.uri)), e.map && !e.map.resolvedUri && (e.map.resolvedUri = Fl(t, e.map.uri)), e.map && e.map.key && !e.map.key.resolvedUri && (e.map.key.resolvedUri = Fl(t, e.map.key.uri)), e.parts && e.parts.length && e.parts.forEach(e => { e.resolvedUri || (e.resolvedUri = Fl(t, e.uri)) }), e.preloadHints && e.preloadHints.length && e.preloadHints.forEach(e => { e.resolvedUri || (e.resolvedUri = Fl(t, e.uri)) }) }, kd = (e, t) => e === t || e.segments && t.segments && e.segments.length === t.segments.length && e.endList === t.endList && e.mediaSequence === t.mediaSequence && e.preloadSegment === t.preloadSegment, Id = (e, n, t = kd) => { var i = D(e, {}), s = i.playlists[n.id]; if (!s) return null; if (t(s, n)) return null; n.segments = wd(n); const r = D(s, n); if (r.preloadSegment && !n.preloadSegment && delete r.preloadSegment, s.segments) { if (n.skip) { n.segments = n.segments || []; for (let e = 0; e < n.skip.skippedSegments; e++)n.segments.unshift({ skipped: !0 }) } r.segments = ((e, t, i) => { var s = e.slice(), n = t.slice(), r = (i = i || 0, []); let a; for (let e = 0; e < n.length; e++) { var o = s[e + i], l = n[e]; o ? (a = o.map || a, r.push(Ed(o, l))) : (a && !l.map && (l.map = a), r.push(l)) } return r })(s.segments, n.segments, n.mediaSequence - s.mediaSequence) } r.segments.forEach(e => { Cd(e, r.resolvedUri) }); for (let e = 0; e < i.playlists.length; e++)i.playlists[e].id === n.id && (i.playlists[e] = r); return i.playlists[n.id] = r, i.playlists[n.uri] = r, bd(e, (t, e, i, s) => { if (t.playlists) for (let e = 0; e < t.playlists.length; e++)n.id === t.playlists[e].id && (t.playlists[e] = r) }), i }, xd = (e, t) => { var i = e.segments || [], i = i[i.length - 1], s = i && i.parts && i.parts[i.parts.length - 1], s = s && s.duration || i && i.duration; return t && s ? 1e3 * s : 500 * (e.partTargetDuration || e.targetDuration || 10) }; class Ad extends Rn { constructor(e, t, i = {}) { if (super(), !e) throw new Error("A non-empty playlist URL or object is required"); this.logger_ = Hl("PlaylistLoader"); var { withCredentials: i = !1 } = i, e = (this.src = e, this.vhs_ = t, this.withCredentials = i, t.options_); this.customTagParsers = e && e.customTagParsers || [], this.customTagMappers = e && e.customTagMappers || [], this.llhls = e && e.llhls, this.state = "HAVE_NOTHING", this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this), this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_) } handleMediaupdatetimeout_() { if ("HAVE_METADATA" === this.state) { var t = this.media(); let e = Fl(this.main.uri, t.uri); this.llhls && (e = ((e, t) => { if (!t.endList && t.serverControl) { const n = {}; if (t.serverControl.canBlockReload) { var i, s = t["preloadSegment"]; let e = t.mediaSequence + t.segments.length; s && (s = s.parts || [], -1 < (i = sd(t) - 1) && i != s.length - 1 && (n._HLS_part = i), -1 < i || s.length) && e--, n._HLS_msn = e } if (t.serverControl && t.serverControl.canSkipUntil && (n._HLS_skip = t.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(n).length) { const r = new window.URL(e);["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function (e) { n.hasOwnProperty(e) && r.searchParams.set(e, n[e]) }), e = r.toString() } } return e })(e, t)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({ uri: e, withCredentials: this.withCredentials }, (e, t) => { if (this.request) return e ? this.playlistRequestError(this.request, this.media(), "HAVE_METADATA") : void this.haveMetadata({ playlistString: this.request.responseText, url: this.media().uri, id: this.media().id }) }) } } playlistRequestError(e, t, i) { var { uri: t, id: s } = t; this.request = null, i && (this.state = i), this.error = { playlist: this.main.playlists[s], status: e.status, message: `HLS playlist request error at URL: ${t}.`, responseText: e.responseText, code: 500 <= e.status ? 4 : 2 }, this.trigger("error") } parseManifest_({ url: t, manifestString: i }) { { var [{ onwarn: i, oninfo: e, manifestString: s, customTagParsers: n = [], customTagMappers: r = [], llhls: a }] = [{ onwarn: ({ message: e }) => this.logger_(`m3u8-parser warn for ${t}: ` + e), oninfo: ({ message: e }) => this.logger_(`m3u8-parser info for ${t}: ` + e), manifestString: i, customTagParsers: this.customTagParsers, customTagMappers: this.customTagMappers, llhls: this.llhls }]; const o = new Ir, l = (i && o.on("warn", i), e && o.on("info", e), n.forEach(e => o.addParser(e)), r.forEach(e => o.addTagMapper(e)), o.push(s), o.end(), o.manifest); if (a || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function (e) { l.hasOwnProperty(e) && delete l[e] }), l.segments && l.segments.forEach(function (t) { ["parts", "preloadHints"].forEach(function (e) { t.hasOwnProperty(e) && delete t[e] }) })), !l.targetDuration) { let e = 10; l.segments && l.segments.length && (e = l.segments.reduce((e, t) => Math.max(e, t.duration), 0)), i && i("manifest has no targetDuration defaulting to " + e), l.targetDuration = e } return (e = id(l)).length && !l.partTargetDuration && (n = e.reduce((e, t) => Math.max(e, t.duration), 0), i && (i("manifest has no partTargetDuration defaulting to " + n), _d.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), l.partTargetDuration = n), l } } haveMetadata({ playlistString: e, playlistObject: t, url: i, id: s }) { this.request = null, this.state = "HAVE_METADATA"; t = t || this.parseManifest_({ url: i, manifestString: e }), t.lastRequest = Date.now(), Td({ playlist: t, uri: i, id: s }), e = Id(this.main, t); this.targetDuration = t.partTargetDuration || t.targetDuration, this.pendingMedia_ = null, e ? (this.main = e, this.media_ = this.main.playlists[s]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(xd(this.media(), !!e)), this.trigger("loadedplaylist") } dispose() { this.trigger("dispose"), this.stopRequest(), window.clearTimeout(this.mediaUpdateTimeout), window.clearTimeout(this.finalRenditionTimeout), this.off() } stopRequest() { var e; this.request && (e = this.request, this.request = null, e.onreadystatechange = null, e.abort()) } media(i, e) { if (!i) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); if ("string" == typeof i) { if (!this.main.playlists[i]) throw new Error("Unknown playlist URI: " + i); i = this.main.playlists[i] } if (window.clearTimeout(this.finalRenditionTimeout), e) e = (i.partTargetDuration || i.targetDuration) / 2 * 1e3 || 5e3, this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, i, !1), e); else { const s = this.state; var e = !this.media_ || i.id !== this.media_.id, t = this.main.playlists[i.id]; if (t && t.endList || i.endList && i.segments.length) this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = i, e && (this.trigger("mediachanging"), "HAVE_MAIN_MANIFEST" === s ? this.trigger("loadedmetadata") : this.trigger("mediachange")); else if (this.updateMediaUpdateTimeout_(xd(i, !0)), e) { if (this.state = "SWITCHING_MEDIA", this.request) { if (i.resolvedUri === this.request.url) return; this.request.onreadystatechange = null, this.request.abort(), this.request = null } this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = i, this.request = this.vhs_.xhr({ uri: i.resolvedUri, withCredentials: this.withCredentials }, (e, t) => { if (this.request) { if (i.lastRequest = Date.now(), i.resolvedUri = jl(i.resolvedUri, t), e) return this.playlistRequestError(this.request, i, s); this.haveMetadata({ playlistString: t.responseText, url: i.uri, id: i.id }), "HAVE_MAIN_MANIFEST" === s ? this.trigger("loadedmetadata") : this.trigger("mediachange") } }) } } } pause() { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA") } load(e) { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null); var t = this.media(); e ? (e = t ? (t.partTargetDuration || t.targetDuration) / 2 * 1e3 : 5e3, this.mediaUpdateTimeout = window.setTimeout(() => { this.mediaUpdateTimeout = null, this.load() }, e)) : this.started ? t && !t.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist") : this.start() } updateMediaUpdateTimeout_(e) { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.media() && !this.media().endList && (this.mediaUpdateTimeout = window.setTimeout(() => { this.mediaUpdateTimeout = null, this.trigger("mediaupdatetimeout"), this.updateMediaUpdateTimeout_(e) }, e)) } start() { this.started = !0, "object" == typeof this.src ? (this.src.uri || (this.src.uri = window.location.href), this.src.resolvedUri = this.src.uri, setTimeout(() => { this.setupInitialPlaylist(this.src) }, 0)) : this.request = this.vhs_.xhr({ uri: this.src, withCredentials: this.withCredentials }, (e, t) => { if (this.request) { if (this.request = null, e) return this.error = { status: t.status, message: `HLS playlist request error at URL: ${this.src}.`, responseText: t.responseText, code: 2 }, "HAVE_NOTHING" === this.state && (this.started = !1), this.trigger("error"); this.src = jl(this.src, t); e = this.parseManifest_({ manifestString: t.responseText, url: this.src }); this.setupInitialPlaylist(e) } }) } srcUri() { return "string" == typeof this.src ? this.src : this.src.uri } setupInitialPlaylist(e) { var t, i, s, n; this.state = "HAVE_MAIN_MANIFEST", e.playlists ? (this.main = e, Sd(this.main, this.srcUri()), e.playlists.forEach(t => { t.segments = wd(t), t.segments.forEach(e => { Cd(e, t.resolvedUri) }) }), this.trigger("loadedplaylist"), this.request || this.media(this.main.playlists[0])) : (t = this.srcUri() || window.location.href, this.main = (i = t, s = vd(0, i), (n = { mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: window.location.href, resolvedUri: window.location.href, playlists: [{ uri: i, id: s, resolvedUri: i, attributes: {} }] }).playlists[s] = n.playlists[0], n.playlists[i] = n.playlists[0], n), this.haveMetadata({ playlistObject: e, url: t, id: this.main.playlists[0].id }), this.trigger("loadedmetadata")) } } function Ld(e, t, i, s) { var n = "arraybuffer" === e.responseType ? e.response : e.responseText; !t && n && (e.responseTime = Date.now(), e.roundTripTime = e.responseTime - e.requestTime, e.bytesReceived = n.byteLength || n.length, e.bandwidth || (e.bandwidth = Math.floor(e.bytesReceived / e.roundTripTime * 8 * 1e3))), i.headers && (e.responseHeaders = i.headers), t && "ETIMEDOUT" === t.code && (e.timedout = !0), s(t = t || e.aborted || 200 === i.statusCode || 206 === i.statusCode || 0 === i.statusCode ? t : new Error("XHR Failed with a response of: " + (e && (n || e.responseText))), e) } function Pd() { function d(e, a) { e = D({ timeout: 45e3 }, e); var t = d.beforeRequest || T.Vhs.xhr.beforeRequest, i = d._requestCallbackSet || T.Vhs.xhr._requestCallbackSet || new Set; const o = d._responseCallbackSet || T.Vhs.xhr._responseCallbackSet; t && "function" == typeof t && (T.log.warn("beforeRequest is deprecated, use onRequest instead."), i.add(t)); var s = !0 === T.Vhs.xhr.original ? Bd : T.Vhs.xhr, n = ((e, i) => { if (e && e.size) { let t = i; return e.forEach(e => { t = e(t) }), t } })(i, e); i.delete(t); const l = s(n || e, function (e, t) { var i, s, n, r; return i = o, s = l, n = e, r = t, i && i.size && i.forEach(e => { e(s, n, r) }), Ld(l, e, t, a) }), r = l.abort; return l.abort = function () { return l.aborted = !0, r.apply(l, arguments) }, l.uri = e.uri, l.requestTime = Date.now(), l } return d.original = !0, d } function Dd(e) { var t = {}; return e.byterange && (t.Range = function (e) { let t; return "bytes=" + e.offset + "-" + (t = "bigint" == typeof e.offset || "bigint" == typeof e.length ? window.BigInt(e.offset) + window.BigInt(e.length) - window.BigInt(1) : e.offset + e.length - 1) }(e.byterange)), t } function Od(e, t) { return e = e.toString(16), "00".substring(0, 2 - e.length) + e + (t % 2 ? " " : "") } function Md(e) { return 32 <= e && e < 126 ? String.fromCharCode(e) : "." } function Nd(i) { const s = {}; return Object.keys(i).forEach(e => { var t = i[e]; zr(t) ? s[e] = { bytes: t.buffer, byteOffset: t.byteOffset, byteLength: t.byteLength } : s[e] = t }), s } function Rd(e) { var t = e.byterange || { length: 1 / 0, offset: 0 }; return [t.length, t.offset, e.resolvedUri].join(",") } function Ud(e) { return e.resolvedUri } const Bd = T["xhr"], Fd = e => { var t, i, s = Array.prototype.slice.call(e); let n = ""; for (let e = 0; e < s.length / 16; e++)t = s.slice(16 * e, 16 * e + 16).map(Od).join(""), i = s.slice(16 * e, 16 * e + 16).map(Md).join(""), n += t + " " + i + "\n"; return n }; Nn = Object.freeze({ __proto__: null, createTransferableMessage: Nd, initSegmentId: Rd, segmentKeyId: Ud, hexDump: Fd, tagDump: ({ bytes: e }) => Fd(e), textRanges: e => { let t = "", i; for (i = 0; i < e.length; i++)t += (s = e, n = i, s.start(n) + "-" + s.end(n) + " "); var s, n; return t } }); const jd = .25, Hd = e => e.transmuxedPresentationEnd - e.transmuxedPresentationStart - e.transmuxerPrependedSeconds, Vd = ({ playlist: e, time: t = void 0, callback: i }) => { var s, n; if (i) return e && void 0 !== t ? (e = ((t, i) => { if (!i || !i.segments || 0 === i.segments.length) return null; let s = 0, n; for (let e = 0; e < i.segments.length && (n = i.segments[e], !(t <= (s = n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationEnd : s + n.duration))); e++); var e = i.segments[i.segments.length - 1]; if (e.videoTimingInfo && e.videoTimingInfo.transmuxedPresentationEnd < t) return null; if (t > s) { if (t > s + e.duration * jd) return null; n = e } return { segment: n, estimatedStart: n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationStart : s - n.duration, type: n.videoTimingInfo ? "accurate" : "estimate" } })(t, e)) ? "estimate" === e.type ? i({ message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again", seekTime: e.estimatedStart }) : (s = { mediaSeconds: t }, t = t, (n = (e = e.segment).dateTimeObject ? (n = e.videoTimingInfo.transmuxerPrependedSeconds, t = t - (e.videoTimingInfo.transmuxedPresentationStart + n), new Date(e.dateTimeObject.getTime() + 1e3 * t)) : null) && (s.programDateTime = n.toISOString()), i(null, s)) : i({ message: "valid programTime was not found" }) : i({ message: "getProgramTime: playlist and time must be provided" }); throw new Error("getProgramTime: callback must be provided") }, qd = ({ programTime: e, playlist: t, retryCount: i = 2, seekTo: s, pauseAfterSeek: n = !0, tech: r, callback: a }) => { var o, l, d; if (a) return "undefined" != typeof e && t && s ? t.endList || r.hasStarted_ ? (t => { if (!t.segments || 0 === t.segments.length) return !1; for (let e = 0; e < t.segments.length; e++)if (!t.segments[e].dateTimeObject) return !1; return !0 })(t) ? (d = ((e, t) => { let i; try { i = new Date(e) } catch (e) { return null } if (!t || !t.segments || 0 === t.segments.length) return null; let s = t.segments[0]; if (i < s.dateTimeObject) return null; for (let e = 0; e < t.segments.length - 1; e++) { s = t.segments[e]; var n = t.segments[e + 1].dateTimeObject; if (i < n) break } var e = t.segments[t.segments.length - 1], r = e.dateTimeObject, a = e.videoTimingInfo ? Hd(e.videoTimingInfo) : e.duration + e.duration * jd, a = new Date(r.getTime() + 1e3 * a); return i > a ? null : { segment: s = i > r ? e : s, estimatedStart: s.videoTimingInfo ? s.videoTimingInfo.transmuxedPresentationStart : yd.duration(t, t.mediaSequence + t.segments.indexOf(s)), type: s.videoTimingInfo ? "accurate" : "estimate" } })(e, t)) ? (l = ((e, t) => { let i, s; try { i = new Date(e), s = new Date(t) } catch (e) { } e = i.getTime(); return (s.getTime() - e) / 1e3 })((o = d.segment).dateTimeObject, e), "estimate" === d.type ? 0 === i ? a({ message: e + " is not buffered yet. Try again" }) : (s(d.estimatedStart + l), void r.one("seeked", () => { qd({ programTime: e, playlist: t, retryCount: i - 1, seekTo: s, pauseAfterSeek: n, tech: r, callback: a }) })) : (d = o.start + l, r.one("seeked", () => a(null, r.currentTime())), n && r.pause(), void s(d))) : a({ message: e + " was not found in the stream" }) : a({ message: "programDateTime tags must be provided in the manifest " + t.resolvedUri }) : a({ message: "player must be playing a live stream to start buffering" }) : a({ message: "seekToProgramTime: programTime, seekTo and playlist must be provided" }); throw new Error("seekToProgramTime: callback must be provided") }, zd = (e, t) => { if (4 === e.readyState) return t() }, $d = (e, t, n) => { let s = [], r, a = !1; function o(e, t, i, s) { return t.abort(), a = !0, n(e, t, i, s) } function i(e, t) { var i; if (!a) return e ? o(e, t, "", s) : (i = t.responseText.substring(s && s.byteLength || 0, t.responseText.length), s = function () { for (var e, t, i, s = arguments.length, n = new Array(s), r = 0; r < s; r++)n[r] = arguments[r]; return (n = n.filter(function (e) { return e && (e.byteLength || e.length) && "string" != typeof e })).length <= 1 ? S(n[0]) : (e = n.reduce(function (e, t, i) { return e + (t.byteLength || t.length) }, 0), t = new Uint8Array(e), i = 0, n.forEach(function (e) { e = S(e), t.set(e, i), i += e.byteLength }), t) }(s, Or(i, !0)), r = r || gl(s), s.length < 10 || r && s.length < r + 2 || "ts" === (i = Tl(s)) && s.length < 188 || !i && s.length < 376 ? zd(t, () => o(e, t, "", s)) : o(null, t, i, s)) } const l = t({ uri: e, beforeSend(e) { e.overrideMimeType("text/plain; charset=x-user-defined"), e.addEventListener("progress", function ({ }) { return Ld(e, null, { statusCode: e.status }, i) }) } }, function (e, t) { return Ld(l, e, t, i) }); return l }; Ri = T.EventTarget; function Wd(t, i) { if (!kd(t, i)) return !1; if (t.sidx && i.sidx && (t.sidx.offset !== i.sidx.offset || t.sidx.length !== i.sidx.length)) return !1; if (!t.sidx && i.sidx || t.sidx && !i.sidx) return !1; if (t.segments && !i.segments || !t.segments && i.segments) return !1; if (t.segments || i.segments) for (let e = 0; e < t.segments.length; e++) { var s = t.segments[e], n = i.segments[e]; if (s.uri !== n.uri) return !1; if (s.byterange || n.byterange) { s = s.byterange, n = n.byterange; if (s && !n || !s && n) return !1; if (s.offset !== n.offset || s.length !== n.length) return !1 } } return !0 } const Gd = (e, t, i, s) => { return `placeholder-uri-${e}-${t}-` + (s.attributes.NAME || i) }, Xd = ({ mainXml: e, srcUrl: t, clientOffset: i, sidxMapping: s, previousManifest: n }) => { e = e, i = { manifestUri: t, clientOffset: i, sidxMapping: s, previousManifest: n }, e = cl(pl(e), i), s = sl(e.representationInfo); n = Yo({ dashPlaylists: s, locations: e.locations, sidxMapping: i.sidxMapping, previousManifest: i.previousManifest, eventStream: e.eventStream }); return Sd(n, t, Gd), n }, Kd = (e, t, i) => { let a = !0, o = D(e, { duration: t.duration, minimumUpdatePeriod: t.minimumUpdatePeriod, timelineStarts: t.timelineStarts }); for (let e = 0; e < t.playlists.length; e++) { var s = t.playlists[e], n = (s.sidx && (n = Ho(s.sidx), i) && i[n] && i[n].sidx && No(s, i[n].sidx, s.sidx.resolvedUri), Id(o, s, Wd)); n && (o = n, a = !1) } var r, l; return bd(t, (e, t, i, s) => { var n, r; e.playlists && e.playlists.length && (n = e.playlists[0].id, r = Id(o, e.playlists[0], Wd)) && (s in (o = r).mediaGroups[t][i] || (o.mediaGroups[t][i][s] = e), o.mediaGroups[t][i][s].playlists[0] = o.playlists[n], a = !1) }), r = o, l = t, bd(r, (e, t, i, s) => { s in l.mediaGroups[t][i] || delete r.mediaGroups[t][i][s] }), (a = t.minimumUpdatePeriod === e.minimumUpdatePeriod && a) ? null : o }, Yd = (e, t) => { return (Boolean(!e.map && !t.map) || Boolean(e.map && t.map && e.map.byterange.offset === t.map.byterange.offset && e.map.byterange.length === t.map.byterange.length)) && e.uri === t.uri && e.byterange.offset === t.byterange.offset && e.byterange.length === t.byterange.length }, Qd = (e, t) => { var i = {}; for (const a in e) { var s = e[a].sidx; if (s) { var n = Ho(s); if (!t[n]) break; var r = t[n].sidxInfo; Yd(r, s) && (i[n] = t[n]) } } return i }; class Jd extends Ri { constructor(e, t, i = {}, s) { super(), this.mainPlaylistLoader_ = s || this, s || (this.isMain_ = !0); var { withCredentials: s = !1 } = i; if (this.vhs_ = t, this.withCredentials = s, this.addMetadataToTextTrack = i.addMetadataToTextTrack, !e) throw new Error("A non-empty playlist URL or object is required"); this.on("minimumUpdatePeriod", () => { this.refreshXml_() }), this.on("mediaupdatetimeout", () => { this.refreshMedia_(this.media().id) }), this.state = "HAVE_NOTHING", this.loadedPlaylists_ = {}, this.logger_ = Hl("DashPlaylistLoader"), this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = e, this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = e } requestErrored_(e, t, i) { return !this.request || (this.request = null, e ? (this.error = "object" != typeof e || e instanceof Error ? { status: t.status, message: "DASH request error at URL: " + t.uri, response: t.response, code: 2 } : e, i && (this.state = i), this.trigger("error"), !0) : void 0) } addSidxSegments_(a, s, n) { const r = a.sidx && Ho(a.sidx); if (a.sidx && r && !this.mainPlaylistLoader_.sidxMapping_[r]) { const o = jl(a.sidx.resolvedUri), l = (t, i) => { if (!this.requestErrored_(t, i, s)) { t = this.mainPlaylistLoader_.sidxMapping_; let e; try { e = El(S(i.response).subarray(8)) } catch (e) { return void this.requestErrored_(e, i, s) } return t[r] = { sidxInfo: a.sidx, sidx: e }, No(a, e, a.sidx.resolvedUri), n(!0) } }; this.request = $d(o, this.vhs_.xhr, (e, t, i, s) => { var n, r; return e ? l(e, t) : i && "mp4" === i ? ({ offset: n, length: r } = a.sidx.byterange, s.length >= r + n ? l(e, { response: s.subarray(n, n + r), status: t.status, uri: t.uri }) : void (this.request = this.vhs_.xhr({ uri: o, responseType: "arraybuffer", headers: Dd({ byterange: a.sidx.byterange }) }, l))) : l({ status: t.status, message: `Unsupported ${i || "unknown"} container type for sidx segment at URL: ` + o, response: "", playlist: a, internal: !0, playlistExclusionDuration: 1 / 0, code: 2 }, t) }) } else this.mediaRequest_ = window.setTimeout(() => n(!1), 0) } dispose() { this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, window.clearTimeout(this.minimumUpdatePeriodTimeout_), window.clearTimeout(this.mediaRequest_), window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.off() } hasPendingRequest() { return this.request || this.mediaRequest_ } stopRequest() { var e; this.request && (e = this.request, this.request = null, e.onreadystatechange = null, e.abort()) } media(t) { if (!t) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); const i = this.state; if ("string" == typeof t) { if (!this.mainPlaylistLoader_.main.playlists[t]) throw new Error("Unknown playlist URI: " + t); t = this.mainPlaylistLoader_.main.playlists[t] } var e = !this.media_ || t.id !== this.media_.id; e && this.loadedPlaylists_[t.id] && this.loadedPlaylists_[t.id].endList ? (this.state = "HAVE_METADATA", this.media_ = t, e && (this.trigger("mediachanging"), this.trigger("mediachange"))) : e && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(t, i, e => { this.haveMetadata({ startingState: i, playlist: t }) })) } haveMetadata({ startingState: e, playlist: t }) { this.state = "HAVE_METADATA", this.loadedPlaylists_[t.id] = t, this.mediaRequest_ = null, this.refreshMedia_(t.id), "HAVE_MAIN_MANIFEST" === e ? this.trigger("loadedmetadata") : this.trigger("mediachange") } pause() { this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMain_ && (window.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_), this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), "HAVE_NOTHING" === this.state && (this.started = !1) } load(e) { window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null; var t = this.media(); e ? (e = t ? t.targetDuration / 2 * 1e3 : 5e3, this.mediaUpdateTimeout = window.setTimeout(() => this.load(), e)) : this.started ? t && !t.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist") : this.start() } start() { this.started = !0, this.isMain_ ? this.requestMain_((e, t) => { this.haveMain_(), this.hasPendingRequest() || this.media_ || this.media(this.mainPlaylistLoader_.main.playlists[0]) }) : this.mediaRequest_ = window.setTimeout(() => this.haveMain_(), 0) } requestMain_(s) { this.request = this.vhs_.xhr({ uri: this.mainPlaylistLoader_.srcUrl, withCredentials: this.withCredentials }, (e, t) => { if (this.requestErrored_(e, t)) "HAVE_NOTHING" === this.state && (this.started = !1); else { const i = t.responseText !== this.mainPlaylistLoader_.mainXml_; if (this.mainPlaylistLoader_.mainXml_ = t.responseText, t.responseHeaders && t.responseHeaders.date ? this.mainLoaded_ = Date.parse(t.responseHeaders.date) : this.mainLoaded_ = Date.now(), this.mainPlaylistLoader_.srcUrl = jl(this.mainPlaylistLoader_.srcUrl, t), !i) return s(t, i); this.handleMain_(), this.syncClientServerClock_(() => s(t, i)) } }) } syncClientServerClock_(s) { const n = ml(this.mainPlaylistLoader_.mainXml_); return null === n ? (this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), s()) : "DIRECT" === n.method ? (this.mainPlaylistLoader_.clientOffset_ = n.value - Date.now(), s()) : void (this.request = this.vhs_.xhr({ uri: Fl(this.mainPlaylistLoader_.srcUrl, n.value), method: n.method, withCredentials: this.withCredentials }, (t, i) => { if (this.request) { if (t) return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), s(); let e; e = "HEAD" === n.method ? i.responseHeaders && i.responseHeaders.date ? Date.parse(i.responseHeaders.date) : this.mainLoaded_ : Date.parse(i.responseText), this.mainPlaylistLoader_.clientOffset_ = e - Date.now(), s() } })) } haveMain_() { this.state = "HAVE_MAIN_MANIFEST", this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_) } handleMain_() { this.mediaRequest_ = null; var e = this.mainPlaylistLoader_.main; let t = Xd({ mainXml: this.mainPlaylistLoader_.mainXml_, srcUrl: this.mainPlaylistLoader_.srcUrl, clientOffset: this.mainPlaylistLoader_.clientOffset_, sidxMapping: this.mainPlaylistLoader_.sidxMapping_, previousManifest: e }); e && (t = Kd(e, t, this.mainPlaylistLoader_.sidxMapping_)), this.mainPlaylistLoader_.main = t || e; var i = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0]; return i && i !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = i), (!e || t && t.minimumUpdatePeriod !== e.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), this.addEventStreamToMetadataTrack_(t), Boolean(t) } updateMinimumUpdatePeriodTimeout_() { var e = this.mainPlaylistLoader_; e.createMupOnMedia_ && (e.off("loadedmetadata", e.createMupOnMedia_), e.createMupOnMedia_ = null), e.minimumUpdatePeriodTimeout_ && (window.clearTimeout(e.minimumUpdatePeriodTimeout_), e.minimumUpdatePeriodTimeout_ = null); let t = e.main && e.main.minimumUpdatePeriod; 0 === t && (e.media() ? t = 1e3 * e.media().targetDuration : (e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_, e.one("loadedmetadata", e.createMupOnMedia_))), "number" != typeof t || t <= 0 ? t < 0 && this.logger_(`found invalid minimumUpdatePeriod of ${t}, not setting a timeout`) : this.createMUPTimeout_(t) } createMUPTimeout_(e) { const t = this.mainPlaylistLoader_; t.minimumUpdatePeriodTimeout_ = window.setTimeout(() => { t.minimumUpdatePeriodTimeout_ = null, t.trigger("minimumUpdatePeriod"), t.createMUPTimeout_(e) }, e) } refreshXml_() { this.requestMain_((e, t) => { t && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]), this.mainPlaylistLoader_.sidxMapping_ = ((e, n) => { let r = Qd(e.playlists, n); return bd(e, (e, t, i, s) => { e.playlists && e.playlists.length && (e = e.playlists, r = D(r, Qd(e, n))) }), r })(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_), this.addSidxSegments_(this.media(), this.state, e => { this.refreshMedia_(this.media().id) })) }) } refreshMedia_(e) { if (!e) throw new Error("refreshMedia_ must take a media id"); this.media_ && this.isMain_ && this.handleMain_(); var t = this.mainPlaylistLoader_.main.playlists; const i = !this.media_ || this.media_ !== t[e]; if (i ? this.media_ = t[e] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) { const s = () => { this.media().endList || (this.mediaUpdateTimeout = window.setTimeout(() => { this.trigger("mediaupdatetimeout"), s() }, xd(this.media(), Boolean(i)))) }; s() } this.trigger("loadedplaylist") } addEventStreamToMetadataTrack_(e) { e && this.mainPlaylistLoader_.main.eventStream && (e = this.mainPlaylistLoader_.main.eventStream.map(e => ({ cueTime: e.start, frames: [{ data: e.messageData }] })), this.addMetadataToTextTrack("EventStream", e, this.mainPlaylistLoader_.main.duration)) } } var O = { GOAL_BUFFER_LENGTH: 30, MAX_GOAL_BUFFER_LENGTH: 60, BACK_BUFFER_LENGTH: 30, GOAL_BUFFER_LENGTH_RATE: 1, INITIAL_BANDWIDTH: 4194304, BANDWIDTH_VARIANCE: 1.2, BUFFER_LOW_WATER_LINE: 0, MAX_BUFFER_LOW_WATER_LINE: 30, EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16, BUFFER_LOW_WATER_LINE_RATE: 1, BUFFER_HIGH_WATER_LINE: 30 }; function Zd(e) { return e.on = e.addEventListener, e.off = e.removeEventListener, e } const eh = t => { var i = new Uint8Array(new ArrayBuffer(t.length)); for (let e = 0; e < t.length; e++)i[e] = t.charCodeAt(e); return i.buffer }; function th(s) { return function () { const e = function (t) { try { return URL.createObjectURL(new Blob([t], { type: "application/javascript" })) } catch (e) { var i = new BlobBuilder; return i.append(t), URL.createObjectURL(i.getBlob()) } }(s); var t = Zd(new Worker(e)); t.objURL = e; const i = t.terminate; return t.on = t.addEventListener, t.off = t.removeEventListener, t.terminate = function () { return URL.revokeObjectURL(e), i.call(this) }, t } } function ih(e) {
    return `var browserWorkerPolyFill = ${Zd.toString()};
`+ "browserWorkerPolyFill(self);\n" + e
  } function sh(e) { return e.toString().replace(/^function.+?{/, "").slice(0, -1) } var nh = th(ih(sh(function () { function e() { this.init = function () { var r = {}; this.on = function (e, t) { r[e] || (r[e] = []), r[e] = r[e].concat(t) }, this.off = function (e, t) { return !!r[e] && (t = r[e].indexOf(t), r[e] = r[e].slice(), r[e].splice(t, 1), -1 < t) }, this.trigger = function (e) { var t, i, s, n = r[e]; if (n) if (2 === arguments.length) for (i = n.length, t = 0; t < i; ++t)n[t].call(this, arguments[1]); else { for (s = [], t = arguments.length, t = 1; t < arguments.length; ++t)s.push(arguments[t]); for (i = n.length, t = 0; t < i; ++t)n[t].apply(this, s) } }, this.dispose = function () { r = {} } } } var l, R, U, B, F, j, H, V, q, z, $, W, G, X, K, Y, Q, J, Z, ee, d, te, ie, se, ne, re, ae, oe, t, le, de, he, ue, ce, pe, me, ge, fe = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, i = (e.prototype.pipe = function (t) { return this.on("data", function (e) { t.push(e) }), this.on("done", function (e) { t.flush(e) }), this.on("partialdone", function (e) { t.partialFlush(e) }), this.on("endedtimeline", function (e) { t.endTimeline(e) }), this.on("reset", function (e) { t.reset(e) }), t }, e.prototype.push = function (e) { this.trigger("data", e) }, e.prototype.flush = function (e) { this.trigger("done", e) }, e.prototype.partialFlush = function (e) { this.trigger("partialdone", e) }, e.prototype.endTimeline = function (e) { this.trigger("endedtimeline", e) }, e.prototype.reset = function (e) { this.trigger("reset", e) }, e), ye = Math.pow(2, 32), s = { getUint64: function (e) { var t, e = new DataView(e.buffer, e.byteOffset, e.byteLength); return e.getBigUint64 ? (t = e.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : e.getUint32(0) * ye + e.getUint32(4) }, MAX_UINT32: ye }, _e = s.MAX_UINT32; if (d = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], pasp: [], sdtp: [], smhd: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], styp: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [] }, "undefined" != typeof Uint8Array) { for (var n in d) d.hasOwnProperty(n) && (d[n] = [n.charCodeAt(0), n.charCodeAt(1), n.charCodeAt(2), n.charCodeAt(3)]); te = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), se = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), ie = new Uint8Array([0, 0, 0, 1]), ke = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), xe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), ne = { video: ke, audio: xe }, oe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), ae = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), le = t, de = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), he = t, re = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) } l = function (e) { for (var t, i = [], s = 0, n = 1; n < arguments.length; n++)i.push(arguments[n]); for (n = i.length; n--;)s += i[n].byteLength; for (t = new Uint8Array(s + 8), new DataView(t.buffer, t.byteOffset, t.byteLength).setUint32(0, t.byteLength), t.set(e, 4), n = 0, s = 8; n < i.length; n++)t.set(i[n], s), s += i[n].byteLength; return t }, R = function () { return l(d.dinf, l(d.dref, oe)) }, U = function (e) { return l(d.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, e.audioobjecttype << 3 | e.samplingfrequencyindex >>> 1, e.samplingfrequencyindex << 7 | e.channelcount << 3, 6, 1, 2])) }, X = function (e) { return l(d.hdlr, ne[e]) }, G = function (e) { var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, e.duration >>> 24 & 255, e.duration >>> 16 & 255, e.duration >>> 8 & 255, 255 & e.duration, 85, 196, 0, 0]); return e.samplerate && (t[12] = e.samplerate >>> 24 & 255, t[13] = e.samplerate >>> 16 & 255, t[14] = e.samplerate >>> 8 & 255, t[15] = 255 & e.samplerate), l(d.mdhd, t) }, W = function (e) { return l(d.mdia, G(e), X(e.type), j(e)) }, F = function (e) { return l(d.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e])) }, j = function (e) { return l(d.minf, "video" === e.type ? l(d.vmhd, re) : l(d.smhd, ae), R(), Y(e)) }, V = function (e) { for (var t = e.length, i = []; t--;)i[t] = Z(e[t]); return l.apply(null, [d.mvex].concat(i)) }, q = function (e) { e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return l(d.mvhd, e) }, K = function (e) { for (var t, i = e.samples || [], s = new Uint8Array(4 + i.length), n = 0; n < i.length; n++)t = i[n].flags, s[n + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy; return l(d.sdtp, s) }, Y = function (e) { return l(d.stbl, Q(e), l(d.stts, he), l(d.stsc, le), l(d.stsz, de), l(d.stco, t)) }, Q = function (e) { return l(d.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), ("video" === e.type ? ue : ce)(e)) }, ue = function (e) { for (var t, i, s = e.sps || [], n = e.pps || [], r = [], a = [], o = 0; o < s.length; o++)r.push((65280 & s[o].byteLength) >>> 8), r.push(255 & s[o].byteLength), r = r.concat(Array.prototype.slice.call(s[o])); for (o = 0; o < n.length; o++)a.push((65280 & n[o].byteLength) >>> 8), a.push(255 & n[o].byteLength), a = a.concat(Array.prototype.slice.call(n[o])); return t = [d.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, (65280 & e.height) >> 8, 255 & e.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), l(d.avcC, new Uint8Array([1, e.profileIdc, e.profileCompatibility, e.levelIdc, 255].concat([s.length], r, [n.length], a))), l(d.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))], e.sarRatio && (i = e.sarRatio[0], e = e.sarRatio[1], t.push(l(d.pasp, new Uint8Array([(4278190080 & i) >> 24, (16711680 & i) >> 16, (65280 & i) >> 8, 255 & i, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e])))), l.apply(null, t) }, ce = function (e) { return l(d.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.channelcount) >> 8, 255 & e.channelcount, (65280 & e.samplesize) >> 8, 255 & e.samplesize, 0, 0, 0, 0, (65280 & e.samplerate) >> 8, 255 & e.samplerate, 0, 0]), U(e)) }, $ = function (e) { e = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 0, (4278190080 & e.duration) >> 24, (16711680 & e.duration) >> 16, (65280 & e.duration) >> 8, 255 & e.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, 0, 0, (65280 & e.height) >> 8, 255 & e.height, 0, 0]); return l(d.tkhd, e) }, J = function (e) { var t, i = l(d.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), s = Math.floor(e.baseMediaDecodeTime / _e), n = Math.floor(e.baseMediaDecodeTime % _e), s = l(d.tfdt, new Uint8Array([1, 0, 0, 0, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n])); return "audio" === e.type ? (t = ee(e, 92), l(d.traf, i, s, t)) : (n = K(e), t = ee(e, n.length + 92), l(d.traf, i, s, t, n)) }, z = function (e) { return e.duration = e.duration || 4294967295, l(d.trak, $(e), W(e)) }, Z = function (e) { var t = new Uint8Array([0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]); return "video" !== e.type && (t[t.length - 1] = 0), l(d.trex, t) }, pe = function (e, t) { var i = 0, s = 0, n = 0, r = 0; return e.length && (void 0 !== e[0].duration && (i = 1), void 0 !== e[0].size && (s = 2), void 0 !== e[0].flags && (n = 4), void 0 !== e[0].compositionTimeOffset) && (r = 8), [0, 0, i | s | n | r, 1, (4278190080 & e.length) >>> 24, (16711680 & e.length) >>> 16, (65280 & e.length) >>> 8, 255 & e.length, (4278190080 & t) >>> 24, (16711680 & t) >>> 16, (65280 & t) >>> 8, 255 & t] }, me = function (e, t) { var i, s, n, r, a = e.samples || []; for (t += 20 + 16 * a.length, e = pe(a, t), (s = new Uint8Array(e.length + 16 * a.length)).set(e), i = e.length, r = 0; r < a.length; r++)n = a[r], s[i++] = (4278190080 & n.duration) >>> 24, s[i++] = (16711680 & n.duration) >>> 16, s[i++] = (65280 & n.duration) >>> 8, s[i++] = 255 & n.duration, s[i++] = (4278190080 & n.size) >>> 24, s[i++] = (16711680 & n.size) >>> 16, s[i++] = (65280 & n.size) >>> 8, s[i++] = 255 & n.size, s[i++] = n.flags.isLeading << 2 | n.flags.dependsOn, s[i++] = n.flags.isDependedOn << 6 | n.flags.hasRedundancy << 4 | n.flags.paddingValue << 1 | n.flags.isNonSyncSample, s[i++] = 61440 & n.flags.degradationPriority, s[i++] = 15 & n.flags.degradationPriority, s[i++] = (4278190080 & n.compositionTimeOffset) >>> 24, s[i++] = (16711680 & n.compositionTimeOffset) >>> 16, s[i++] = (65280 & n.compositionTimeOffset) >>> 8, s[i++] = 255 & n.compositionTimeOffset; return l(d.trun, s) }, ge = function (e, t) { var i, s, n, r, a = e.samples || []; for (t += 20 + 8 * a.length, e = pe(a, t), (i = new Uint8Array(e.length + 8 * a.length)).set(e), s = e.length, r = 0; r < a.length; r++)n = a[r], i[s++] = (4278190080 & n.duration) >>> 24, i[s++] = (16711680 & n.duration) >>> 16, i[s++] = (65280 & n.duration) >>> 8, i[s++] = 255 & n.duration, i[s++] = (4278190080 & n.size) >>> 24, i[s++] = (16711680 & n.size) >>> 16, i[s++] = (65280 & n.size) >>> 8, i[s++] = 255 & n.size; return l(d.trun, i) }, ee = function (e, t) { return ("audio" === e.type ? ge : me)(e, t) }; function ve(e, t) { var i = Ie(); return i.dataOffset = t, i.compositionTimeOffset = e.pts - e.dts, i.duration = e.duration, i.size = 4 * e.length, i.size += e.byteLength, e.keyFrame && (i.flags.dependsOn = 2, i.flags.isNonSyncSample = 0), i } function r(e) { for (var t = []; e--;)t.push(0); return t } function a(e) { e = e || {}, a.prototype.init.call(this), this.parse708captions_ = "boolean" != typeof e.parse708captions || e.parse708captions, this.captionPackets_ = [], this.ccStreams_ = [new g(0, 0), new g(0, 1), new g(1, 0), new g(1, 1)], this.parse708captions_ && (this.cc708Stream_ = new m({ captionServices: e.captionServices })), this.reset(), this.ccStreams_.forEach(function (e) { e.on("data", this.trigger.bind(this, "data")), e.on("partialdone", this.trigger.bind(this, "partialdone")), e.on("done", this.trigger.bind(this, "done")) }, this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done"))) } function be(e) { return 32 <= e && e <= 127 || 160 <= e && e <= 255 } function o(e) { this.windowNum = e, this.reset() } function Te(e, t, i) { this.serviceNum = e, this.text = "", this.currentWindow = new o(-1), this.windows = [], this.stream = i, "string" == typeof t && this.createTextDecoder(t) } function Se(e) { return null === e ? "" : (e = Fe[e] || e, String.fromCharCode(e)) } function h() { for (var e = [], t = je + 1; t--;)e.push(""); return e } function we(e, t) { var i = 1; for (t < e && (i = -1); Math.abs(t - e) > $e;)e += i * ze; return e } function Ee(e) { var t, i; Ee.prototype.init.call(this), this.type_ = e || "shared", this.push = function (e) { "shared" !== this.type_ && e.type !== this.type_ || (void 0 === i && (i = e.dts), e.dts = we(e.dts, i), e.pts = we(e.pts, i), t = e.dts, this.trigger("data", e)) }, this.flush = function () { i = t, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.discontinuity = function () { t = i = void 0 }, this.reset = function () { this.discontinuity(), this.trigger("reset") } } var Ce, ke = { ftyp: B = function () { return l(d.ftyp, te, ie, te, se) }, mdat: function (e) { return l(d.mdat, e) }, moof: function (e, t) { for (var i = [], s = t.length; s--;)i[s] = J(t[s]); return l.apply(null, [d.moof, F(e)].concat(i)) }, moov: H = function (e) { for (var t = e.length, i = []; t--;)i[t] = z(e[t]); return l.apply(null, [d.moov, q(4294967295)].concat(i).concat(V(e))) }, initSegment: function (e) { var t = B(), e = H(e), i = new Uint8Array(t.byteLength + e.byteLength); return i.set(t), i.set(e, t.byteLength), i } }, Ie = function () { return { size: 0, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0, degradationPriority: 0, isNonSyncSample: 1 } } }, xe = { groupNalsIntoFrames: function (e) { var t, i, s = [], n = []; for (n.byteLength = 0, n.nalCount = 0, t = s.byteLength = n.duration = 0; t < e.length; t++)"access_unit_delimiter_rbsp" === (i = e[t]).nalUnitType ? (s.length && (s.duration = i.dts - s.dts, n.byteLength += s.byteLength, n.nalCount += s.length, n.duration += s.duration, n.push(s)), (s = [i]).byteLength = i.data.byteLength, s.pts = i.pts, s.dts = i.dts) : ("slice_layer_without_partitioning_rbsp_idr" === i.nalUnitType && (s.keyFrame = !0), s.duration = i.dts - s.dts, s.byteLength += i.data.byteLength, s.push(i)); return n.length && (!s.duration || s.duration <= 0) && (s.duration = n[n.length - 1].duration), n.byteLength += s.byteLength, n.nalCount += s.length, n.duration += s.duration, n.push(s), n }, groupFramesIntoGops: function (e) { var t, i, s = [], n = []; for (s.byteLength = 0, s.nalCount = 0, s.duration = 0, s.pts = e[0].pts, s.dts = e[0].dts, n.byteLength = 0, n.nalCount = 0, n.duration = 0, n.pts = e[0].pts, n.dts = e[0].dts, t = 0; t < e.length; t++)(i = e[t]).keyFrame ? (s.length && (n.push(s), n.byteLength += s.byteLength, n.nalCount += s.nalCount, n.duration += s.duration), (s = [i]).nalCount = i.length, s.byteLength = i.byteLength, s.pts = i.pts, s.dts = i.dts, s.duration = i.duration) : (s.duration += i.duration, s.nalCount += i.length, s.byteLength += i.byteLength, s.push(i)); return n.length && s.duration <= 0 && (s.duration = n[n.length - 1].duration), n.byteLength += s.byteLength, n.nalCount += s.nalCount, n.duration += s.duration, n.push(s), n }, extendFirstKeyFrame: function (e) { var t; return !e[0][0].keyFrame && 1 < e.length && (t = e.shift(), e.byteLength -= t.byteLength, e.nalCount -= t.nalCount, e[0][0].dts = t.dts, e[0][0].pts = t.pts, e[0][0].duration += t.duration), e }, generateSampleTable: function (e, t) { for (var i, s, n, r = t || 0, a = [], o = 0; o < e.length; o++)for (s = e[o], i = 0; i < s.length; i++)n = s[i], r += (n = ve(n, r)).size, a.push(n); return a }, concatenateNalData: function (e) { for (var t, i, s, n, r, a = 0, o = e.byteLength, l = e.nalCount, d = new Uint8Array(o + 4 * l), h = new DataView(d.buffer), u = 0; u < e.length; u++)for (s = e[u], t = 0; t < s.length; t++)for (n = s[t], i = 0; i < n.length; i++)r = n[i], h.setUint32(a, r.data.byteLength), d.set(r.data, a += 4), a += r.data.byteLength; return d }, generateSampleTableForFrame: function (e, t) { var i = [], e = ve(e, t || 0); return i.push(e), i }, concatenateNalDataForFrame: function (e) { for (var t, i = 0, s = e.byteLength, n = e.length, r = new Uint8Array(s + 4 * n), a = new DataView(r.buffer), o = 0; o < e.length; o++)t = e[o], a.setUint32(i, t.data.byteLength), r.set(t.data, i += 4), i += t.data.byteLength; return r } }, u = [33, 16, 5, 32, 164, 27], Ae = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], Le = function (e) { return 9e4 * e }, Pe = function (e, t) { return e * t }, De = function (e) { return e / 9e4 }, Oe = function (e, t) { return e / t }, c = { ONE_SECOND_IN_TS: 9e4, secondsToVideoTs: Le, secondsToAudioTs: Pe, videoTsToSeconds: De, audioTsToSeconds: Oe, audioTsToVideoTs: function (e, t) { return e / t * 9e4 }, videoTsToAudioTs: function (e, t) { return e / 9e4 * t }, metadataTsToSeconds: function (e, t, i) { return De(i ? e : e - t) } }, Me = function () { var e, i; return Ce || (e = { 96e3: [u, [227, 64], r(154), [56]], 88200: [u, [231], r(170), [56]], 64e3: [u, [248, 192], r(240), [56]], 48e3: [u, [255, 192], r(268), [55, 148, 128], r(54), [112]], 44100: [u, [255, 192], r(268), [55, 163, 128], r(84), [112]], 32e3: [u, [255, 192], r(268), [55, 234], r(226), [112]], 24e3: [u, [255, 192], r(268), [55, 255, 128], r(268), [111, 112], r(126), [224]], 16e3: [u, [255, 192], r(268), [55, 255, 128], r(268), [111, 255], r(269), [223, 108], r(195), [1, 192]], 12e3: [Ae, r(268), [3, 127, 248], r(268), [6, 255, 240], r(268), [13, 255, 224], r(268), [27, 253, 128], r(259), [56]], 11025: [Ae, r(268), [3, 127, 248], r(268), [6, 255, 240], r(268), [13, 255, 224], r(268), [27, 255, 192], r(268), [55, 175, 128], r(108), [112]], 8e3: [Ae, r(268), [3, 121, 16], r(47), [7]] }, i = e, Ce = Object.keys(i).reduce(function (e, t) { return e[t] = new Uint8Array(i[t].reduce(function (e, t) { return e.concat(t) }, [])), e }, {})), Ce }, Ne = c, Le = { prefixWithSilence: function (e, t, i, s) { var n, r, a, o, l, d = 0, h = 0; if (t.length && (r = Ne.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), n = Math.ceil(Ne.ONE_SECOND_IN_TS / (e.samplerate / 1024)), i && s && (r = r - Math.max(i, s), h = (d = Math.floor(r / n)) * n), !(d < 1 || h > Ne.ONE_SECOND_IN_TS / 2))) { for (a = (a = Me()[e.samplerate]) || t[0].data, o = 0; o < d; o++)l = t[0], t.splice(0, 0, { data: a, dts: l.dts - n, pts: l.pts - n }); return e.baseMediaDecodeTime -= Math.floor(Ne.videoTsToAudioTs(h, e.samplerate)), h } }, trimAdtsFramesByEarliestDts: function (e, t, i) { return t.minSegmentDts >= i ? e : (t.minSegmentDts = 1 / 0, e.filter(function (e) { return e.dts >= i && (t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), t.minSegmentPts = t.minSegmentDts, !0) })) }, generateSampleTable: function (e) { for (var t, i = [], s = 0; s < e.length; s++)t = e[s], i.push({ size: t.data.byteLength, duration: 1024 }); return i }, concatenateFrameData: function (e) { for (var t, i = 0, s = new Uint8Array(function (e) { for (var t = 0, i = 0; i < e.length; i++)t += e[i].data.byteLength; return t }(e)), n = 0; n < e.length; n++)t = e[n], s.set(t.data, i), i += t.data.byteLength; return s } }, Re = c.ONE_SECOND_IN_TS, Pe = { clearDtsInfo: function (e) { delete e.minSegmentDts, delete e.maxSegmentDts, delete e.minSegmentPts, delete e.maxSegmentPts }, calculateTrackBaseMediaDecodeTime: function (e, t) { var i = e.minSegmentDts; return t || (i -= e.timelineStartInfo.dts), t = e.timelineStartInfo.baseMediaDecodeTime, t += i, t = Math.max(0, t), "audio" === e.type && (t *= e.samplerate / Re, t = Math.floor(t)), t }, collectDtsInfo: function (e, t) { "number" == typeof t.pts && (void 0 === e.timelineStartInfo.pts && (e.timelineStartInfo.pts = t.pts), void 0 === e.minSegmentPts ? e.minSegmentPts = t.pts : e.minSegmentPts = Math.min(e.minSegmentPts, t.pts), void 0 === e.maxSegmentPts ? e.maxSegmentPts = t.pts : e.maxSegmentPts = Math.max(e.maxSegmentPts, t.pts)), "number" == typeof t.dts && (void 0 === e.timelineStartInfo.dts && (e.timelineStartInfo.dts = t.dts), void 0 === e.minSegmentDts ? e.minSegmentDts = t.dts : e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), void 0 === e.maxSegmentDts ? e.maxSegmentDts = t.dts : e.maxSegmentDts = Math.max(e.maxSegmentDts, t.dts)) } }, Oe = { parseSei: function (e) { for (var t = 0, i = { payloadType: -1, payloadSize: 0 }, s = 0, n = 0; t < e.byteLength && 128 !== e[t];) { for (; 255 === e[t];)s += 255, t++; for (s += e[t++]; 255 === e[t];)n += 255, t++; if (n += e[t++], !i.payload && 4 === s) { if ("GA94" === String.fromCharCode(e[t + 3], e[t + 4], e[t + 5], e[t + 6])) { i.payloadType = s, i.payloadSize = n, i.payload = e.subarray(t, t + n); break } i.payload = void 0 } t += n, n = s = 0 } return i }, parseUserData: function (e) { return 181 !== e.payload[0] || 49 != (e.payload[1] << 8 | e.payload[2]) || "GA94" !== String.fromCharCode(e.payload[3], e.payload[4], e.payload[5], e.payload[6]) || 3 !== e.payload[7] ? null : e.payload.subarray(8, e.payload.length - 1) }, parseCaptionPackets: function (e, t) { var i, s, n, r, a = []; if (64 & t[0]) for (s = 31 & t[0], i = 0; i < s; i++)r = { type: 3 & t[2 + (n = 3 * i)], pts: e }, 4 & t[2 + n] && (r.ccData = t[3 + n] << 8 | t[4 + n], a.push(r)); return a }, discardEmulationPreventionBytes: function (e) { for (var t = e.byteLength, i = [], s = 1; s < t - 2;)0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2] ? (i.push(s + 2), s += 2) : s++; if (0 === i.length) return e; for (var n = t - i.length, r = new Uint8Array(n), a = 0, s = 0; s < n; a++, s++)a === i[0] && (a++, i.shift()), r[s] = e[a]; return r }, USER_DATA_REGISTERED_ITU_T_T35: 4 }, p = i, Ue = Oe, Be = ((a.prototype = new p).push = function (e) { var t; "sei_rbsp" === e.nalUnitType && (t = Ue.parseSei(e.escapedRBSP)).payload && t.payloadType === Ue.USER_DATA_REGISTERED_ITU_T_T35 && (t = Ue.parseUserData(t)) && (e.dts < this.latestDts_ ? this.ignoreNextEqualDts_ = !0 : e.dts === this.latestDts_ && this.ignoreNextEqualDts_ ? (this.numSameDts_--, this.numSameDts_ || (this.ignoreNextEqualDts_ = !1)) : (t = Ue.parseCaptionPackets(e.pts, t), this.captionPackets_ = this.captionPackets_.concat(t), this.latestDts_ !== e.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = e.dts)) }, a.prototype.flushCCStreams = function (t) { this.ccStreams_.forEach(function (e) { return "flush" === t ? e.flush() : e.partialFlush() }, this) }, a.prototype.flushStream = function (e) { this.captionPackets_.length && (this.captionPackets_.forEach(function (e, t) { e.presortIndex = t }), this.captionPackets_.sort(function (e, t) { return e.pts === t.pts ? e.presortIndex - t.presortIndex : e.pts - t.pts }), this.captionPackets_.forEach(function (e) { e.type < 2 ? this.dispatchCea608Packet(e) : this.dispatchCea708Packet(e) }, this), this.captionPackets_.length = 0), this.flushCCStreams(e) }, a.prototype.flush = function () { return this.flushStream("flush") }, a.prototype.partialFlush = function () { return this.flushStream("partialFlush") }, a.prototype.reset = function () { this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function (e) { e.reset() }) }, a.prototype.dispatchCea608Packet = function (e) { this.setsTextOrXDSActive(e) ? this.activeCea608Channel_[e.type] = null : this.setsChannel1Active(e) ? this.activeCea608Channel_[e.type] = 0 : this.setsChannel2Active(e) && (this.activeCea608Channel_[e.type] = 1), null !== this.activeCea608Channel_[e.type] && this.ccStreams_[(e.type << 1) + this.activeCea608Channel_[e.type]].push(e) }, a.prototype.setsChannel1Active = function (e) { return 4096 == (30720 & e.ccData) }, a.prototype.setsChannel2Active = function (e) { return 6144 == (30720 & e.ccData) }, a.prototype.setsTextOrXDSActive = function (e) { return 256 == (28928 & e.ccData) || 4138 == (30974 & e.ccData) || 6186 == (30974 & e.ccData) }, a.prototype.dispatchCea708Packet = function (e) { this.parse708captions_ && this.cc708Stream_.push(e) }, { 127: 9834, 4128: 32, 4129: 160, 4133: 8230, 4138: 352, 4140: 338, 4144: 9608, 4145: 8216, 4146: 8217, 4147: 8220, 4148: 8221, 4149: 8226, 4153: 8482, 4154: 353, 4156: 339, 4157: 8480, 4159: 376, 4214: 8539, 4215: 8540, 4216: 8541, 4217: 8542, 4218: 9168, 4219: 9124, 4220: 9123, 4221: 9135, 4222: 9126, 4223: 9121, 4256: 12600 }), m = (o.prototype.reset = function () { this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0 }, o.prototype.getText = function () { return this.rows.join("\n") }, o.prototype.clearText = function () { this.rows = [""], this.rowIdx = 0 }, o.prototype.newLine = function (e) { for (this.rows.length >= this.virtualRowCount && "function" == typeof this.beforeRowOverflow && this.beforeRowOverflow(e), 0 < this.rows.length && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount;)this.rows.shift(), this.rowIdx-- }, o.prototype.isEmpty = function () { return 0 === this.rows.length || 1 === this.rows.length && "" === this.rows[0] }, o.prototype.addText = function (e) { this.rows[this.rowIdx] += e }, o.prototype.backspace = function () { var e; this.isEmpty() || (e = this.rows[this.rowIdx], this.rows[this.rowIdx] = e.substr(0, e.length - 1)) }, Te.prototype.init = function (e, t) { this.startPts = e; for (var i = 0; i < 8; i++)this.windows[i] = new o(i), "function" == typeof t && (this.windows[i].beforeRowOverflow = t) }, Te.prototype.setCurrentWindow = function (e) { this.currentWindow = this.windows[e] }, Te.prototype.createTextDecoder = function (t) { if ("undefined" == typeof TextDecoder) this.stream.trigger("log", { level: "warn", message: "The `encoding` option is unsupported without TextDecoder support" }); else try { this.textDecoder_ = new TextDecoder(t) } catch (e) { this.stream.trigger("log", { level: "warn", message: "TextDecoder could not be created with " + t + " encoding. " + e }) } }, function (e) { e = e || {}, m.prototype.init.call(this); var t, i = this, s = e.captionServices || {}, n = {}; Object.keys(s).forEach(e => { t = s[e], /^SERVICE/.test(e) && (n[e] = t.encoding) }), this.serviceEncodings = n, this.current708Packet = null, this.services = {}, this.push = function (e) { (3 === e.type || null === i.current708Packet) && i.new708Packet(), i.add708Bytes(e) } }), Fe = (m.prototype = new p, m.prototype.new708Packet = function () { null !== this.current708Packet && this.push708Packet(), this.current708Packet = { data: [], ptsVals: [] } }, m.prototype.add708Bytes = function (e) { var t = e.ccData, i = t >>> 8, t = 255 & t; this.current708Packet.ptsVals.push(e.pts), this.current708Packet.data.push(i), this.current708Packet.data.push(t) }, m.prototype.push708Packet = function () { var e, t = this.current708Packet, i = t.data, s = null, n = 0, r = i[n++]; for (t.seq = r >> 6, t.sizeCode = 63 & r; n < i.length; n++)e = 31 & (r = i[n++]), 7 === (s = r >> 5) && 0 < e && (s = i[n++]), this.pushServiceBlock(s, n, e), 0 < e && (n += e - 1) }, m.prototype.pushServiceBlock = function (e, t, i) { for (var s, n = t, r = this.current708Packet.data, a = (a = this.services[e]) || this.initService(e, n); n < t + i && n < r.length; n++)s = r[n], be(s) ? n = this.handleText(n, a) : 24 === s ? n = this.multiByteCharacter(n, a) : 16 === s ? n = this.extendedCommands(n, a) : 128 <= s && s <= 135 ? n = this.setCurrentWindow(n, a) : 152 <= s && s <= 159 ? n = this.defineWindow(n, a) : 136 === s ? n = this.clearWindows(n, a) : 140 === s ? n = this.deleteWindows(n, a) : 137 === s ? n = this.displayWindows(n, a) : 138 === s ? n = this.hideWindows(n, a) : 139 === s ? n = this.toggleWindows(n, a) : 151 === s ? n = this.setWindowAttributes(n, a) : 144 === s ? n = this.setPenAttributes(n, a) : 145 === s ? n = this.setPenColor(n, a) : 146 === s ? n = this.setPenLocation(n, a) : 143 === s ? a = this.reset(n, a) : 8 === s ? a.currentWindow.backspace() : 12 === s ? a.currentWindow.clearText() : 13 === s ? a.currentWindow.pendingNewLine = !0 : 14 === s ? a.currentWindow.clearText() : 141 === s && n++ }, m.prototype.extendedCommands = function (e, t) { var i = this.current708Packet.data[++e]; return e = be(i) ? this.handleText(e, t, { isExtended: !0 }) : e }, m.prototype.getPts = function (e) { return this.current708Packet.ptsVals[Math.floor(e / 2)] }, m.prototype.initService = function (t, e) { var i, s = "SERVICE" + t, n = this; return s in this.serviceEncodings && (i = this.serviceEncodings[s]), this.services[t] = new Te(t, i, n), this.services[t].init(this.getPts(e), function (e) { n.flushDisplayed(e, n.services[t]) }), this.services[t] }, m.prototype.handleText = function (e, t, i) { var s, n = i && i.isExtended, i = i && i.isMultiByte, r = this.current708Packet.data, a = n ? 4096 : 0, o = r[e], r = r[e + 1], l = t.currentWindow, r = t.textDecoder_ && !n ? (i ? (s = [o, r], e++) : s = [o], t.textDecoder_.decode(new Uint8Array(s))) : (i = Be[n = a | o] || n, 4096 & n && n === i ? "" : String.fromCharCode(i)); return l.pendingNewLine && !l.isEmpty() && l.newLine(this.getPts(e)), l.pendingNewLine = !1, l.addText(r), e }, m.prototype.multiByteCharacter = function (e, t) { var i = this.current708Packet.data, s = i[e + 1], i = i[e + 2]; return e = be(s) && be(i) ? this.handleText(++e, t, { isMultiByte: !0 }) : e }, m.prototype.setCurrentWindow = function (e, t) { var i = this.current708Packet.data[e]; return t.setCurrentWindow(7 & i), e }, m.prototype.defineWindow = function (e, t) { var i = this.current708Packet.data, s = i[e], t = (t.setCurrentWindow(7 & s), t.currentWindow), s = i[++e]; return t.visible = (32 & s) >> 5, t.rowLock = (16 & s) >> 4, t.columnLock = (8 & s) >> 3, t.priority = 7 & s, s = i[++e], t.relativePositioning = (128 & s) >> 7, t.anchorVertical = 127 & s, s = i[++e], t.anchorHorizontal = s, s = i[++e], t.anchorPoint = (240 & s) >> 4, t.rowCount = 15 & s, s = i[++e], t.columnCount = 63 & s, s = i[++e], t.windowStyle = (56 & s) >> 3, t.penStyle = 7 & s, t.virtualRowCount = t.rowCount + 1, e }, m.prototype.setWindowAttributes = function (e, t) { var i = this.current708Packet.data, t = (i[e], t.currentWindow.winAttr), s = i[++e]; return t.fillOpacity = (192 & s) >> 6, t.fillRed = (48 & s) >> 4, t.fillGreen = (12 & s) >> 2, t.fillBlue = 3 & s, s = i[++e], t.borderType = (192 & s) >> 6, t.borderRed = (48 & s) >> 4, t.borderGreen = (12 & s) >> 2, t.borderBlue = 3 & s, s = i[++e], t.borderType += (128 & s) >> 5, t.wordWrap = (64 & s) >> 6, t.printDirection = (48 & s) >> 4, t.scrollDirection = (12 & s) >> 2, t.justify = 3 & s, s = i[++e], t.effectSpeed = (240 & s) >> 4, t.effectDirection = (12 & s) >> 2, t.displayEffect = 3 & s, e }, m.prototype.flushDisplayed = function (e, t) { for (var i = [], s = 0; s < 8; s++)t.windows[s].visible && !t.windows[s].isEmpty() && i.push(t.windows[s].getText()); t.endPts = e, t.text = i.join("\n\n"), this.pushCaption(t), t.startPts = e }, m.prototype.pushCaption = function (e) { "" !== e.text && (this.trigger("data", { startPts: e.startPts, endPts: e.endPts, text: e.text, stream: "cc708_" + e.serviceNum }), e.text = "", e.startPts = e.endPts) }, m.prototype.displayWindows = function (e, t) { var i = this.current708Packet.data[++e], s = this.getPts(e); this.flushDisplayed(s, t); for (var n = 0; n < 8; n++)i & 1 << n && (t.windows[n].visible = 1); return e }, m.prototype.hideWindows = function (e, t) { var i = this.current708Packet.data[++e], s = this.getPts(e); this.flushDisplayed(s, t); for (var n = 0; n < 8; n++)i & 1 << n && (t.windows[n].visible = 0); return e }, m.prototype.toggleWindows = function (e, t) { var i = this.current708Packet.data[++e], s = this.getPts(e); this.flushDisplayed(s, t); for (var n = 0; n < 8; n++)i & 1 << n && (t.windows[n].visible ^= 1); return e }, m.prototype.clearWindows = function (e, t) { var i = this.current708Packet.data[++e], s = this.getPts(e); this.flushDisplayed(s, t); for (var n = 0; n < 8; n++)i & 1 << n && t.windows[n].clearText(); return e }, m.prototype.deleteWindows = function (e, t) { var i = this.current708Packet.data[++e], s = this.getPts(e); this.flushDisplayed(s, t); for (var n = 0; n < 8; n++)i & 1 << n && t.windows[n].reset(); return e }, m.prototype.setPenAttributes = function (e, t) { var i = this.current708Packet.data, t = (i[e], t.currentWindow.penAttr), s = i[++e]; return t.textTag = (240 & s) >> 4, t.offset = (12 & s) >> 2, t.penSize = 3 & s, s = i[++e], t.italics = (128 & s) >> 7, t.underline = (64 & s) >> 6, t.edgeType = (56 & s) >> 3, t.fontStyle = 7 & s, e }, m.prototype.setPenColor = function (e, t) { var i = this.current708Packet.data, t = (i[e], t.currentWindow.penColor), s = i[++e]; return t.fgOpacity = (192 & s) >> 6, t.fgRed = (48 & s) >> 4, t.fgGreen = (12 & s) >> 2, t.fgBlue = 3 & s, s = i[++e], t.bgOpacity = (192 & s) >> 6, t.bgRed = (48 & s) >> 4, t.bgGreen = (12 & s) >> 2, t.bgBlue = 3 & s, s = i[++e], t.edgeRed = (48 & s) >> 4, t.edgeGreen = (12 & s) >> 2, t.edgeBlue = 3 & s, e }, m.prototype.setPenLocation = function (e, t) { var i = this.current708Packet.data, s = (i[e], t.currentWindow.penLoc); return t.currentWindow.pendingNewLine = !0, t = i[++e], s.row = 15 & t, t = i[++e], s.column = 63 & t, e }, m.prototype.reset = function (e, t) { var i = this.getPts(e); return this.flushDisplayed(i, t), this.initService(t.serviceNum, e) }, { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 304: 174, 305: 176, 306: 189, 307: 191, 308: 8482, 309: 162, 310: 163, 311: 9834, 312: 224, 313: 160, 314: 232, 315: 226, 316: 234, 317: 238, 318: 244, 319: 251, 544: 193, 545: 201, 546: 211, 547: 218, 548: 220, 549: 252, 550: 8216, 551: 161, 552: 42, 553: 39, 554: 8212, 555: 169, 556: 8480, 557: 8226, 558: 8220, 559: 8221, 560: 192, 561: 194, 562: 199, 563: 200, 564: 202, 565: 203, 566: 235, 567: 206, 568: 207, 569: 239, 570: 212, 571: 217, 572: 249, 573: 219, 574: 171, 575: 187, 800: 195, 801: 227, 802: 205, 803: 204, 804: 236, 805: 210, 806: 242, 807: 213, 808: 245, 809: 123, 810: 125, 811: 92, 812: 94, 813: 95, 814: 124, 815: 126, 816: 196, 817: 228, 818: 214, 819: 246, 820: 223, 821: 165, 822: 164, 823: 9474, 824: 197, 825: 229, 826: 216, 827: 248, 828: 9484, 829: 9488, 830: 9492, 831: 9496 }), je = 14, He = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152], g = function (e, t) { g.prototype.init.call(this), this.field_ = e || 0, this.dataChannel_ = t || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function (e) { var t, i, s, n, r = 32639 & e.ccData; r === this.lastControlCode_ ? this.lastControlCode_ = null : (4096 == (61440 & r) ? this.lastControlCode_ = r : r !== this.PADDING_ && (this.lastControlCode_ = null), t = r >>> 8, i = 255 & r, r !== this.PADDING_ && (r === this.RESUME_CAPTION_LOADING_ ? this.mode_ = "popOn" : r === this.END_OF_CAPTION_ ? (this.mode_ = "popOn", this.clearFormatting(e.pts), this.flushDisplayed(e.pts), n = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = n, this.startPts_ = e.pts) : r === this.ROLL_UP_2_ROWS_ ? (this.rollUpRows_ = 2, this.setRollUp(e.pts)) : r === this.ROLL_UP_3_ROWS_ ? (this.rollUpRows_ = 3, this.setRollUp(e.pts)) : r === this.ROLL_UP_4_ROWS_ ? (this.rollUpRows_ = 4, this.setRollUp(e.pts)) : r === this.CARRIAGE_RETURN_ ? (this.clearFormatting(e.pts), this.flushDisplayed(e.pts), this.shiftRowsUp_(), this.startPts_ = e.pts) : r === this.BACKSPACE_ ? "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1) : r === this.ERASE_DISPLAYED_MEMORY_ ? (this.flushDisplayed(e.pts), this.displayed_ = h()) : r === this.ERASE_NON_DISPLAYED_MEMORY_ ? this.nonDisplayed_ = h() : r === this.RESUME_DIRECT_CAPTIONING_ ? ("paintOn" !== this.mode_ && (this.flushDisplayed(e.pts), this.displayed_ = h()), this.mode_ = "paintOn", this.startPts_ = e.pts) : this.isSpecialCharacter(t, i) ? (s = Se((t = (3 & t) << 8) | i), this[this.mode_](e.pts, s), this.column_++) : this.isExtCharacter(t, i) ? ("popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), s = Se((t = (3 & t) << 8) | i), this[this.mode_](e.pts, s), this.column_++) : this.isMidRowCode(t, i) ? (this.clearFormatting(e.pts), this[this.mode_](e.pts, " "), this.column_++, 14 == (14 & i) && this.addFormatting(e.pts, ["i"]), 1 == (1 & i) && this.addFormatting(e.pts, ["u"])) : this.isOffsetControlCode(t, i) ? this.column_ += 3 & i : this.isPAC(t, i) ? (n = He.indexOf(7968 & r), "rollUp" === this.mode_ && (n - this.rollUpRows_ + 1 < 0 && (n = this.rollUpRows_ - 1), this.setRollUp(e.pts, n)), n !== this.row_ && (this.clearFormatting(e.pts), this.row_ = n), 1 & i && -1 === this.formatting_.indexOf("u") && this.addFormatting(e.pts, ["u"]), 16 == (16 & r) && (this.column_ = 4 * ((14 & r) >> 1)), this.isColorPAC(i) && 14 == (14 & i) && this.addFormatting(e.pts, ["i"])) : this.isNormalChar(t) && (0 === i && (i = null), s = Se(t), s += Se(i), this[this.mode_](e.pts, s), this.column_ += s.length))) } }, p = (g.prototype = new p, g.prototype.flushDisplayed = function (e) { var t = this.displayed_.map(function (e, t) { try { return e.trim() } catch (e) { return this.trigger("log", { level: "warn", message: "Skipping a malformed 608 caption at index " + t + "." }), "" } }, this).join("\n").replace(/^\n+|\n+$/g, ""); t.length && this.trigger("data", { startPts: this.startPts_, endPts: e, text: t, stream: this.name_ }) }, g.prototype.reset = function () { this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = h(), this.nonDisplayed_ = h(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = je, this.rollUpRows_ = 2, this.formatting_ = [] }, g.prototype.setConstants = function () { 0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_ }, g.prototype.isSpecialCharacter = function (e, t) { return e === this.EXT_ && 48 <= t && t <= 63 }, g.prototype.isExtCharacter = function (e, t) { return (e === this.EXT_ + 1 || e === this.EXT_ + 2) && 32 <= t && t <= 63 }, g.prototype.isMidRowCode = function (e, t) { return e === this.EXT_ && 32 <= t && t <= 47 }, g.prototype.isOffsetControlCode = function (e, t) { return e === this.OFFSET_ && 33 <= t && t <= 35 }, g.prototype.isPAC = function (e, t) { return e >= this.BASE_ && e < this.BASE_ + 8 && 64 <= t && t <= 127 }, g.prototype.isColorPAC = function (e) { return 64 <= e && e <= 79 || 96 <= e && e <= 127 }, g.prototype.isNormalChar = function (e) { return 32 <= e && e <= 127 }, g.prototype.setRollUp = function (e, t) { if ("rollUp" !== this.mode_ && (this.row_ = je, this.mode_ = "rollUp", this.flushDisplayed(e), this.nonDisplayed_ = h(), this.displayed_ = h()), void 0 !== t && t !== this.row_) for (var i = 0; i < this.rollUpRows_; i++)this.displayed_[t - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = ""; void 0 === t && (t = this.row_), this.topRow_ = t - this.rollUpRows_ + 1 }, g.prototype.addFormatting = function (e, t) { this.formatting_ = this.formatting_.concat(t); t = t.reduce(function (e, t) { return e + "<" + t + ">" }, ""); this[this.mode_](e, t) }, g.prototype.clearFormatting = function (e) { var t; this.formatting_.length && (t = this.formatting_.reverse().reduce(function (e, t) { return e + "</" + t + ">" }, ""), this.formatting_ = [], this[this.mode_](e, t)) }, g.prototype.popOn = function (e, t) { var i = this.nonDisplayed_[this.row_]; this.nonDisplayed_[this.row_] = i += t }, g.prototype.rollUp = function (e, t) { var i = this.displayed_[this.row_]; this.displayed_[this.row_] = i += t }, g.prototype.shiftRowsUp_ = function () { for (var e = 0; e < this.topRow_; e++)this.displayed_[e] = ""; for (e = this.row_ + 1; e < je + 1; e++)this.displayed_[e] = ""; for (e = this.topRow_; e < this.row_; e++)this.displayed_[e] = this.displayed_[e + 1]; this.displayed_[this.row_] = "" }, g.prototype.paintOn = function (e, t) { var i = this.displayed_[this.row_]; this.displayed_[this.row_] = i += t }, { CaptionStream: a, Cea608Stream: g, Cea708Stream: m }), Ve = { H264_STREAM_TYPE: 27, ADTS_STREAM_TYPE: 15, METADATA_STREAM_TYPE: 21 }, qe = i, ze = 8589934592, $e = 4294967296; Ee.prototype = new qe; function We(e, t, i) { for (var s = "", n = t; n < i; n++)s += "%" + ("00" + e[n].toString(16)).slice(-2); return s } function f(e, t, i) { return decodeURIComponent(We(e, t, i)) } function y(e, t, i) { return unescape(We(e, t, i)) } function _(e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] } var Ge, Xe, Ke, qe = Ee, Ye = we, Qe = (e, t, i) => { if (e) for (var s = i; s < e.length; s++)if (e[s] === t) return s; return -1 }, Je = 3, v = { APIC: function (e) { var t, i = 1; e.data[0] !== Je || (t = Qe(e.data, 0, 1)) < 0 || (e.mimeType = y(e.data, 1, t), e.pictureType = e.data[i = t + 1], (t = Qe(e.data, 0, ++i)) < 0) || (e.description = f(e.data, i, t), i = t + 1, "--\x3e" === e.mimeType ? e.url = y(e.data, i, e.data.length) : e.pictureData = e.data.subarray(i, e.data.length)) }, "T*": function (e) { e.data[0] === Je && (e.value = f(e.data, 1, e.data.length).replace(/\0*$/, ""), e.values = e.value.split("\0")) }, TXXX: function (e) { var t; e.data[0] === Je && -1 !== (t = Qe(e.data, 0, 1)) && (e.description = f(e.data, 1, t), e.value = f(e.data, t + 1, e.data.length).replace(/\0*$/, ""), e.data = e.value) }, "W*": function (e) { e.url = y(e.data, 0, e.data.length).replace(/\0.*$/, "") }, WXXX: function (e) { var t; e.data[0] === Je && -1 !== (t = Qe(e.data, 0, 1)) && (e.description = f(e.data, 1, t), e.url = y(e.data, t + 1, e.data.length).replace(/\0.*$/, "")) }, PRIV: function (e) { for (var t = 0; t < e.data.length; t++)if (0 === e.data[t]) { e.owner = y(e.data, 0, t); break } e.privateData = e.data.subarray(t + 1), e.data = e.privateData } }, Ze = { parseId3Frames: function (e) { var t, i = 10, s = 0, n = []; if (!(e.length < 10 || e[0] !== "I".charCodeAt(0) || e[1] !== "D".charCodeAt(0) || e[2] !== "3".charCodeAt(0))) { s = _(e.subarray(6, 10)); s += 10, 64 & e[5] && (i = (i += 4) + _(e.subarray(10, 14)), s -= _(e.subarray(16, 20))); do { if ((t = _(e.subarray(i + 4, i + 8))) < 1) break; var r = { id: String.fromCharCode(e[i], e[i + 1], e[i + 2], e[i + 3]), data: e.subarray(i + 10, i + t + 10) } } while (r.key = r.id, v[r.id] ? v[r.id](r) : "T" === r.id[0] ? v["T*"](r) : "W" === r.id[0] && v["W*"](r), n.push(r), (i = i + 10 + t) < s); return n } }, parseSyncSafeInteger: _, frameParsers: v }, b = i, et = Ve, T = Ze, tt = function (e) { var t, i = { descriptor: e && e.descriptor }, l = 0, d = [], h = 0; if (tt.prototype.init.call(this), this.dispatchType = et.METADATA_STREAM_TYPE.toString(16), i.descriptor) for (t = 0; t < i.descriptor.length; t++)this.dispatchType += ("00" + i.descriptor[t].toString(16)).slice(-2); this.push = function (e) { var t, i, s, n, r, a, o; if ("timed-metadata" === e.type) if (e.dataAlignmentIndicator && (h = 0, d.length = 0), 0 === d.length && (e.data.length < 10 || e.data[0] !== "I".charCodeAt(0) || e.data[1] !== "D".charCodeAt(0) || e.data[2] !== "3".charCodeAt(0))) this.trigger("log", { level: "warn", message: "Skipping unrecognized metadata packet" }); else if (d.push(e), h += e.data.byteLength, 1 === d.length && (l = T.parseSyncSafeInteger(e.data.subarray(6, 10)), l += 10), !(h < l)) { for (t = { data: new Uint8Array(l), frames: [], pts: d[0].pts, dts: d[0].dts }, n = 0; n < l;)t.data.set(d[0].data.subarray(0, l - n), n), n += d[0].data.byteLength, h -= d[0].data.byteLength, d.shift(); i = 10, 64 & t.data[5] && (i = (i += 4) + T.parseSyncSafeInteger(t.data.subarray(10, 14)), l -= T.parseSyncSafeInteger(t.data.subarray(16, 20))); do { if ((s = T.parseSyncSafeInteger(t.data.subarray(i + 4, i + 8))) < 1) { this.trigger("log", { level: "warn", message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing." }); break } } while ((o = { id: String.fromCharCode(t.data[i], t.data[i + 1], t.data[i + 2], t.data[i + 3]), data: t.data.subarray(i + 10, i + s + 10) }).key = o.id, T.frameParsers[o.id] ? T.frameParsers[o.id](o) : "T" === o.id[0] ? T.frameParsers["T*"](o) : "W" === o.id[0] && T.frameParsers["W*"](o), "com.apple.streaming.transportStreamTimestamp" === o.owner && (a = (1 & (r = o.data)[3]) << 30 | r[4] << 22 | r[5] << 14 | r[6] << 6 | r[7] >>> 2, a = (a *= 4) + (3 & r[7]), o.timeStamp = a, void 0 === t.pts && void 0 === t.dts && (t.pts = o.timeStamp, t.dts = o.timeStamp), this.trigger("timestamp", o)), t.frames.push(o), (i = i + 10 + s) < l); this.trigger("data", t) } } }, b = (tt.prototype = new b, tt), S = i, it = p, w = Ve, st = function () { var n = new Uint8Array(188), r = 0; st.prototype.init.call(this), this.push = function (e) { var t, i = 0, s = 188; for (r ? ((t = new Uint8Array(e.byteLength + r)).set(n.subarray(0, r)), t.set(e, r), r = 0) : t = e; s < t.byteLength;)71 === t[i] && 71 === t[s] ? (this.trigger("data", t.subarray(i, s)), i += 188, s += 188) : (i++, s++); i < t.byteLength && (n.set(t.subarray(i), 0), r = t.byteLength - i) }, this.flush = function () { 188 === r && 71 === n[0] && (this.trigger("data", n), r = 0), this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.reset = function () { r = 0, this.trigger("reset") } }, nt = (st.prototype = new S, (Ge = function () { var s, n, r, a; Ge.prototype.init.call(this), (a = this).packetsWaitingForPmt = [], this.programMapTable = void 0, s = function (e, t) { var i = 0; t.payloadUnitStartIndicator && (i += e[i] + 1), ("pat" === t.type ? n : r)(e.subarray(i), t) }, n = function (e, t) { t.section_number = e[7], t.last_section_number = e[8], a.pmtPid = (31 & e[10]) << 8 | e[11], t.pmtPid = a.pmtPid }, r = function (e, t) { var i, s; if (1 & e[5]) { for (a.programMapTable = { video: null, audio: null, "timed-metadata": {} }, i = 3 + ((15 & e[1]) << 8 | e[2]) - 4, s = 12 + ((15 & e[10]) << 8 | e[11]); s < i;) { var n = e[s], r = (31 & e[s + 1]) << 8 | e[s + 2]; n === w.H264_STREAM_TYPE && null === a.programMapTable.video ? a.programMapTable.video = r : n === w.ADTS_STREAM_TYPE && null === a.programMapTable.audio ? a.programMapTable.audio = r : n === w.METADATA_STREAM_TYPE && (a.programMapTable["timed-metadata"][r] = n), s += 5 + ((15 & e[s + 3]) << 8 | e[s + 4]) } t.programMapTable = a.programMapTable } }, this.push = function (e) { var t = {}, i = 4; if (t.payloadUnitStartIndicator = !!(64 & e[1]), t.pid = 31 & e[1], t.pid <<= 8, t.pid |= e[2], 1 < (48 & e[3]) >>> 4 && (i += e[i] + 1), 0 === t.pid) t.type = "pat", s(e.subarray(i), t), this.trigger("data", t); else if (t.pid === this.pmtPid) for (t.type = "pmt", s(e.subarray(i), t), this.trigger("data", t); this.packetsWaitingForPmt.length;)this.processPes_.apply(this, this.packetsWaitingForPmt.shift()); else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([e, i, t]) : this.processPes_(e, i, t) }, this.processPes_ = function (e, t, i) { i.pid === this.programMapTable.video ? i.streamType = w.H264_STREAM_TYPE : i.pid === this.programMapTable.audio ? i.streamType = w.ADTS_STREAM_TYPE : i.streamType = this.programMapTable["timed-metadata"][i.pid], i.type = "pes", i.data = e.subarray(t), this.trigger("data", i) } }).prototype = new S, Ge.STREAM_TYPES = { h264: 27, adts: 15 }, (Xe = function () { function s(e, t, i) { var s, n = new Uint8Array(e.size), r = { type: t }, a = 0, o = 0; if (e.data.length && !(e.size < 9)) { for (r.trackId = e.data[0].pid, a = 0; a < e.data.length; a++)s = e.data[a], n.set(s.data, o), o += s.data.byteLength; d(n, r), t = "video" === t || r.packetLength <= e.size, (i || t) && (e.size = 0, e.data.length = 0), t && l.trigger("data", r) } } var t, l = this, n = !1, r = { data: [], size: 0 }, a = { data: [], size: 0 }, o = { data: [], size: 0 }, d = function (e, t) { var i = e[0] << 16 | e[1] << 8 | e[2]; t.data = new Uint8Array, 1 == i && (t.packetLength = 6 + (e[4] << 8 | e[5]), t.dataAlignmentIndicator = 0 != (4 & e[6]), 192 & (i = e[7]) && (t.pts = (14 & e[9]) << 27 | (255 & e[10]) << 20 | (254 & e[11]) << 12 | (255 & e[12]) << 5 | (254 & e[13]) >>> 3, t.pts *= 4, t.pts += (6 & e[13]) >>> 1, t.dts = t.pts, 64 & i) && (t.dts = (14 & e[14]) << 27 | (255 & e[15]) << 20 | (254 & e[16]) << 12 | (255 & e[17]) << 5 | (254 & e[18]) >>> 3, t.dts *= 4, t.dts += (6 & e[18]) >>> 1), t.data = e.subarray(9 + e[8])) }; Xe.prototype.init.call(this), this.push = function (i) { ({ pat: function () { }, pes: function () { var e, t; switch (i.streamType) { case w.H264_STREAM_TYPE: e = r, t = "video"; break; case w.ADTS_STREAM_TYPE: e = a, t = "audio"; break; case w.METADATA_STREAM_TYPE: e = o, t = "timed-metadata"; break; default: return }i.payloadUnitStartIndicator && s(e, t, !0), e.data.push(i), e.size += i.data.byteLength }, pmt: function () { var e = { type: "metadata", tracks: [] }; null !== (t = i.programMapTable).video && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +t.video, codec: "avc", type: "video" }), null !== t.audio && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +t.audio, codec: "adts", type: "audio" }), n = !0, l.trigger("data", e) } })[i.type]() }, this.reset = function () { r.size = 0, r.data.length = 0, a.size = 0, a.data.length = 0, this.trigger("reset") }, this.flushStreams_ = function () { s(r, "video"), s(a, "audio"), s(o, "timed-metadata") }, this.flush = function () { var e; !n && t && (e = { type: "metadata", tracks: [] }, null !== t.video && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +t.video, codec: "avc", type: "video" }), null !== t.audio && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +t.audio, codec: "adts", type: "audio" }), l.trigger("data", e)), n = !1, this.flushStreams_(), this.trigger("done") } }).prototype = new S, { PAT_PID: 0, MP2T_PACKET_LENGTH: 188, TransportPacketStream: st, TransportParseStream: Ge, ElementaryStream: Xe, TimestampRolloverStream: qe, CaptionStream: it.CaptionStream, Cea608Stream: it.Cea608Stream, Cea708Stream: it.Cea708Stream, MetadataStream: b }); for (Ke in w) w.hasOwnProperty(Ke) && (nt[Ke] = w[Ke]); var rt, at, S = nt, qe = i, ot = c.ONE_SECOND_IN_TS, lt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], dt = function (l) { var d, h = 0; dt.prototype.init.call(this), this.skipWarn_ = function (e, t) { this.trigger("log", { level: "warn", message: `adts skiping bytes ${e} to ${t} in frame ${h} outside syncword` }) }, this.push = function (e) { var t, i, s, n, r, a, o = 0; if (l || (h = 0), "audio" === e.type) { for (d && d.length ? (s = d, (d = new Uint8Array(s.byteLength + e.data.byteLength)).set(s), d.set(e.data, s.byteLength)) : d = e.data; o + 7 < d.length;)if (255 !== d[o] || 240 != (246 & d[o + 1])) "number" != typeof a && (a = o), o++; else { if ("number" == typeof a && (this.skipWarn_(a, o), a = null), i = 2 * (1 & ~d[o + 1]), t = (3 & d[o + 3]) << 11 | d[o + 4] << 3 | (224 & d[o + 5]) >> 5, r = (n = 1024 * (1 + (3 & d[o + 6]))) * ot / lt[(60 & d[o + 2]) >>> 2], d.byteLength - o < t) break; this.trigger("data", { pts: e.pts + h * r, dts: e.dts + h * r, sampleCount: n, audioobjecttype: 1 + (d[o + 2] >>> 6 & 3), channelcount: (1 & d[o + 2]) << 2 | (192 & d[o + 3]) >>> 6, samplerate: lt[(60 & d[o + 2]) >>> 2], samplingfrequencyindex: (60 & d[o + 2]) >>> 2, samplesize: 16, data: d.subarray(o + 7 + i, o + t) }), h++, o += t } "number" == typeof a && (this.skipWarn_(a, o), a = null), d = d.subarray(o) } }, this.flush = function () { h = 0, this.trigger("done") }, this.reset = function () { d = void 0, this.trigger("reset") }, this.endTimeline = function () { d = void 0, this.trigger("endedtimeline") } }, it = (dt.prototype = new qe, dt), b = i, ht = function (s) { var n = s.byteLength, r = 0, a = 0; this.length = function () { return 8 * n }, this.bitsAvailable = function () { return 8 * n + a }, this.loadWord = function () { var e = s.byteLength - n, t = new Uint8Array(4), i = Math.min(4, n); if (0 === i) throw new Error("no bytes available"); t.set(s.subarray(e, e + i)), r = new DataView(t.buffer).getUint32(0), a = 8 * i, n -= i }, this.skipBits = function (e) { var t; e < a || (e = (e -= a) - 8 * (t = Math.floor(e / 8)), n -= t, this.loadWord()), r <<= e, a -= e }, this.readBits = function (e) { var t = Math.min(a, e), i = r >>> 32 - t; return 0 < (a -= t) ? r <<= t : 0 < n && this.loadWord(), 0 < (t = e - t) ? i << t | this.readBits(t) : i }, this.skipLeadingZeros = function () { for (var e = 0; e < a; ++e)if (0 != (r & 2147483648 >>> e)) return r <<= e, a -= e, e; return this.loadWord(), e + this.skipLeadingZeros() }, this.skipUnsignedExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.skipExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.readUnsignedExpGolomb = function () { var e = this.skipLeadingZeros(); return this.readBits(e + 1) - 1 }, this.readExpGolomb = function () { var e = this.readUnsignedExpGolomb(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) }, this.readBoolean = function () { return 1 === this.readBits(1) }, this.readUnsignedByte = function () { return this.readBits(8) }, this.loadWord() }, ut = function () { var s, n, r = 0; ut.prototype.init.call(this), this.push = function (e) { for (var t, i = (n = n ? ((t = new Uint8Array(n.byteLength + e.data.byteLength)).set(n), t.set(e.data, n.byteLength), t) : e.data).byteLength; r < i - 3; r++)if (1 === n[r + 2]) { s = r + 5; break } for (; s < i;)switch (n[s]) { case 0: if (0 !== n[s - 1]) s += 2; else if (0 !== n[s - 2]) s++; else { for (r + 3 !== s - 2 && this.trigger("data", n.subarray(r + 3, s - 2)); 1 !== n[++s] && s < i;); r = s - 2, s += 3 } break; case 1: 0 !== n[s - 1] || 0 !== n[s - 2] ? s += 3 : (this.trigger("data", n.subarray(r + 3, s - 2)), r = s - 2, s += 3); break; default: s += 3 }n = n.subarray(r), s -= r, r = 0 }, this.reset = function () { n = null, r = 0, this.trigger("reset") }, this.flush = function () { n && 3 < n.byteLength && this.trigger("data", n.subarray(r + 3)), n = null, r = 0, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") } }; ut.prototype = new b, at = { 100: !0, 110: !0, 122: !0, 244: !0, 44: !0, 83: !0, 86: !0, 118: !0, 128: !0, 138: !0, 139: !0, 134: !0 }, (rt = function () { var i, s, n, r, a, o, g, t = new ut; rt.prototype.init.call(this), (i = this).push = function (e) { "video" === e.type && (s = e.trackId, n = e.pts, r = e.dts, t.push(e)) }, t.on("data", function (e) { var t = { trackId: s, pts: n, dts: r, data: e, nalUnitTypeCode: 31 & e[0] }; switch (t.nalUnitTypeCode) { case 5: t.nalUnitType = "slice_layer_without_partitioning_rbsp_idr"; break; case 6: t.nalUnitType = "sei_rbsp", t.escapedRBSP = a(e.subarray(1)); break; case 7: t.nalUnitType = "seq_parameter_set_rbsp", t.escapedRBSP = a(e.subarray(1)), t.config = o(t.escapedRBSP); break; case 8: t.nalUnitType = "pic_parameter_set_rbsp"; break; case 9: t.nalUnitType = "access_unit_delimiter_rbsp" }i.trigger("data", t) }), t.on("done", function () { i.trigger("done") }), t.on("partialdone", function () { i.trigger("partialdone") }), t.on("reset", function () { i.trigger("reset") }), t.on("endedtimeline", function () { i.trigger("endedtimeline") }), this.flush = function () { t.flush() }, this.partialFlush = function () { t.partialFlush() }, this.reset = function () { t.reset() }, this.endTimeline = function () { t.endTimeline() }, g = function (e, t) { for (var i = 8, s = 8, n = 0; n < e; n++)i = 0 === (s = 0 !== s ? (i + t.readExpGolomb() + 256) % 256 : s) ? i : s }, a = function (e) { for (var t = e.byteLength, i = [], s = 1; s < t - 2;)0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2] ? (i.push(s + 2), s += 2) : s++; if (0 === i.length) return e; for (var n = t - i.length, r = new Uint8Array(n), a = 0, s = 0; s < n; a++, s++)a === i[0] && (a++, i.shift()), r[s] = e[a]; return r }, o = function (e) { var t, i, s, n, r, a, o = 0, l = 0, d = 0, h = 0, u = [1, 1], c = new ht(e), e = c.readUnsignedByte(), p = c.readUnsignedByte(), m = c.readUnsignedByte(); if (c.skipUnsignedExpGolomb(), at[e] && (3 === (i = c.readUnsignedExpGolomb()) && c.skipBits(1), c.skipUnsignedExpGolomb(), c.skipUnsignedExpGolomb(), c.skipBits(1), c.readBoolean())) for (r = 3 !== i ? 8 : 12, a = 0; a < r; a++)c.readBoolean() && g(a < 6 ? 16 : 64, c); if (c.skipUnsignedExpGolomb(), 0 === (i = c.readUnsignedExpGolomb())) c.readUnsignedExpGolomb(); else if (1 === i) for (c.skipBits(1), c.skipExpGolomb(), c.skipExpGolomb(), t = c.readUnsignedExpGolomb(), a = 0; a < t; a++)c.skipExpGolomb(); if (c.skipUnsignedExpGolomb(), c.skipBits(1), i = c.readUnsignedExpGolomb(), s = c.readUnsignedExpGolomb(), 0 === (n = c.readBits(1)) && c.skipBits(1), c.skipBits(1), c.readBoolean() && (o = c.readUnsignedExpGolomb(), l = c.readUnsignedExpGolomb(), d = c.readUnsignedExpGolomb(), h = c.readUnsignedExpGolomb()), c.readBoolean() && c.readBoolean()) { switch (c.readUnsignedByte()) { case 1: u = [1, 1]; break; case 2: u = [12, 11]; break; case 3: u = [10, 11]; break; case 4: u = [16, 11]; break; case 5: u = [40, 33]; break; case 6: u = [24, 11]; break; case 7: u = [20, 11]; break; case 8: u = [32, 11]; break; case 9: u = [80, 33]; break; case 10: u = [18, 11]; break; case 11: u = [15, 11]; break; case 12: u = [64, 33]; break; case 13: u = [160, 99]; break; case 14: u = [4, 3]; break; case 15: u = [3, 2]; break; case 16: u = [2, 1]; break; case 255: u = [c.readUnsignedByte() << 8 | c.readUnsignedByte(), c.readUnsignedByte() << 8 | c.readUnsignedByte()] }u && (u[0], u[1]) } return { profileIdc: e, levelIdc: m, profileCompatibility: p, width: 16 * (i + 1) - 2 * o - 2 * l, height: (2 - n) * (s + 1) * 16 - 2 * d - 2 * h, sarRatio: u } } }).prototype = new b; function ct(e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] } var qe = rt, pt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], mt = function (e, t) { var i = 0 <= (i = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]) ? i : 0; return (16 & e[t + 5]) >> 4 ? 20 + i : 10 + i }, gt = function (e, t) { return e.length - t < 10 || e[t] !== "I".charCodeAt(0) || e[t + 1] !== "D".charCodeAt(0) || e[t + 2] !== "3".charCodeAt(0) ? t : (t += mt(e, t), gt(e, t)) }, ft = function (e, t, i) { for (var s = "", n = t; n < i; n++)s += "%" + ("00" + e[n].toString(16)).slice(-2); return s }, b = { isLikelyAacData: function (e) { var t = gt(e, 0); return e.length >= t + 2 && 255 == (255 & e[t]) && 240 == (240 & e[t + 1]) && 16 == (22 & e[t + 1]) }, parseId3TagSize: mt, parseAdtsSize: function (e, t) { var i = (224 & e[t + 5]) >> 5, s = e[t + 4] << 3; return 6144 & e[t + 3] | s | i }, parseType: function (e, t) { return e[t] === "I".charCodeAt(0) && e[t + 1] === "D".charCodeAt(0) && e[t + 2] === "3".charCodeAt(0) ? "timed-metadata" : !0 & e[t] && 240 == (240 & e[t + 1]) ? "audio" : null }, parseSampleRate: function (e) { for (var t = 0; t + 5 < e.length;) { if (255 === e[t] && 240 == (246 & e[t + 1])) return pt[(60 & e[t + 2]) >>> 2]; t++ } return null }, parseAacTimestamp: function (e) { var t, i = 10; 64 & e[5] && (i = (i += 4) + ct(e.subarray(10, 14))); do { if ((t = ct(e.subarray(i + 4, i + 8))) < 1) return null; if ("PRIV" === String.fromCharCode(e[i], e[i + 1], e[i + 2], e[i + 3])) for (var s, n, r = e.subarray(i + 10, i + t + 10), a = 0; a < r.byteLength; a++)if (0 === r[a]) { if ("com.apple.streaming.transportStreamTimestamp" === unescape(ft(r, 0, a))) return n = (1 & (s = r.subarray(a + 1))[3]) << 30 | s[4] << 22 | s[5] << 14 | s[6] << 6 | s[7] >>> 2, (n *= 4) + (3 & s[7]); break } } while ((i = i + 10 + t) < e.byteLength); return null } }, E = i, yt = b, _t = function () { var r = new Uint8Array, a = 0; _t.prototype.init.call(this), this.setTimestamp = function (e) { a = e }, this.push = function (e) { var t, i, s = 0, n = 0; for (r.length ? (i = r.length, (r = new Uint8Array(e.byteLength + i)).set(r.subarray(0, i)), r.set(e, i)) : r = e; 3 <= r.length - n;)if (r[n] === "I".charCodeAt(0) && r[n + 1] === "D".charCodeAt(0) && r[n + 2] === "3".charCodeAt(0)) { if (r.length - n < 10) break; if (n + (s = yt.parseId3TagSize(r, n)) > r.length) break; t = { type: "timed-metadata", data: r.subarray(n, n + s) }, this.trigger("data", t), n += s } else if (255 == (255 & r[n]) && 240 == (240 & r[n + 1])) { if (r.length - n < 7) break; if (n + (s = yt.parseAdtsSize(r, n)) > r.length) break; t = { type: "audio", data: r.subarray(n, n + s), pts: a, dts: a }, this.trigger("data", t), n += s } else n++; i = r.length - n, r = 0 < i ? r.subarray(n) : new Uint8Array }, this.reset = function () { r = new Uint8Array, this.trigger("reset") }, this.endTimeline = function () { r = new Uint8Array, this.trigger("endedtimeline") } }; _t.prototype = new E; function vt(e, t) { for (var i = Object.keys(t), s = 0; s < i.length; s++) { var n = i[s]; "headOfPipeline" !== n && t[n].on && t[n].on("log", Ot.bind(e, n)) } } function bt(e, t) { var i; if (e.length === t.length) { for (i = 0; i < e.length; i++)if (e[i] !== t[i]) return; return 1 } } function Tt(e, t, i, s, n, r) { return { start: { dts: e, pts: e + (i - t) }, end: { dts: e + (s - t), pts: e + (n - i) }, prependedContentDuration: r, baseMediaDecodeTime: e } } var St, wt, C, E = i, k = ke, I = xe, Et = Le, x = Pe, A = S, Ct = c, kt = it, It = qe, xt = _t, At = b.isLikelyAacData, Lt = c.ONE_SECOND_IN_TS, Pt = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], Dt = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], Ot = function (e, t) { t.stream = e, this.trigger("log", t) }, Mt = function (r, a) { var o = [], l = 0, d = 0, h = 1 / 0, u = (a = a || {}).firstSequenceNumber || 0; Mt.prototype.init.call(this), this.push = function (t) { x.collectDtsInfo(r, t), r && Pt.forEach(function (e) { r[e] = t[e] }), o.push(t) }, this.setEarliestDts = function (e) { l = e }, this.setVideoBaseMediaDecodeTime = function (e) { h = e }, this.setAudioAppendStart = function (e) { d = e }, this.flush = function () { var e, t, i, s, n; 0 !== o.length && (e = Et.trimAdtsFramesByEarliestDts(o, r, l), r.baseMediaDecodeTime = x.calculateTrackBaseMediaDecodeTime(r, a.keepOriginalTimestamps), n = Et.prefixWithSilence(r, e, d, h), r.samples = Et.generateSampleTable(e), i = k.mdat(Et.concatenateFrameData(e)), o = [], s = k.moof(u, [r]), t = new Uint8Array(s.byteLength + i.byteLength), u++, t.set(s), t.set(i, s.byteLength), x.clearDtsInfo(r), i = Math.ceil(1024 * Lt / r.samplerate), e.length && (s = e.length * i, this.trigger("segmentTimingInfo", Tt(Ct.audioTsToVideoTs(r.baseMediaDecodeTime, r.samplerate), e[0].dts, e[0].pts, e[0].dts + s, e[0].pts + s, n || 0)), this.trigger("timingInfo", { start: e[0].pts, end: e[0].pts + s })), this.trigger("data", { track: r, boxes: t })), this.trigger("done", "AudioSegmentStream") }, this.reset = function () { x.clearDtsInfo(r), o = [], this.trigger("reset") } }; Mt.prototype = new E, (St = function (a, r) { var t, i, o = [], d = [], l = (r = r || {}).firstSequenceNumber || 0; St.prototype.init.call(this), delete a.minPTS, this.gopCache_ = [], this.push = function (e) { x.collectDtsInfo(a, e), "seq_parameter_set_rbsp" !== e.nalUnitType || t || (t = e.config, a.sps = [e.data], Dt.forEach(function (e) { a[e] = t[e] }, this)), "pic_parameter_set_rbsp" !== e.nalUnitType || i || (i = e.data, a.pps = [e.data]), o.push(e) }, this.flush = function () { for (var e, t, i, s = 0; o.length && "access_unit_delimiter_rbsp" !== o[0].nalUnitType;)o.shift(); if (0 !== o.length) { if (e = I.groupNalsIntoFrames(o), (e = I.groupFramesIntoGops(e))[0][0].keyFrame || ((n = this.getGopForFusion_(o[0], a)) ? (s = n.duration, e.unshift(n), e.byteLength += n.byteLength, e.nalCount += n.nalCount, e.pts = n.pts, e.dts = n.dts, e.duration += n.duration) : e = I.extendFirstKeyFrame(e)), d.length) { var n = r.alignGopsAtEnd ? this.alignGopsAtEnd_(e) : this.alignGopsAtStart_(e); if (!n) return this.gopCache_.unshift({ gop: e.pop(), pps: a.pps, sps: a.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), o = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); x.clearDtsInfo(a), e = n } x.collectDtsInfo(a, e), a.samples = I.generateSampleTable(e), n = k.mdat(I.concatenateNalData(e)), a.baseMediaDecodeTime = x.calculateTrackBaseMediaDecodeTime(a, r.keepOriginalTimestamps), this.trigger("processedGopsInfo", e.map(function (e) { return { pts: e.pts, dts: e.dts, byteLength: e.byteLength } })), t = e[0], i = e[e.length - 1], this.trigger("segmentTimingInfo", Tt(a.baseMediaDecodeTime, t.dts, t.pts, i.dts + i.duration, i.pts + i.duration, s)), this.trigger("timingInfo", { start: e[0].pts, end: e[e.length - 1].pts + e[e.length - 1].duration }), this.gopCache_.unshift({ gop: e.pop(), pps: a.pps, sps: a.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), o = [], this.trigger("baseMediaDecodeTime", a.baseMediaDecodeTime), this.trigger("timelineStartInfo", a.timelineStartInfo), t = k.moof(l, [a]), i = new Uint8Array(t.byteLength + n.byteLength), l++, i.set(t), i.set(n, t.byteLength), this.trigger("data", { track: a, boxes: i }) } this.resetStream_(), this.trigger("done", "VideoSegmentStream") }, this.reset = function () { this.resetStream_(), o = [], this.gopCache_.length = 0, d.length = 0, this.trigger("reset") }, this.resetStream_ = function () { x.clearDtsInfo(a), i = t = void 0 }, this.getGopForFusion_ = function (e) { for (var t, i, s, n = 1 / 0, r = 0; r < this.gopCache_.length; r++)i = (s = this.gopCache_[r]).gop, a.pps && bt(a.pps[0], s.pps[0]) && a.sps && bt(a.sps[0], s.sps[0]) && (i.dts < a.timelineStartInfo.dts || -1e4 <= (i = e.dts - i.dts - i.duration) && i <= 45e3 && (!t || i < n) && (t = s, n = i)); return t ? t.gop : null }, this.alignGopsAtStart_ = function (e) { for (var t, i, s, n, r = e.byteLength, a = e.nalCount, o = e.duration, l = t = 0; l < d.length && t < e.length && (i = d[l], s = e[t], i.pts !== s.pts);)s.pts > i.pts ? l++ : (t++, r -= s.byteLength, a -= s.nalCount, o -= s.duration); return 0 === t ? e : t === e.length ? null : ((n = e.slice(t)).byteLength = r, n.duration = o, n.nalCount = a, n.pts = n[0].pts, n.dts = n[0].dts, n) }, this.alignGopsAtEnd_ = function (e) { for (var t, i, s, n, r = d.length - 1, a = e.length - 1, o = null, l = !1; 0 <= r && 0 <= a;) { if (t = d[r], i = e[a], t.pts === i.pts) { l = !0; break } t.pts > i.pts ? r-- : (r === d.length - 1 && (o = a), a--) } return l || null !== o ? 0 === (s = l ? a : o) ? e : (n = (s = e.slice(s)).reduce(function (e, t) { return e.byteLength += t.byteLength, e.duration += t.duration, e.nalCount += t.nalCount, e }, { byteLength: 0, duration: 0, nalCount: 0 }), s.byteLength = n.byteLength, s.duration = n.duration, s.nalCount = n.nalCount, s.pts = s[0].pts, s.dts = s[0].dts, s) : null }, this.alignGopsWith = function (e) { d = e } }).prototype = new E, ((C = function (e, t) { this.numberOfTracks = 0, this.metadataStream = t, "undefined" != typeof (e = e || {}).remux ? this.remuxTracks = !!e.remux : this.remuxTracks = !0, "boolean" == typeof e.keepOriginalTimestamps ? this.keepOriginalTimestamps = e.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, C.prototype.init.call(this), this.push = function (e) { return e.text ? this.pendingCaptions.push(e) : e.frames ? this.pendingMetadata.push(e) : (this.pendingTracks.push(e.track), this.pendingBytes += e.boxes.byteLength, "video" === e.track.type && (this.videoTrack = e.track, this.pendingBoxes.push(e.boxes)), void ("audio" === e.track.type && (this.audioTrack = e.track, this.pendingBoxes.unshift(e.boxes)))) } }).prototype = new E).flush = function (e) { var t, i, s, n = 0, r = { captions: [], captionStreams: {}, metadata: [], info: {} }, a = 0; if (this.pendingTracks.length < this.numberOfTracks) { if ("VideoSegmentStream" !== e && "AudioSegmentStream" !== e) return; if (this.remuxTracks) return; if (0 === this.pendingTracks.length) return this.emittedTracks++, void (this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)) } if (this.videoTrack ? (a = this.videoTrack.timelineStartInfo.pts, Dt.forEach(function (e) { r.info[e] = this.videoTrack[e] }, this)) : this.audioTrack && (a = this.audioTrack.timelineStartInfo.pts, Pt.forEach(function (e) { r.info[e] = this.audioTrack[e] }, this)), this.videoTrack || this.audioTrack) { for (1 === this.pendingTracks.length ? r.type = this.pendingTracks[0].type : r.type = "combined", this.emittedTracks += this.pendingTracks.length, e = k.initSegment(this.pendingTracks), r.initSegment = new Uint8Array(e.byteLength), r.initSegment.set(e), r.data = new Uint8Array(this.pendingBytes), s = 0; s < this.pendingBoxes.length; s++)r.data.set(this.pendingBoxes[s], n), n += this.pendingBoxes[s].byteLength; for (s = 0; s < this.pendingCaptions.length; s++)(t = this.pendingCaptions[s]).startTime = Ct.metadataTsToSeconds(t.startPts, a, this.keepOriginalTimestamps), t.endTime = Ct.metadataTsToSeconds(t.endPts, a, this.keepOriginalTimestamps), r.captionStreams[t.stream] = !0, r.captions.push(t); for (s = 0; s < this.pendingMetadata.length; s++)(i = this.pendingMetadata[s]).cueTime = Ct.metadataTsToSeconds(i.pts, a, this.keepOriginalTimestamps), r.metadata.push(i); for (r.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", r), s = 0; s < r.captions.length; s++)t = r.captions[s], this.trigger("caption", t); for (s = 0; s < r.metadata.length; s++)i = r.metadata[s], this.trigger("id3Frame", i) } this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0) }, C.prototype.setRemux = function (e) { this.remuxTracks = e }, (wt = function (s) { var n, r, a = this, i = !0; wt.prototype.init.call(this), s = s || {}, this.baseMediaDecodeTime = s.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function () { var t = {}; (this.transmuxPipeline_ = t).type = "aac", t.metadataStream = new A.MetadataStream, t.aacStream = new xt, t.audioTimestampRolloverStream = new A.TimestampRolloverStream("audio"), t.timedMetadataTimestampRolloverStream = new A.TimestampRolloverStream("timed-metadata"), t.adtsStream = new kt, t.coalesceStream = new C(s, t.metadataStream), t.headOfPipeline = t.aacStream, t.aacStream.pipe(t.audioTimestampRolloverStream).pipe(t.adtsStream), t.aacStream.pipe(t.timedMetadataTimestampRolloverStream).pipe(t.metadataStream).pipe(t.coalesceStream), t.metadataStream.on("timestamp", function (e) { t.aacStream.setTimestamp(e.timeStamp) }), t.aacStream.on("data", function (e) { "timed-metadata" !== e.type && "audio" !== e.type || t.audioSegmentStream || (r = r || { timelineStartInfo: { baseMediaDecodeTime: a.baseMediaDecodeTime }, codec: "adts", type: "audio" }, t.coalesceStream.numberOfTracks++, t.audioSegmentStream = new Mt(r, s), t.audioSegmentStream.on("log", a.getLogTrigger_("audioSegmentStream")), t.audioSegmentStream.on("timingInfo", a.trigger.bind(a, "audioTimingInfo")), t.adtsStream.pipe(t.audioSegmentStream).pipe(t.coalesceStream), a.trigger("trackinfo", { hasAudio: !!r, hasVideo: !!n })) }), t.coalesceStream.on("data", this.trigger.bind(this, "data")), t.coalesceStream.on("done", this.trigger.bind(this, "done")), vt(this, t) }, this.setupTsPipeline = function () { var i = {}; (this.transmuxPipeline_ = i).type = "ts", i.metadataStream = new A.MetadataStream, i.packetStream = new A.TransportPacketStream, i.parseStream = new A.TransportParseStream, i.elementaryStream = new A.ElementaryStream, i.timestampRolloverStream = new A.TimestampRolloverStream, i.adtsStream = new kt, i.h264Stream = new It, i.captionStream = new A.CaptionStream(s), i.coalesceStream = new C(s, i.metadataStream), i.headOfPipeline = i.packetStream, i.packetStream.pipe(i.parseStream).pipe(i.elementaryStream).pipe(i.timestampRolloverStream), i.timestampRolloverStream.pipe(i.h264Stream), i.timestampRolloverStream.pipe(i.adtsStream), i.timestampRolloverStream.pipe(i.metadataStream).pipe(i.coalesceStream), i.h264Stream.pipe(i.captionStream).pipe(i.coalesceStream), i.elementaryStream.on("data", function (e) { var t; if ("metadata" === e.type) { for (t = e.tracks.length; t--;)n || "video" !== e.tracks[t].type ? r || "audio" !== e.tracks[t].type || ((r = e.tracks[t]).timelineStartInfo.baseMediaDecodeTime = a.baseMediaDecodeTime) : (n = e.tracks[t]).timelineStartInfo.baseMediaDecodeTime = a.baseMediaDecodeTime; n && !i.videoSegmentStream && (i.coalesceStream.numberOfTracks++, i.videoSegmentStream = new St(n, s), i.videoSegmentStream.on("log", a.getLogTrigger_("videoSegmentStream")), i.videoSegmentStream.on("timelineStartInfo", function (e) { r && !s.keepOriginalTimestamps && (r.timelineStartInfo = e, i.audioSegmentStream.setEarliestDts(e.dts - a.baseMediaDecodeTime)) }), i.videoSegmentStream.on("processedGopsInfo", a.trigger.bind(a, "gopInfo")), i.videoSegmentStream.on("segmentTimingInfo", a.trigger.bind(a, "videoSegmentTimingInfo")), i.videoSegmentStream.on("baseMediaDecodeTime", function (e) { r && i.audioSegmentStream.setVideoBaseMediaDecodeTime(e) }), i.videoSegmentStream.on("timingInfo", a.trigger.bind(a, "videoTimingInfo")), i.h264Stream.pipe(i.videoSegmentStream).pipe(i.coalesceStream)), r && !i.audioSegmentStream && (i.coalesceStream.numberOfTracks++, i.audioSegmentStream = new Mt(r, s), i.audioSegmentStream.on("log", a.getLogTrigger_("audioSegmentStream")), i.audioSegmentStream.on("timingInfo", a.trigger.bind(a, "audioTimingInfo")), i.audioSegmentStream.on("segmentTimingInfo", a.trigger.bind(a, "audioSegmentTimingInfo")), i.adtsStream.pipe(i.audioSegmentStream).pipe(i.coalesceStream)), a.trigger("trackinfo", { hasAudio: !!r, hasVideo: !!n }) } }), i.coalesceStream.on("data", this.trigger.bind(this, "data")), i.coalesceStream.on("id3Frame", function (e) { e.dispatchType = i.metadataStream.dispatchType, a.trigger("id3Frame", e) }), i.coalesceStream.on("caption", this.trigger.bind(this, "caption")), i.coalesceStream.on("done", this.trigger.bind(this, "done")), vt(this, i) }, this.setBaseMediaDecodeTime = function (e) { var t = this.transmuxPipeline_; s.keepOriginalTimestamps || (this.baseMediaDecodeTime = e), r && (r.timelineStartInfo.dts = void 0, r.timelineStartInfo.pts = void 0, x.clearDtsInfo(r), t.audioTimestampRolloverStream) && t.audioTimestampRolloverStream.discontinuity(), n && (t.videoSegmentStream && (t.videoSegmentStream.gopCache_ = []), n.timelineStartInfo.dts = void 0, n.timelineStartInfo.pts = void 0, x.clearDtsInfo(n), t.captionStream.reset()), t.timestampRolloverStream && t.timestampRolloverStream.discontinuity() }, this.setAudioAppendStart = function (e) { r && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(e) }, this.setRemux = function (e) { var t = this.transmuxPipeline_; s.remux = e, t && t.coalesceStream && t.coalesceStream.setRemux(e) }, this.alignGopsWith = function (e) { n && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(e) }, this.getLogTrigger_ = function (t) { var i = this; return function (e) { e.stream = t, i.trigger("log", e) } }, this.push = function (e) { var t; i && ((t = At(e)) && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : t || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), i = !1), this.transmuxPipeline_.headOfPipeline.push(e) }, this.flush = function () { i = !0, this.transmuxPipeline_.headOfPipeline.flush() }, this.endTimeline = function () { this.transmuxPipeline_.headOfPipeline.endTimeline() }, this.reset = function () { this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset() }, this.resetCaptions = function () { this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset() } }).prototype = new E; function Nt(e) { var t = ""; return (t += String.fromCharCode(e[0])) + String.fromCharCode(e[1]) + String.fromCharCode(e[2]) + String.fromCharCode(e[3]) } function Rt(e, t) { var i, s, n, r = []; if (!t.length) return null; for (i = 0; i < e.byteLength;)s = $t(e[i] << 24 | e[i + 1] << 16 | e[i + 2] << 8 | e[i + 3]), n = Wt(e.subarray(i + 4, i + 8)), s = 1 < s ? i + s : e.byteLength, n === t[0] && (1 === t.length ? r.push(e.subarray(i + 8, s)) : (n = Rt(e.subarray(i + 8, s), t.slice(1))).length && (r = r.concat(n))), i = s; return r } function Ut(e) { var t = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)) }; return t.baseMediaDecodeTime = 1 === t.version ? Xt(e.subarray(4)) : Gt(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7]), t } function Bt(e) { var t, i = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), samples: [] }, s = new DataView(e.buffer, e.byteOffset, e.byteLength), n = 1 & i.flags[2], r = 4 & i.flags[2], a = 1 & i.flags[1], o = 2 & i.flags[1], l = 4 & i.flags[1], d = 8 & i.flags[1], h = s.getUint32(4), u = 8; for (n && (i.dataOffset = s.getInt32(u), u += 4), r && h && (t = { flags: Kt(e.subarray(u, u + 4)) }, u += 4, a && (t.duration = s.getUint32(u), u += 4), o && (t.size = s.getUint32(u), u += 4), d && (t.compositionTimeOffset = 1 === i.version ? s.getInt32(u) : s.getUint32(u), u += 4), i.samples.push(t), h--); h--;)t = {}, a && (t.duration = s.getUint32(u), u += 4), o && (t.size = s.getUint32(u), u += 4), l && (t.flags = Kt(e.subarray(u, u + 4)), u += 4), d && (t.compositionTimeOffset = 1 === i.version ? s.getInt32(u) : s.getUint32(u), u += 4), i.samples.push(t); return i } function Ft(e) { var t = new DataView(e.buffer, e.byteOffset, e.byteLength), i = 1 & (e = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), trackId: t.getUint32(4) }).flags[2], s = 2 & e.flags[2], n = 8 & e.flags[2], r = 16 & e.flags[2], a = 32 & e.flags[2], o = 65536 & e.flags[0], l = 131072 & e.flags[0], d = 8; return i && (d += 4, e.baseDataOffset = t.getUint32(12), d += 4), s && (e.sampleDescriptionIndex = t.getUint32(d), d += 4), n && (e.defaultSampleDuration = t.getUint32(d), d += 4), r && (e.defaultSampleSize = t.getUint32(d), d += 4), a && (e.defaultSampleFlags = t.getUint32(d)), o && (e.durationIsEmpty = !0), !i && l && (e.baseDataOffsetIsMoof = !0), e } function jt(e) { var t = 31 & e[1]; return t << 8 | e[2] } function Ht(e) { return !!(64 & e[1]) } function Vt(e) { var t = 0; return 1 < (48 & e[3]) >>> 4 && (t += e[4] + 1), t } function qt(e) { switch (e) { case 5: return "slice_layer_without_partitioning_rbsp_idr"; case 6: return "sei_rbsp"; case 7: return "seq_parameter_set_rbsp"; case 8: return "pic_parameter_set_rbsp"; case 9: return "access_unit_delimiter_rbsp"; default: return null } } var zt = wt, i = function (e) { return e >>> 0 }, Le = function (e) { return ("00" + e.toString(16)).slice(-2) }, $t = i, Wt = Nt, Gt = i, Xt = s.getUint64, Kt = function (e) { return { isLeading: (12 & e[0]) >>> 2, dependsOn: 3 & e[0], isDependedOn: (192 & e[1]) >>> 6, hasRedundancy: (48 & e[1]) >>> 4, paddingValue: (14 & e[1]) >>> 1, isNonSyncSample: 1 & e[1], degradationPriority: e[2] << 8 | e[3] } }, Pe = "undefined" != typeof window ? window : "undefined" != typeof fe ? fe : "undefined" != typeof self ? self : {}, S = Pe, Yt = Oe.discardEmulationPreventionBytes, Qt = p.CaptionStream, L = Rt, Jt = Ut, Zt = Bt, ei = Ft, ti = S, ii = function (e, h) { var i = L(e, ["moof", "traf"]), e = L(e, ["mdat"]), u = {}, s = []; return e.forEach(function (e, t) { t = i[t]; s.push({ mdat: e, traf: t }) }), s.forEach(function (e) { var t, i, s, n, r, a = e.mdat, e = e.traf, o = L(e, ["tfhd"]), o = ei(o[0]), l = o.trackId, d = L(e, ["tfdt"]), d = 0 < d.length ? Jt(d[0]).baseMediaDecodeTime : 0, e = L(e, ["trun"]); h === l && 0 < e.length && (t = d, i = o.defaultSampleDuration || 0, s = o.defaultSampleSize || 0, n = o.trackId, r = [], e.forEach(function (e) { e = Zt(e).samples; e.forEach(function (e) { void 0 === e.duration && (e.duration = i), void 0 === e.size && (e.size = s), e.trackId = n, e.dts = t, void 0 === e.compositionTimeOffset && (e.compositionTimeOffset = 0), "bigint" == typeof t ? (e.pts = t + ti.BigInt(e.compositionTimeOffset), t += ti.BigInt(e.duration)) : (e.pts = t + e.compositionTimeOffset, t += e.duration) }), r = r.concat(e) }), d = function (e, t, i) { for (var s, n, r = new DataView(e.buffer, e.byteOffset, e.byteLength), a = { logs: [], seiNals: [] }, o = 0; o + 4 < e.length; o += s)if (s = r.getUint32(o), o += 4, !(s <= 0)) switch (31 & e[o]) { case 6: var l = e.subarray(o + 1, o + 1 + s), d = function (e, t) { for (var i = e, s = 0; s < t.length; s++) { var n = t[s]; if (i < n.size) return n; i -= n.size } return null }(o, t), l = { nalUnitType: "sei_rbsp", size: s, data: l, escapedRBSP: Yt(l), trackId: i }; if (d) l.pts = d.pts, l.dts = d.dts, n = d; else { if (!n) { a.logs.push({ level: "warn", message: "We've encountered a nal unit without data at " + o + " for trackId " + i + ". See mux.js#223." }); break } l.pts = n.pts, l.dts = n.dts } a.seiNals.push(l) }return a }(a, r, l), u[l] || (u[l] = { seiNals: [], logs: [] }), u[l].seiNals = u[l].seiNals.concat(d.seiNals), u[l].logs = u[l].logs.concat(d.logs)) }), u }, si = function () { var t, a, o, l, d, i, s = !1; this.isInitialized = function () { return s }, this.init = function (e) { t = new Qt, s = !0, i = !!e && e.isPartial, t.on("data", function (e) { e.startTime = e.startPts / l, e.endTime = e.endPts / l, d.captions.push(e), d.captionStreams[e.stream] = !0 }), t.on("log", function (e) { d.logs.push(e) }) }, this.isNewInit = function (e, t) { return !(e && 0 === e.length || t && "object" == typeof t && 0 === Object.keys(t).length || o === e[0] && l === t[o]) }, this.parse = function (e, t, i) { var s, n; if (!this.isInitialized()) return null; if (!t || !i) return null; if (this.isNewInit(t, i)) o = t[0], l = i[o]; else if (null === o || !l) return a.push(e), null; for (; 0 < a.length;) { var r = a.shift(); this.parse(r, t, i) } return e = e, n = l, (s = null === (s = o) ? null : { seiNals: (e = ii(e, s)[s] || {}).seiNals, logs: e.logs, timescale: n }) && s.logs && (d.logs = d.logs.concat(s.logs)), null !== s && s.seiNals ? (this.pushNals(s.seiNals), this.flushStream(), d) : d.logs.length ? { logs: d.logs, captions: [], captionStreams: [] } : null }, this.pushNals = function (e) { if (!this.isInitialized() || !e || 0 === e.length) return null; e.forEach(function (e) { t.push(e) }) }, this.flushStream = function () { if (!this.isInitialized()) return null; i ? t.partialFlush() : t.flush() }, this.clearParsedCaptions = function () { d.captions = [], d.captionStreams = {}, d.logs = [] }, this.resetCaptionStream = function () { if (!this.isInitialized()) return null; t.reset() }, this.clearAllCaptions = function () { this.clearParsedCaptions(), this.resetCaptionStream() }, this.reset = function () { a = [], l = o = null, d ? this.clearParsedCaptions() : d = { captions: [], captionStreams: {}, logs: [] }, this.resetCaptionStream() }, this.reset() }, ni = function (e) { for (var t = 0, i = String.fromCharCode(e[t]), s = ""; "\0" !== i;)s += i, t++, i = String.fromCharCode(e[t]); return s += i }, ri = s.getUint64, ai = function (e) { return void 0 !== e || null !== e }, oi = i, P = Le, D = Rt, li = Nt, di = { parseEmsgBox: function (e) { var t, i, s, n, r, a, o, l = 4, d = e[0], h = (0 === d ? (l = (l += (n = ni(e.subarray(l))).length) + (r = ni(e.subarray(l))).length, s = (h = new DataView(e.buffer)).getUint32(l), o = h.getUint32(l += 4), t = h.getUint32(l += 4), i = h.getUint32(l += 4), l += 4) : 1 === d && (s = (h = new DataView(e.buffer)).getUint32(l), a = ri(e.subarray(l += 4)), t = h.getUint32(l += 8), i = h.getUint32(l += 4), l = (l = (l += 4) + (n = ni(e.subarray(l))).length) + (r = ni(e.subarray(l))).length), { scheme_id_uri: n, value: r, timescale: s || 1, presentation_time: a, presentation_time_delta: o, event_duration: t, id: i, message_data: new Uint8Array(e.subarray(l, e.byteLength)) }); return r = "\0" !== (n = h).scheme_id_uri, a = 0 === (s = d) && ai(n.presentation_time_delta) && r, o = 1 === s && ai(n.presentation_time) && r, !(1 < s) && a || o ? h : void 0 }, scaleTime: function (e, t, i, s) { return e || 0 === e ? e / t : s + i / t } }, hi = s.getUint64, ui = S, ci = Ze.parseId3Frames, pi = function (e) { var t = 0 === e[0] ? 12 : 20; return oi(e[t] << 24 | e[1 + t] << 16 | e[2 + t] << 8 | e[3 + t]) }, mi = function (r, e) { e = D(e, ["moof", "traf"]).reduce(function (e, t) { var i = D(t, ["tfhd"])[0], i = oi(i[4] << 24 | i[5] << 16 | i[6] << 8 | i[7]), i = r[i] || 9e4, t = D(t, ["tfdt"])[0], s = new DataView(t.buffer, t.byteOffset, t.byteLength), t = 1 === t[0] ? hi(t.subarray(4, 12)) : s.getUint32(4); let n; return "bigint" == typeof t ? n = t / ui.BigInt(i) : "number" != typeof t || isNaN(t) || (n = t / i), e = (n = n < Number.MAX_SAFE_INTEGER ? Number(n) : n) < e ? n : e }, 1 / 0); return "bigint" == typeof e || isFinite(e) ? e : 0 }, gi = function (e) { var e = D(e, ["moov", "trak"]), r = []; return e.forEach(function (e) { var t, i = {}, s = D(e, ["tkhd"])[0], n = (s && (n = (s = new DataView(s.buffer, s.byteOffset, s.byteLength)).getUint8(0), i.id = 0 === n ? s.getUint32(12) : s.getUint32(20)), D(e, ["mdia", "hdlr"])[0]), n = (n && (s = li(n.subarray(8, 12)), i.type = "vide" === s ? "video" : "soun" === s ? "audio" : s), D(e, ["mdia", "minf", "stbl", "stsd"])[0]), s = (n && (s = n.subarray(8), i.codec = li(s.subarray(4, 8)), n = D(s, [i.codec])[0]) && (/^[asm]vc[1-9]$/i.test(i.codec) ? (t = n.subarray(78), "avcC" === li(t.subarray(4, 8)) && 11 < t.length ? (i.codec += ".", i.codec += P(t[9]), i.codec += P(t[10]), i.codec += P(t[11])) : i.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(i.codec) ? (t = n.subarray(28), "esds" === li(t.subarray(4, 8)) && 20 < t.length && 0 !== t[19] ? (i.codec += "." + P(t[19]), i.codec += "." + P(t[20] >>> 2 & 63).replace(/^0/, "")) : i.codec = "mp4a.40.2") : i.codec = i.codec.toLowerCase()), D(e, ["mdia", "mdhd"])[0]); s && (i.timescale = pi(s)), r.push(i) }), r }, fi = function (e, i = 0) { return D(e, ["emsg"]).map(e => { var e = di.parseEmsgBox(new Uint8Array(e)), t = ci(e.message_data); return { cueTime: di.scaleTime(e.presentation_time, e.timescale, e.presentation_time_delta, i), duration: di.scaleTime(e.event_duration, e.timescale), frames: t } }) }, yi = Ve, _i = Ve, O = Ye, M = {}, N = (M.ts = { parseType: function (e, t) { e = jt(e); return 0 === e ? "pat" : e === t ? "pmt" : t ? "pes" : null }, parsePat: function (e) { var t = Ht(e), i = 4 + Vt(e); return t && (i += e[i] + 1), (31 & e[i + 10]) << 8 | e[i + 11] }, parsePmt: function (e) { var t = {}, i = Ht(e), s = 4 + Vt(e); if (i && (s += e[s] + 1), 1 & e[s + 5]) { for (var n = 3 + ((15 & e[s + 1]) << 8 | e[s + 2]) - 4, r = 12 + ((15 & e[s + 10]) << 8 | e[s + 11]); r < n;) { var a = s + r; t[(31 & e[a + 1]) << 8 | e[a + 2]] = e[a], r += 5 + ((15 & e[a + 3]) << 8 | e[a + 4]) } return t } }, parsePayloadUnitStartIndicator: Ht, parsePesType: function (e, t) { switch (t[jt(e)]) { case yi.H264_STREAM_TYPE: return "video"; case yi.ADTS_STREAM_TYPE: return "audio"; case yi.METADATA_STREAM_TYPE: return "timed-metadata"; default: return null } }, parsePesTime: function (e) { var t, i, s; return !Ht(e) || (t = 4 + Vt(e)) >= e.byteLength ? null : (i = null, 192 & (s = e[t + 7]) && ((i = {}).pts = (14 & e[t + 9]) << 27 | (255 & e[t + 10]) << 20 | (254 & e[t + 11]) << 12 | (255 & e[t + 12]) << 5 | (254 & e[t + 13]) >>> 3, i.pts *= 4, i.pts += (6 & e[t + 13]) >>> 1, i.dts = i.pts, 64 & s) && (i.dts = (14 & e[t + 14]) << 27 | (255 & e[t + 15]) << 20 | (254 & e[t + 16]) << 12 | (255 & e[t + 17]) << 5 | (254 & e[t + 18]) >>> 3, i.dts *= 4, i.dts += (6 & e[t + 18]) >>> 1), i) }, videoPacketContainsKeyFrame: function (e) { for (var t = 4 + Vt(e), i = e.subarray(t), s = 0, n = 0, r = !1; n < i.byteLength - 3; n++)if (1 === i[n + 2]) { s = n + 5; break } for (; s < i.byteLength;)switch (i[s]) { case 0: if (0 !== i[s - 1]) s += 2; else if (0 !== i[s - 2]) s++; else { for (n + 3 !== s - 2 && "slice_layer_without_partitioning_rbsp_idr" === qt(31 & i[n + 3]) && (r = !0); 1 !== i[++s] && s < i.length;); n = s - 2, s += 3 } break; case 1: 0 !== i[s - 1] || 0 !== i[s - 2] ? s += 3 : ("slice_layer_without_partitioning_rbsp_idr" === qt(31 & i[n + 3]) && (r = !0), n = s - 2, s += 3); break; default: s += 3 }return i = i.subarray(n), s -= n, n = 0, r = i && 3 < i.byteLength && "slice_layer_without_partitioning_rbsp_idr" === qt(31 & i[n + 3]) ? !0 : r } }, M.aac = b, c.ONE_SECOND_IN_TS), vi = function (e, t) { for (var i, s = 0, n = 188; n < e.byteLength;)if (71 === e[s] && 71 === e[n]) { switch (i = e.subarray(s, n), M.ts.parseType(i, t.pid)) { case "pat": t.pid = M.ts.parsePat(i); break; case "pmt": var r = M.ts.parsePmt(i); t.table = t.table || {}, Object.keys(r).forEach(function (e) { t.table[e] = r[e] }) }s += 188, n += 188 } else s++, n++ }, bi = function (e, t, i) { for (var s, n, r, a, o = 0, l = 188, d = !1; l <= e.byteLength;)if (71 !== e[o] || 71 !== e[l] && l !== e.byteLength) o++, l++; else { if (s = e.subarray(o, l), "pes" === M.ts.parseType(s, t.pid) && (n = M.ts.parsePesType(s, t.table), r = M.ts.parsePayloadUnitStartIndicator(s), "audio" === n) && r && (a = M.ts.parsePesTime(s)) && (a.type = "audio", i.audio.push(a), d = !0), d) break; o += 188, l += 188 } for (o = (l = e.byteLength) - 188, d = !1; 0 <= o;)if (71 !== e[o] || 71 !== e[l] && l !== e.byteLength) o--, l--; else { if (s = e.subarray(o, l), "pes" === M.ts.parseType(s, t.pid) && (n = M.ts.parsePesType(s, t.table), r = M.ts.parsePayloadUnitStartIndicator(s), "audio" === n) && r && (a = M.ts.parsePesTime(s)) && (a.type = "audio", i.audio.push(a), d = !0), d) break; o -= 188, l -= 188 } }, Ti = function (e, t, i) { for (var s, n, r, a, o, l, d, h, u = 0, c = 188, p = !1, m = { data: [], size: 0 }; c < e.byteLength;)if (71 === e[u] && 71 === e[c]) { if (s = e.subarray(u, c), "pes" === M.ts.parseType(s, t.pid)) if (n = M.ts.parsePesType(s, t.table), r = M.ts.parsePayloadUnitStartIndicator(s), "video" === n && (r && !p && (a = M.ts.parsePesTime(s)) && (a.type = "video", i.video.push(a), p = !0), !i.firstKeyFrame)) { if (r && 0 !== m.size) { for (o = new Uint8Array(m.size), l = 0; m.data.length;)d = m.data.shift(), o.set(d, l), l += d.byteLength; M.ts.videoPacketContainsKeyFrame(o) && (h = M.ts.parsePesTime(o)) && (i.firstKeyFrame = h, i.firstKeyFrame.type = "video"), m.size = 0 } m.data.push(s), m.size += s.byteLength } if (p && i.firstKeyFrame) break; u += 188, c += 188 } else u++, c++; for (u = (c = e.byteLength) - 188, p = !1; 0 <= u;)if (71 === e[u] && 71 === e[c]) { if (s = e.subarray(u, c), "pes" === M.ts.parseType(s, t.pid) && (n = M.ts.parsePesType(s, t.table), r = M.ts.parsePayloadUnitStartIndicator(s), "video" === n) && r && (a = M.ts.parsePesTime(s)) && (a.type = "video", i.video.push(a), p = !0), p) break; u -= 188, c -= 188 } else u--, c-- }, Si = function (e, t) { var i, s, n, e = (M.aac.isLikelyAacData(e) ? function (e) { for (var t, i, s = !1, n = 0, r = null, a = null, o = 0, l = 0; 3 <= e.length - l;) { switch (M.aac.parseType(e, l)) { case "timed-metadata": e.length - l < 10 ? s = !0 : (o = M.aac.parseId3TagSize(e, l)) > e.length ? s = !0 : (null === a && (t = e.subarray(l, l + o), a = M.aac.parseAacTimestamp(t)), l += o); break; case "audio": e.length - l < 7 ? s = !0 : (o = M.aac.parseAdtsSize(e, l)) > e.length ? s = !0 : (null === r && (t = e.subarray(l, l + o), r = M.aac.parseSampleRate(t)), n++, l += o); break; default: l++ }if (s) return null } return null === r || null === a ? null : { audio: [{ type: "audio", dts: a, pts: a }, { type: "audio", dts: a + 1024 * n * (i = N / r), pts: a + 1024 * n * i }] } } : function (e) { var t, i = { pid: null, table: null }, s = {}; for (t in vi(e, i), i.table) if (i.table.hasOwnProperty(t)) switch (i.table[t]) { case _i.H264_STREAM_TYPE: s.video = [], Ti(e, i, s), 0 === s.video.length && delete s.video; break; case _i.ADTS_STREAM_TYPE: s.audio = [], bi(e, i, s), 0 === s.audio.length && delete s.audio }return s })(e); return e && (e.audio || e.video) ? (t = t, (i = e).audio && i.audio.length && ("undefined" != typeof (s = t) && !isNaN(s) || (s = i.audio[0].dts), i.audio.forEach(function (e) { e.dts = O(e.dts, s), e.pts = O(e.pts, s), e.dtsTime = e.dts / N, e.ptsTime = e.pts / N })), i.video && i.video.length && ("undefined" != typeof (n = t) && !isNaN(n) || (n = i.video[0].dts), i.video.forEach(function (e) { e.dts = O(e.dts, n), e.pts = O(e.pts, n), e.dtsTime = e.dts / N, e.ptsTime = e.pts / N }), i.firstKeyFrame) && ((t = i.firstKeyFrame).dts = O(t.dts, n), t.pts = O(t.pts, n), t.dtsTime = t.dts / N, t.ptsTime = t.pts / N), e) : null }; class wi { constructor(e, t) { this.options = t || {}, this.self = e, this.init() } init() { var i, e; this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new zt(this.options), i = this.self, (e = this.transmuxer).on("data", function (e) { var t = e.initSegment, t = (e.initSegment = { data: t.buffer, byteOffset: t.byteOffset, byteLength: t.byteLength }, e.data); e.data = t.buffer, i.postMessage({ action: "data", segment: e, byteOffset: t.byteOffset, byteLength: t.byteLength }, [e.data]) }), e.on("done", function (e) { i.postMessage({ action: "done" }) }), e.on("gopInfo", function (e) { i.postMessage({ action: "gopInfo", gopInfo: e }) }), e.on("videoSegmentTimingInfo", function (e) { var t = { start: { decode: c.videoTsToSeconds(e.start.dts), presentation: c.videoTsToSeconds(e.start.pts) }, end: { decode: c.videoTsToSeconds(e.end.dts), presentation: c.videoTsToSeconds(e.end.pts) }, baseMediaDecodeTime: c.videoTsToSeconds(e.baseMediaDecodeTime) }; e.prependedContentDuration && (t.prependedContentDuration = c.videoTsToSeconds(e.prependedContentDuration)), i.postMessage({ action: "videoSegmentTimingInfo", videoSegmentTimingInfo: t }) }), e.on("audioSegmentTimingInfo", function (e) { var t = { start: { decode: c.videoTsToSeconds(e.start.dts), presentation: c.videoTsToSeconds(e.start.pts) }, end: { decode: c.videoTsToSeconds(e.end.dts), presentation: c.videoTsToSeconds(e.end.pts) }, baseMediaDecodeTime: c.videoTsToSeconds(e.baseMediaDecodeTime) }; e.prependedContentDuration && (t.prependedContentDuration = c.videoTsToSeconds(e.prependedContentDuration)), i.postMessage({ action: "audioSegmentTimingInfo", audioSegmentTimingInfo: t }) }), e.on("id3Frame", function (e) { i.postMessage({ action: "id3Frame", id3Frame: e }) }), e.on("caption", function (e) { i.postMessage({ action: "caption", caption: e }) }), e.on("trackinfo", function (e) { i.postMessage({ action: "trackinfo", trackInfo: e }) }), e.on("audioTimingInfo", function (e) { i.postMessage({ action: "audioTimingInfo", audioTimingInfo: { start: c.videoTsToSeconds(e.start), end: c.videoTsToSeconds(e.end) } }) }), e.on("videoTimingInfo", function (e) { i.postMessage({ action: "videoTimingInfo", videoTimingInfo: { start: c.videoTsToSeconds(e.start), end: c.videoTsToSeconds(e.end) } }) }), e.on("log", function (e) { i.postMessage({ action: "log", log: e }) }) } pushMp4Captions(e) { this.captionParser || (this.captionParser = new si, this.captionParser.init()); var t = new Uint8Array(e.data, e.byteOffset, e.byteLength), e = this.captionParser.parse(t, e.trackIds, e.timescales); this.self.postMessage({ action: "mp4Captions", captions: e && e.captions || [], logs: e && e.logs || [], data: t.buffer }, [t.buffer]) } probeMp4StartTime({ timescales: e, data: t }) { e = mi(e, t); this.self.postMessage({ action: "probeMp4StartTime", startTime: e, data: t }, [t.buffer]) } probeMp4Tracks({ data: e }) { var t = gi(e); this.self.postMessage({ action: "probeMp4Tracks", tracks: t, data: e }, [e.buffer]) } probeEmsgID3({ data: e, offset: t }) { t = fi(e, t); this.self.postMessage({ action: "probeEmsgID3", id3Frames: t, emsgData: e }, [e.buffer]) } probeTs({ data: e, baseStartTime: t }) { t = "number" != typeof t || isNaN(t) ? void 0 : t * c.ONE_SECOND_IN_TS, t = Si(e, t); let i = null; t && ((i = { hasVideo: t.video && 2 === t.video.length || !1, hasAudio: t.audio && 2 === t.audio.length || !1 }).hasVideo && (i.videoStart = t.video[0].ptsTime), i.hasAudio) && (i.audioStart = t.audio[0].ptsTime), this.self.postMessage({ action: "probeTs", result: i, data: e }, [e.buffer]) } clearAllMp4Captions() { this.captionParser && this.captionParser.clearAllCaptions() } clearParsedMp4Captions() { this.captionParser && this.captionParser.clearParsedCaptions() } push(e) { e = new Uint8Array(e.data, e.byteOffset, e.byteLength); this.transmuxer.push(e) } reset() { this.transmuxer.reset() } setTimestampOffset(e) { e = e.timestampOffset || 0; this.transmuxer.setBaseMediaDecodeTime(Math.round(c.secondsToVideoTs(e))) } setAudioAppendStart(e) { this.transmuxer.setAudioAppendStart(Math.ceil(c.secondsToVideoTs(e.appendStart))) } setRemux(e) { this.transmuxer.setRemux(e.remux) } flush(e) { this.transmuxer.flush(), self.postMessage({ action: "done", type: "transmuxed" }) } endTimeline() { this.transmuxer.endTimeline(), self.postMessage({ action: "endedtimeline", type: "transmuxed" }) } alignGopsWith(e) { this.transmuxer.alignGopsWith(e.gopsToAlignWith.slice()) } } self.onmessage = function (e) { "init" === e.data.action && e.data.options ? this.messageHandlers = new wi(self, e.data.options) : (this.messageHandlers || (this.messageHandlers = new wi(self)), e.data && e.data.action && "init" !== e.data.action && this.messageHandlers[e.data.action] && this.messageHandlers[e.data.action](e.data)) } }))); const rh = (e, t, i) => { var { type: s, initSegment: n, captions: r, captionStreams: a, metadata: o, videoFrameDtsTime: l, videoFramePtsTime: d } = e.data.segment, t = (t.buffer.push({ captions: r, captionStreams: a, metadata: o }), e.data.segment.boxes || { data: e.data.segment.data }), r = { type: s, data: new Uint8Array(t.data, t.data.byteOffset, t.data.byteLength), initSegment: new Uint8Array(n.data, n.byteOffset, n.byteLength) }; "undefined" != typeof l && (r.videoFrameDtsTime = l), "undefined" != typeof d && (r.videoFramePtsTime = d), i(r) }, ah = ({ transmuxedData: e, callback: t }) => { e.buffer = [], t(e) }, oh = (e, t) => { t.gopInfo = e.data.gopInfo }, lh = t => { const { transmuxer: i, bytes: e, audioAppendStart: s, gopsToAlignWith: n, remux: r, onData: a, onTrackInfo: o, onAudioTimingInfo: l, onVideoTimingInfo: d, onVideoSegmentTimingInfo: h, onAudioSegmentTimingInfo: u, onId3: c, onCaptions: p, onDone: m, onEndedTimeline: g, onTransmuxerLog: f, isEndOfTimeline: y } = t, _ = { buffer: [] }; let v = y; var b, T; i.onmessage = e => { i.currentTransmux !== t || ("data" === e.data.action && rh(e, _, a), "trackinfo" === e.data.action && o(e.data.trackInfo), "gopInfo" === e.data.action && oh(e, _), "audioTimingInfo" === e.data.action && l(e.data.audioTimingInfo), "videoTimingInfo" === e.data.action && d(e.data.videoTimingInfo), "videoSegmentTimingInfo" === e.data.action && h(e.data.videoSegmentTimingInfo), "audioSegmentTimingInfo" === e.data.action && u(e.data.audioSegmentTimingInfo), "id3Frame" === e.data.action && c([e.data.id3Frame], e.data.id3Frame.dispatchType), "caption" === e.data.action && p(e.data.caption), "endedtimeline" === e.data.action && (v = !1, g()), "log" === e.data.action && f(e.data.log), "transmuxed" !== e.data.type) || v || (i.onmessage = null, ah({ transmuxedData: _, callback: m }), dh(i)) }, s && i.postMessage({ action: "setAudioAppendStart", appendStart: s }), Array.isArray(n) && i.postMessage({ action: "alignGopsWith", gopsToAlignWith: n }), "undefined" != typeof r && i.postMessage({ action: "setRemux", remux: r }), e.byteLength && (b = e instanceof ArrayBuffer ? e : e.buffer, T = e instanceof ArrayBuffer ? 0 : e.byteOffset, i.postMessage({ action: "push", data: b, byteOffset: T, byteLength: e.byteLength }, [b])), y && i.postMessage({ action: "endTimeline" }), i.postMessage({ action: "flush" }) }, dh = e => { e.currentTransmux = null, e.transmuxQueue.length && (e.currentTransmux = e.transmuxQueue.shift(), "function" == typeof e.currentTransmux ? e.currentTransmux() : lh(e.currentTransmux)) }, hh = (e, t) => { e.postMessage({ action: t }), dh(e) }, uh = (e, t) => { t.currentTransmux ? t.transmuxQueue.push(hh.bind(null, t, e)) : (t.currentTransmux = e, hh(t, e)) }; const ch = e => { e.transmuxer.currentTransmux ? e.transmuxer.transmuxQueue.push(e) : (e.transmuxer.currentTransmux = e, lh(e)) }; var ph = e => { uh("reset", e) }, mh = (ch, e => { const t = new nh, i = (t.currentTransmux = null, t.transmuxQueue = [], t.terminate); return t.terminate = () => (t.currentTransmux = null, t.transmuxQueue.length = 0, i.call(t)), t.postMessage({ action: "init", options: e }), t }); function gh(t) { const i = t.transmuxer, s = t.endAction || t.action, n = t.callback; var e, r = yi({}, t, { endAction: null, transmuxer: null, callback: null }); const a = e => { e.data.action === s && (i.removeEventListener("message", a), e.data.data && (e.data.data = new Uint8Array(e.data.data, t.byteOffset || 0, t.byteLength || e.data.data.byteLength), t.data) && (t.data = e.data.data), n(e.data)) }; i.addEventListener("message", a), t.data ? (e = t.data instanceof ArrayBuffer, r.byteOffset = e ? 0 : t.data.byteOffset, r.byteLength = t.data.byteLength, e = [e ? t.data : t.data.buffer], i.postMessage(r, e)) : i.postMessage(r) } function fh(e) { let t = 0; return e.audio && t++, e.video && t++, t } function yh(e, t) { var i = t.attributes || {}, s = Mh(function (e) { e = e.attributes || {}; if (e.CODECS) return Fr(e.CODECS) }(t) || []); return !Oh(e, t) || s.audio || ((e, t) => { if (!Oh(e, t)) return !0; var t = t.attributes || {}, i = e.mediaGroups.AUDIO[t.AUDIO]; for (const s in i) if (!i[s].uri && !i[s].playlists) return !0; return !1 })(e, t) || (t = Mh(function (e, t) { if (e.mediaGroups.AUDIO && t) { var i = e.mediaGroups.AUDIO[t]; if (i) for (var s in i) { s = i[s]; if (s.default && s.playlists) return Fr(s.playlists[0].attributes.CODECS) } } return null }(e, i.AUDIO) || [])).audio && (s.audio = t.audio), s } function _h(e, t) { return (e = e && window.getComputedStyle(e)) ? e[t] : "" } function vh(e, t) { let i, s; return i = (i = e.attributes.BANDWIDTH ? e.attributes.BANDWIDTH : i) || window.Number.MAX_VALUE, s = (s = t.attributes.BANDWIDTH ? t.attributes.BANDWIDTH : s) || window.Number.MAX_VALUE, i - s } const bh = { FAILURE: 2, TIMEOUT: -101, ABORTED: -102 }, Th = e => { e.forEach(e => { e.abort() }) }, Sh = e => ({ bandwidth: e.bandwidth, bytesReceived: e.bytesReceived || 0, roundTripTime: e.roundTripTime || 0 }), wh = e => { var t = e.target, t = { bandwidth: 1 / 0, bytesReceived: 0, roundTripTime: Date.now() - t.requestTime || 0 }; return t.bytesReceived = e.loaded, t.bandwidth = Math.floor(t.bytesReceived / t.roundTripTime * 8 * 1e3), t }, Eh = (e, t) => t.timedout ? { status: t.status, message: "HLS request timed-out at URL: " + t.uri, code: bh.TIMEOUT, xhr: t } : t.aborted ? { status: t.status, message: "HLS request aborted at URL: " + t.uri, code: bh.ABORTED, xhr: t } : e ? { status: t.status, message: "HLS request errored at URL: " + t.uri, code: bh.FAILURE, xhr: t } : "arraybuffer" === t.responseType && 0 === t.response.byteLength ? { status: t.status, message: "Empty HLS response at URL: " + t.uri, code: bh.FAILURE, xhr: t } : null, Ch = (n, r, a) => (e, t) => { var i = t.response, e = Eh(e, t); if (e) return a(e, n); if (16 !== i.byteLength) return a({ status: t.status, message: "Invalid HLS key at URL: " + t.uri, code: bh.FAILURE, xhr: t }, n); var e = new DataView(i), s = new Uint32Array([e.getUint32(0), e.getUint32(4), e.getUint32(8), e.getUint32(12)]); for (let e = 0; e < r.length; e++)r[e].bytes = s; return a(null, n) }, kh = (i, s) => { var e, t = Tl(i.map.bytes); if ("mp4" !== t) return e = i.map.resolvedUri || i.map.uri, s({ internal: !0, message: `Found unsupported ${t || "unknown"} container for initialization segment at URL: ` + e, code: bh.FAILURE }); gh({ action: "probeMp4Tracks", data: i.map.bytes, transmuxer: i.transmuxer, callback: ({ tracks: e, data: t }) => (i.map.bytes = t, e.forEach(function (e) { i.map.tracks = i.map.tracks || {}, i.map.tracks[e.type] || "number" == typeof (i.map.tracks[e.type] = e).id && e.timescale && (i.map.timescales = i.map.timescales || {}, i.map.timescales[e.id] = e.timescale) }), s(null)) }) }, Ih = ({ segment: i, bytes: t, trackInfoFn: s, timingInfoFn: e, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: r, id3Fn: a, captionsFn: o, isEndOfTimeline: l, endedTimelineFn: d, dataFn: h, doneFn: u, onTransmuxerLog: c }) => { var p = i.map && i.map.tracks || {}; const m = Boolean(p.audio && p.video); let g = e.bind(null, i, "audio", "start"); const f = e.bind(null, i, "audio", "end"); let y = e.bind(null, i, "video", "start"); const _ = e.bind(null, i, "video", "end"); gh({ action: "probeTs", transmuxer: i.transmuxer, data: t, baseStartTime: i.baseStartTime, callback: e => { i.bytes = t = e.data; e = e.result; e && (s(i, { hasAudio: e.hasAudio, hasVideo: e.hasVideo, isMuxed: m }), s = null, e.hasAudio && !m && g(e.audioStart), e.hasVideo && y(e.videoStart), g = null, y = null), ch({ bytes: t, transmuxer: i.transmuxer, audioAppendStart: i.audioAppendStart, gopsToAlignWith: i.gopsToAlignWith, remux: m, onData: e => { e.type = "combined" === e.type ? "video" : e.type, h(i, e) }, onTrackInfo: e => { s && (m && (e.isMuxed = !0), s(i, e)) }, onAudioTimingInfo: e => { g && "undefined" != typeof e.start && (g(e.start), g = null), f && "undefined" != typeof e.end && f(e.end) }, onVideoTimingInfo: e => { y && "undefined" != typeof e.start && (y(e.start), y = null), _ && "undefined" != typeof e.end && _(e.end) }, onVideoSegmentTimingInfo: e => { n(e) }, onAudioSegmentTimingInfo: e => { r(e) }, onId3: (e, t) => { a(i, e, t) }, onCaptions: e => { o(i, [e]) }, isEndOfTimeline: l, onEndedTimeline: () => { d() }, onTransmuxerLog: c, onDone: e => { u && (e.type = "combined" === e.type ? "video" : e.type, u(null, i, e)) } }) } }) }, xh = ({ segment: s, bytes: n, trackInfoFn: e, timingInfoFn: t, videoSegmentTimingInfoFn: i, audioSegmentTimingInfoFn: r, id3Fn: a, captionsFn: o, isEndOfTimeline: l, endedTimelineFn: d, dataFn: h, doneFn: u, onTransmuxerLog: c }) => { let p = new Uint8Array(n); if (m = p, 0 < yl(m, ["moof"]).length) { s.isFmp4 = !0; const g = s.map["tracks"], f = { isFmp4: !0, hasVideo: !!g.video, hasAudio: !!g.audio }, y = (g.audio && g.audio.codec && "enca" !== g.audio.codec && (f.audioCodec = g.audio.codec), g.video && g.video.codec && "encv" !== g.video.codec && (f.videoCodec = g.video.codec), g.video && g.audio && (f.isMuxed = !0), e(s, f), (e, t) => { h(s, { data: p, type: f.hasAudio && !f.isMuxed ? "audio" : "video" }), t && t.length && a(s, t), e && e.length && o(s, e), u(null, s, {}) }); void gh({ action: "probeMp4StartTime", timescales: s.map.timescales, data: p, transmuxer: s.transmuxer, callback: ({ data: i, startTime: e }) => { n = i.buffer, s.bytes = p = i, f.hasAudio && !f.isMuxed && t(s, "audio", "start", e), f.hasVideo && t(s, "video", "start", e), gh({ action: "probeEmsgID3", data: p, transmuxer: s.transmuxer, offset: e, callback: ({ emsgData: e, id3Frames: t }) => { n = e.buffer, s.bytes = p = e, g.video && i.byteLength && s.transmuxer ? gh({ action: "pushMp4Captions", endAction: "mp4Captions", transmuxer: s.transmuxer, data: p, timescales: s.map.timescales, trackIds: [g.video.id], callback: e => { n = e.data.buffer, s.bytes = p = e.data, e.logs.forEach(function (e) { c(D(e, { stream: "mp4CaptionParser" })) }), y(e.captions, t) } }) : y(void 0, t) } }) } }) } else { var m; s.transmuxer ? ("undefined" == typeof s.container && (s.container = Tl(p)), "ts" !== s.container && "aac" !== s.container ? (e(s, { hasAudio: !1, hasVideo: !1 }), u(null, s, {})) : Ih({ segment: s, bytes: n, trackInfoFn: e, timingInfoFn: t, videoSegmentTimingInfoFn: i, audioSegmentTimingInfoFn: r, id3Fn: a, captionsFn: o, isEndOfTimeline: l, endedTimelineFn: d, dataFn: h, doneFn: u, onTransmuxerLog: c })) : u(null, s, {}) } }, Ah = function ({ id: t, key: e, encryptedBytes: i, decryptionWorker: s }, n) { const r = e => { e.data.source === t && (s.removeEventListener("message", r), e = e.data.decrypted, n(new Uint8Array(e.bytes, e.byteOffset, e.byteLength))) }; s.addEventListener("message", r); let a; a = e.bytes.slice ? e.bytes.slice() : new Uint32Array(Array.prototype.slice.call(e.bytes)), s.postMessage(Nd({ source: t, encrypted: i, key: a, iv: e.iv }), [i.buffer, a.buffer]) }, Lh = ({ decryptionWorker: e, segment: t, trackInfoFn: i, timingInfoFn: s, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: r, id3Fn: a, captionsFn: o, isEndOfTimeline: l, endedTimelineFn: d, dataFn: h, doneFn: u, onTransmuxerLog: c }) => { Ah({ id: t.requestId, key: t.key, encryptedBytes: t.encryptedBytes, decryptionWorker: e }, e => { t.bytes = e, xh({ segment: t, bytes: t.bytes, trackInfoFn: i, timingInfoFn: s, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: r, id3Fn: a, captionsFn: o, isEndOfTimeline: l, endedTimelineFn: d, dataFn: h, doneFn: u, onTransmuxerLog: c }) }) }, Ph = ({ xhr: e, xhrOptions: t, decryptionWorker: i, segment: s, abortFn: n, progressFn: r, trackInfoFn: a, timingInfoFn: o, videoSegmentTimingInfoFn: l, audioSegmentTimingInfoFn: d, id3Fn: h, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: p, dataFn: m, doneFn: g, onTransmuxerLog: f }) => { const y = []; var _, v, i = (({ activeXhrs: s, decryptionWorker: n, trackInfoFn: r, timingInfoFn: a, videoSegmentTimingInfoFn: o, audioSegmentTimingInfoFn: l, id3Fn: d, captionsFn: h, isEndOfTimeline: u, endedTimelineFn: c, dataFn: p, doneFn: m, onTransmuxerLog: g }) => { let f = 0, y = !1; return (e, t) => { if (!y) { if (e) return y = !0, Th(s), m(e, t); if ((f += 1) === s.length) { const i = function () { if (t.encryptedBytes) return Lh({ decryptionWorker: n, segment: t, trackInfoFn: r, timingInfoFn: a, videoSegmentTimingInfoFn: o, audioSegmentTimingInfoFn: l, id3Fn: d, captionsFn: h, isEndOfTimeline: u, endedTimelineFn: c, dataFn: p, doneFn: m, onTransmuxerLog: g }); xh({ segment: t, bytes: t.bytes, trackInfoFn: r, timingInfoFn: a, videoSegmentTimingInfoFn: o, audioSegmentTimingInfoFn: l, id3Fn: d, captionsFn: h, isEndOfTimeline: u, endedTimelineFn: c, dataFn: p, doneFn: m, onTransmuxerLog: g }) }; if (t.endOfAllRequests = Date.now(), t.map && t.map.encryptedBytes && !t.map.bytes) return Ah({ decryptionWorker: n, id: t.requestId + "-init", encryptedBytes: t.map.encryptedBytes, key: t.map.key }, e => { t.map.bytes = e, kh(t, e => { if (e) return Th(s), m(e, t); i() }) }); i() } } } })({ activeXhrs: y, decryptionWorker: i, trackInfoFn: a, timingInfoFn: o, videoSegmentTimingInfoFn: l, audioSegmentTimingInfoFn: d, id3Fn: h, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: p, dataFn: m, doneFn: g, onTransmuxerLog: f }), u = (s.key && !s.key.bytes && (a = [s.key], s.map && !s.map.bytes && s.map.key && s.map.key.resolvedUri === s.key.resolvedUri && a.push(s.map.key), o = e(D(t, { uri: s.key.resolvedUri, responseType: "arraybuffer" }), Ch(s, a, i)), y.push(o)), s.map && !s.map.bytes && (!s.map.key || s.key && s.key.resolvedUri === s.map.key.resolvedUri || (l = e(D(t, { uri: s.map.key.resolvedUri, responseType: "arraybuffer" }), Ch(s, [s.map.key], i)), y.push(l)), d = D(t, { uri: s.map.resolvedUri, responseType: "arraybuffer", headers: Dd(s.map) }), { segment: _, finishProcessingFn: v } = [{ segment: s, finishProcessingFn: i }][0], h = e(d, (e, t) => { var e = Eh(e, t); return e ? v(e, _) : (e = new Uint8Array(t.response), _.map.key ? (_.map.encryptedBytes = e, v(null, _)) : (_.map.bytes = e, void kh(_, function (e) { if (e) return e.xhr = t, e.status = t.status, v(e, _); v(null, _) }))) }), y.push(h)), D(t, { uri: s.part && s.part.resolvedUri || s.resolvedUri, responseType: "arraybuffer", headers: Dd(s) })); ({ segment: b, finishProcessingFn: T, responseType: S } = { segment: s, finishProcessingFn: i, responseType: u.responseType }); var b, T, S, w, E, c = e(u, (e, t) => { var e = Eh(e, t); return e ? T(e, b) : (e = "arraybuffer" !== S && t.responseText ? eh(t.responseText.substring(b.lastReachedChar || 0)) : t.response, b.stats = Sh(t), b.key ? b.encryptedBytes = new Uint8Array(e) : b.bytes = new Uint8Array(e), T(null, b)) }); c.addEventListener("progress", ({ segment: w, progressFn: E } = [{ segment: s, progressFn: r }][0], e => { var t = e.target; if (!t.aborted) return w.stats = D(w.stats, wh(e)), !w.stats.firstBytesReceivedAt && w.stats.bytesReceived && (w.stats.firstBytesReceivedAt = Date.now()), E(e, w) })), y.push(c); const C = {}; return y.forEach(e => { var t, i; e.addEventListener("loadend", ({ loadendState: t, abortFn: i } = [{ loadendState: C, abortFn: n }][0], e => { e.target.aborted && i && !t.calledAbortFn && (i(), t.calledAbortFn = !0) })) }), () => Th(y) }, Dh = Hl("CodecUtils"), Oh = (e, t) => { t = t.attributes || {}; return e && e.mediaGroups && e.mediaGroups.AUDIO && t.AUDIO && e.mediaGroups.AUDIO[t.AUDIO] }, Mh = function (e) { const s = {}; return e.forEach(({ mediaType: e, type: t, details: i }) => { s[e] = s[e] || [], s[e].push(Br("" + t + i)) }), Object.keys(s).forEach(function (e) { 1 < s[e].length ? (Dh(`multiple ${e} codecs found as attributes: ${s[e].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`), s[e] = null) : s[e] = s[e][0] }), s }, Nh = Hl("PlaylistSelector"), Rh = function (e) { var t; if (e && e.playlist) return t = e.playlist, JSON.stringify({ id: t.id, bandwidth: e.bandwidth, width: e.width, height: e.height, codecs: t.attributes && t.attributes.CODECS || "" }) }, Uh = function (e, s) { const n = e.slice(); e.sort(function (e, t) { var i = s(e, t); return 0 === i ? n.indexOf(e) - n.indexOf(t) : i }) }; function Bh(o, t, l, d, h, u) { if (o) { var c = { bandwidth: t, width: l, height: d, limitRenditionByPlayerDimensions: h }; let e = o.playlists, n = (yd.isAudioOnly(o) && (e = u.getAudioTrackPlaylists_(), c.audioOnly = !0), e.map(e => { var t = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.width, i = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height, s = e.attributes && e.attributes.BANDWIDTH; return { bandwidth: s || window.Number.MAX_VALUE, width: t, height: i, playlist: e } })), r = (Uh(n, (e, t) => e.bandwidth - t.bandwidth), (n = n.filter(e => !yd.isIncompatible(e.playlist))).filter(e => yd.isEnabled(e.playlist))); o = (r = r.length ? r : n.filter(e => !yd.isDisabled(e.playlist))).filter(e => e.bandwidth * O.BANDWIDTH_VARIANCE < t); let a = o[o.length - 1]; var p = o.filter(e => e.bandwidth === a.bandwidth)[0]; if (!1 === h) { const g = p || r[0] || n[0]; if (g && g.playlist) { let e = p ? "bandwidthBestRep" : "sortedPlaylistReps"; return r[0] && (e = "enabledPlaylistReps"), Nh(`choosing ${Rh(g)} using ${e} with options`, c), g.playlist } } else { var m, h = o.filter(e => e.width && e.height), o = (Uh(h, (e, t) => e.width - t.width), h.filter(e => e.width === l && e.height === d)), o = (a = o[o.length - 1], o.filter(e => e.bandwidth === a.bandwidth)[0]); let t, i; o || (m = (t = h.filter(e => e.width > l || e.height > d)).filter(e => e.width === t[0].width && e.height === t[0].height), a = m[m.length - 1], i = m.filter(e => e.bandwidth === a.bandwidth)[0]); let s; u.leastPixelDiffSelector && (m = h.map(e => (e.pixelDiff = Math.abs(e.width - l) + Math.abs(e.height - d), e)), Uh(m, (e, t) => e.pixelDiff === t.pixelDiff ? t.bandwidth - e.bandwidth : e.pixelDiff - t.pixelDiff), s = m[0]); const g = s || i || o || p || r[0] || n[0]; if (g && g.playlist) { let e = "sortedPlaylistReps"; return s ? e = "leastPixelDiffRep" : i ? e = "resolutionPlusOneRep" : o ? e = "resolutionBestRep" : p ? e = "bandwidthBestRep" : r[0] && (e = "enabledPlaylistReps"), Nh(`choosing ${Rh(g)} using ${e} with options`, c), g.playlist } } return Nh("could not choose a playlist with options", c), null } } function Fh() { var e = this.useDevicePixelRatio && window.devicePixelRatio || 1; return Bh(this.playlists.main, this.systemBandwidth, parseInt(_h(this.tech_.el(), "width"), 10) * e, parseInt(_h(this.tech_.el(), "height"), 10) * e, this.limitRenditionByPlayerDimensions, this.playlistController_) } function jh(e, t, i) { let s; var n; if (i && i.cues) for (s = i.cues.length; s--;)(n = i.cues[s]).startTime >= e && n.endTime <= t && i.removeCue(n) } const Hh = ({ inbandTextTracks: e, metadataArray: t, timestampOffset: i, videoDuration: s }) => { if (t) { const a = window.WebKitDataCue || window.VTTCue, o = e.metadataTrack_; if (o && (t.forEach(e => { const s = e.cueTime + i; !("number" != typeof s || window.isNaN(s) || s < 0) && s < 1 / 0 && e.frames && e.frames.length && e.frames.forEach(e => { var t, i = new a(s, s, e.value || e.url || e.data || ""); i.frame = e, i.value = e, t = i, Object.defineProperties(t.frame, { id: { get() { return T.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), t.value.key } }, value: { get() { return T.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), t.value.data } }, privateData: { get() { return T.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), t.value.data } } }), o.addCue(i) }) }), o.cues) && o.cues.length) { var n = o.cues, r = []; for (let e = 0; e < n.length; e++)n[e] && r.push(n[e]); const l = r.reduce((e, t) => { var i = e[t.startTime] || []; return i.push(t), e[t.startTime] = i, e }, {}), d = Object.keys(l).sort((e, t) => Number(e) - Number(t)); d.forEach((e, t) => { e = l[e]; const i = Number(d[t + 1]) || s; e.forEach(e => { e.endTime = i }) }) } } }, Vh = e => "number" == typeof e && isFinite(e), qh = e => { var { startOfSegment: t, duration: i, segment: s, part: n, playlist: { mediaSequence: r, id: a, segments: o = [] }, mediaIndex: l, partIndex: d, timeline: h } = e, o = o.length - 1; let u = "mediaIndex/partIndex increment"; e.getMediaInfoForTime ? u = `getMediaInfoForTime (${e.getMediaInfoForTime})` : e.isSyncRequest && (u = "getSyncSegmentCandidate (isSyncRequest)"), e.independent && (u += " with independent " + e.independent); var c = "number" == typeof d, e = e.segment.uri ? "segment" : "pre-segment", p = c ? sd({ preloadSegment: s }) - 1 : 0; return e + ` [${r + l}/${r + o}]` + (c ? ` part [${d}/${p}]` : "") + ` segment start/end [${s.start} => ${s.end}]` + (c ? ` part start/end [${n.start} => ${n.end}]` : "") + ` startOfSegment [${t}]` + ` duration [${i}]` + ` timeline [${h}]` + ` selected by [${u}]` + ` playlist [${a}]` }, zh = e => e + "TimingInfo", $h = ({ timelineChangeController: e, currentTimeline: t, segmentTimeline: i, loaderType: s, audioDisabled: n }) => { return !(t === i || ("audio" === s ? (t = e.lastTimelineChange({ type: "main" })) && t.to === i : "main" !== s || !n || (t = e.pendingTimelineChange({ type: "audio" })) && t.to === i)) }, Wh = ({ segmentDuration: e, maxDuration: t }) => !!e && Math.round(e) > t + Kl, Gh = (e, t) => { var i, s, n; return "hls" === t && (t = (e => { let s = 0; return ["video", "audio"].forEach(function (t) { t = e[t + "TimingInfo"]; if (t) { var { start: t, end: i } = t; let e; "bigint" == typeof t || "bigint" == typeof i ? e = window.BigInt(i) - window.BigInt(t) : "number" == typeof t && "number" == typeof i && (e = i - t), "undefined" != typeof e && e > s && (s = e) } }), s = "bigint" == typeof s && s < Number.MAX_SAFE_INTEGER ? Number(s) : s })({ audioTimingInfo: e.audioTimingInfo, videoTimingInfo: e.videoTimingInfo })) && (i = e.playlist.targetDuration, s = Wh({ segmentDuration: t, maxDuration: 2 * i }), n = Wh({ segmentDuration: t, maxDuration: i }), t = `Segment with index ${e.mediaIndex} ` + `from playlist ${e.playlist.id} ` + `has a duration of ${t} ` + `when the reported duration is ${e.duration} ` + `and the target duration is ${i}. ` + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1", s || n) ? { severity: s ? "warn" : "info", message: t } : null }; class Xh extends T.EventTarget { constructor(e, t = 0) { if (super(), !e) throw new TypeError("Initialization settings are required"); if ("function" != typeof e.currentTime) throw new TypeError("No currentTime getter specified"); if (!e.mediaSource) throw new TypeError("No MediaSource specified"); this.bandwidth = e.bandwidth, this.throughput = { rate: 0, count: 0 }, this.roundTrip = NaN, this.resetStats_(), this.mediaIndex = null, this.partIndex = null, this.hasPlayed_ = e.hasPlayed, this.currentTime_ = e.currentTime, this.seekable_ = e.seekable, this.seeking_ = e.seeking, this.duration_ = e.duration, this.mediaSource_ = e.mediaSource, this.vhs_ = e.vhs, this.loaderType_ = e.loaderType, this.currentMediaInfo_ = void 0, this.startingMediaInfo_ = void 0, this.segmentMetadataTrack_ = e.segmentMetadataTrack, this.goalBufferLength_ = e.goalBufferLength, this.sourceType_ = e.sourceType, this.sourceUpdater_ = e.sourceUpdater, this.inbandTextTracks_ = e.inbandTextTracks, this.state_ = "INIT", this.timelineChangeController_ = e.timelineChangeController, this.shouldSaveSegmentTimingInfo_ = !0, this.parse708captions_ = e.parse708captions, this.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset, this.captionServices_ = e.captionServices, this.exactManifestTimings = e.exactManifestTimings, this.addMetadataToTextTrack = e.addMetadataToTextTrack, this.checkBufferTimeout_ = null, this.error_ = void 0, this.currentTimeline_ = -1, this.pendingSegment_ = null, this.xhrOptions_ = null, this.pendingSegments_ = [], this.audioDisabled_ = !1, this.isPendingTimestampOffset_ = !1, this.gopBuffer_ = [], this.timeMapping_ = 0, this.safeAppend_ = !1, this.appendInitSegment_ = { audio: !0, video: !0 }, this.playlistOfLastInitSegment_ = { audio: null, video: null }, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_ = { id3: [], caption: [] }, this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = null, this.activeInitSegmentId_ = null, this.initSegments_ = {}, this.cacheEncryptionKeys_ = e.cacheEncryptionKeys, this.keyCache_ = {}, this.decrypter_ = e.decrypter, this.syncController_ = e.syncController, this.syncPoint_ = { segmentIndex: 0, time: 0 }, this.transmuxer_ = this.createTransmuxer_(), this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"), this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_), this.mediaSource_.addEventListener("sourceopen", () => { this.isEndOfStream_() || (this.ended_ = !1) }), this.fetchAtBuffer_ = !1, this.logger_ = Hl(`SegmentLoader[${this.loaderType_}]`), Object.defineProperty(this, "state", { get() { return this.state_ }, set(e) { e !== this.state_ && (this.logger_(this.state_ + " -> " + e), this.state_ = e, this.trigger("statechange")) } }), this.sourceUpdater_.on("ready", () => { this.hasEnoughInfoToAppend_() && this.processCallQueue_() }), "main" === this.loaderType_ && this.timelineChangeController_.on("pendingtimelinechange", () => { this.hasEnoughInfoToAppend_() && this.processCallQueue_() }), "audio" === this.loaderType_ && this.timelineChangeController_.on("timelinechange", () => { this.hasEnoughInfoToLoad_() && this.processLoadQueue_(), this.hasEnoughInfoToAppend_() && this.processCallQueue_() }) } createTransmuxer_() { return mh({ remux: !1, alignGopsAtEnd: this.safeAppend_, keepOriginalTimestamps: !0, parse708captions: this.parse708captions_, captionServices: this.captionServices_ }) } resetStats_() { this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0 } dispose() { this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off() } setAudio(e) { this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_()) } abort() { "WAITING" !== this.state ? this.pendingSegment_ && (this.pendingSegment_ = null) : (this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_()) } abort_() { this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, window.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null } checkForAbort_(e) { return "APPENDING" !== this.state || this.pendingSegment_ ? !this.pendingSegment_ || this.pendingSegment_.requestId !== e : (this.state = "READY", !0) } error(e) { return "undefined" != typeof e && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_ } endOfStream() { this.ended_ = !0, this.transmuxer_ && ph(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended") } buffered_() { var e = this.getMediaInfo_(); if (!this.sourceUpdater_ || !e) return Vl(); if ("main" === this.loaderType_) { var { hasAudio: e, hasVideo: t, isMuxed: i } = e; if (t && e && !this.audioDisabled_ && !i) return this.sourceUpdater_.buffered(); if (t) return this.sourceUpdater_.videoBuffered() } return this.sourceUpdater_.audioBuffered() } initSegmentForMap(e, t = !1) { if (!e) return null; var i = Rd(e); let s = this.initSegments_[i]; return t && !s && e.bytes && (this.initSegments_[i] = s = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: e.bytes, tracks: e.tracks, timescales: e.timescales }), s || e } segmentKey(e, t = !1) { if (!e) return null; var i = Ud(e); let s = this.keyCache_[i]; this.cacheEncryptionKeys_ && t && !s && e.bytes && (this.keyCache_[i] = s = { resolvedUri: e.resolvedUri, bytes: e.bytes }); t = { resolvedUri: (s || e).resolvedUri }; return s && (t.bytes = s.bytes), t } couldBeginLoading_() { return this.playlist_ && !this.paused() } load() { if (this.monitorBuffer_(), this.playlist_) return "INIT" === this.state && this.couldBeginLoading_() ? this.init_() : void (!this.couldBeginLoading_() || "READY" !== this.state && "INIT" !== this.state || (this.state = "READY")) } init_() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } playlist(t, i = {}) { if (t) { var s, n = this.playlist_, r = this.pendingSegment_; this.playlist_ = t, this.xhrOptions_ = i, "INIT" === this.state && (t.syncInfo = { mediaSequence: t.mediaSequence, time: 0 }, "main" === this.loaderType_) && this.syncController_.setDateTimeMappingForStart(t); let e = null; if (n && (n.id ? e = n.id : n.uri && (e = n.uri)), this.logger_(`playlist update [${e} => ${t.id || t.uri}]`), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_(); n && n.uri === t.uri ? (i = t.mediaSequence - n.mediaSequence, this.logger_(`live window shift [${i}]`), null !== this.mediaIndex && (this.mediaIndex -= i, this.mediaIndex < 0 ? (this.mediaIndex = null, this.partIndex = null) : (s = this.playlist_.segments[this.mediaIndex], !this.partIndex || s.parts && s.parts.length && s.parts[this.partIndex] || (s = this.mediaIndex, this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`), this.resetLoader(), this.mediaIndex = s))), r && (r.mediaIndex -= i, r.mediaIndex < 0 ? (r.mediaIndex = null, r.partIndex = null) : (0 <= r.mediaIndex && (r.segment = t.segments[r.mediaIndex]), 0 <= r.partIndex && r.segment.parts && (r.part = r.segment.parts[r.partIndex]))), this.syncController_.saveExpiredSegmentInfo(n, t)) : (null !== this.mediaIndex && (t.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, this.trigger("playlistupdate")) } } pause() { this.checkBufferTimeout_ && (window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null) } paused() { return null === this.checkBufferTimeout_ } resetEverything(e) { this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = { audio: !0, video: !0 }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && (this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }), this.transmuxer_.postMessage({ action: "reset" })) } resetLoader() { this.fetchAtBuffer_ = !1, this.resyncLoader() } resyncLoader() { this.transmuxer_ && ph(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearParsedMp4Captions" }) } remove(t, i, s = () => { }, n = !1) { if ((i = i === 1 / 0 ? this.duration_() : i) <= t) this.logger_("skipping remove because end ${end} is <= start ${start}"); else if (this.sourceUpdater_ && this.getMediaInfo_()) { let e = 1; var r = () => { 0 === --e && s() }; !n && this.audioDisabled_ || (e++, this.sourceUpdater_.removeAudio(t, i, r)), !n && "main" !== this.loaderType_ || (this.gopBuffer_ = ((t, i, e, s) => { var n = Math.ceil((i - s) * Bl), r = Math.ceil((e - s) * Bl), i = t.slice(); let a = t.length; for (; a-- && !(t[a].pts <= r);); if (-1 !== a) { let e = a + 1; for (; e-- && !(t[e].pts <= n);); e = Math.max(e, 0), i.splice(e, a - e + 1) } return i })(this.gopBuffer_, t, i, this.timeMapping_), e++, this.sourceUpdater_.removeVideo(t, i, r)); for (const a in this.inbandTextTracks_) jh(t, i, this.inbandTextTracks_[a]); jh(t, i, this.segmentMetadataTrack_), r() } else this.logger_("skipping remove because no source updater or starting media info") } monitorBuffer_() { this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1) } monitorBufferTick_() { "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 500) } fillBuffer_() { var e; this.sourceUpdater_.updating() || (e = this.chooseNextRequest_()) && ("number" == typeof e.timestampOffset && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline })), this.loadSegment_(e)) } isEndOfStream_(e = this.mediaIndex, t = this.playlist_, i = this.partIndex) { var s; return !(!t || !this.mediaSource_) && (s = "number" == typeof e && t.segments[e], e = e + 1 === t.segments.length, i = !s || !s.parts || i + 1 === s.parts.length, t.endList) && "open" === this.mediaSource_.readyState && e && i } chooseNextRequest_() { var e = this.buffered_(), t = $l(e) || 0, e = Wl(e, this.currentTime_()), i = !this.hasPlayed_() && 1 <= e, s = e >= this.goalBufferLength_(), n = this.playlist_.segments; if (!n.length || i || s) return null; this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_()); var r, i = { partIndex: null, mediaIndex: null, startOfSegment: null, playlist: this.playlist_, isSyncRequest: Boolean(!this.syncPoint_) }, t = (i.isSyncRequest ? i.mediaIndex = function (t, i, s) { i = i || []; var n = []; let r = 0; for (let e = 0; e < i.length; e++) { var a = i[e]; if (t === a.timeline && (n.push(e), (r += a.duration) > s)) return e } return 0 === n.length ? 0 : n[n.length - 1] }(this.currentTimeline_, n, t) : null !== this.mediaIndex ? (s = n[this.mediaIndex], r = "number" == typeof this.partIndex ? this.partIndex : -1, i.startOfSegment = s.end || t, s.parts && s.parts[r + 1] ? (i.mediaIndex = this.mediaIndex, i.partIndex = r + 1) : i.mediaIndex = this.mediaIndex + 1) : ({ segmentIndex: s, startTime: r, partIndex: o } = yd.getMediaInfoForTime({ exactManifestTimings: this.exactManifestTimings, playlist: this.playlist_, currentTime: this.fetchAtBuffer_ ? t : this.currentTime_(), startingPartIndex: this.syncPoint_.partIndex, startingSegmentIndex: this.syncPoint_.segmentIndex, startTime: this.syncPoint_.time }), i.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + t : "currentTime " + this.currentTime_(), i.mediaIndex = s, i.startOfSegment = r, i.partIndex = o), n[i.mediaIndex]); let a = t && "number" == typeof i.partIndex && t.parts && t.parts[i.partIndex]; if (!t || "number" == typeof i.partIndex && !a) return null; "number" != typeof i.partIndex && t.parts && (i.partIndex = 0, a = t.parts[0]), e || !a || a.independent || (0 === i.partIndex ? (r = (s = n[i.mediaIndex - 1]).parts && s.parts.length && s.parts[s.parts.length - 1]) && r.independent && (--i.mediaIndex, i.partIndex = s.parts.length - 1, i.independent = "previous segment") : t.parts[i.partIndex - 1].independent && (--i.partIndex, i.independent = "previous part")); var o = this.mediaSource_ && "ended" === this.mediaSource_.readyState; return i.mediaIndex >= n.length - 1 && o && !this.seeking_() ? null : this.generateSegmentInfo_(i) } generateSegmentInfo_(e) { var { independent: e, playlist: t, mediaIndex: i, startOfSegment: s, isSyncRequest: n, partIndex: r, forceTimestampOffset: a, getMediaInfoForTime: o } = e, l = t.segments[i], d = "number" == typeof r && l.parts[r], i = { requestId: "segment-loader-" + Math.random(), uri: d && d.resolvedUri || l.resolvedUri, mediaIndex: i, partIndex: d ? r : null, isSyncRequest: n, startOfSegment: s, playlist: t, bytes: null, encryptedBytes: null, timestampOffset: null, timeline: l.timeline, duration: d && d.duration || l.duration, segment: l, part: d, byteLength: 0, transmuxer: this.transmuxer_, getMediaInfoForTime: o, independent: e }, r = "undefined" != typeof a ? a : this.isPendingTimestampOffset_, n = (i.timestampOffset = this.timestampOffsetForSegment_({ segmentTimeline: l.timeline, currentTimeline: this.currentTimeline_, startOfSegment: s, buffered: this.buffered_(), overrideCheck: r }), $l(this.sourceUpdater_.audioBuffered())); return "number" == typeof n && (i.audioAppendStart = n - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (i.gopsToAlignWith = ((e, t, i) => { if ("undefined" == typeof t || null === t || !e.length) return []; var s = Math.ceil((t - i + 3) * Bl); let n; for (n = 0; n < e.length && !(e[n].pts > s); n++); return e.slice(n) })(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)), i } timestampOffsetForSegment_(e) { return { segmentTimeline: e, currentTimeline: t, startOfSegment: i, buffered: s, overrideCheck: n } = [e][0], n || e !== t ? !(e < t) && s.length ? s.end(s.length - 1) : i : null; var t, i, s, n } earlyAbortWhenNeeded_(t) { if (!this.vhs_.tech_.paused() && this.xhrOptions_.timeout && this.playlist_.attributes.BANDWIDTH && !(Date.now() - (t.firstBytesReceivedAt || Date.now()) < 1e3)) { var e = this.currentTime_(), i = t.bandwidth, s = this.pendingSegment_.duration, t = yd.estimateSegmentRequestTime(s, i, this.playlist_, t.bytesReceived), n = ([n, r, a = 1] = [this.buffered_(), e, this.vhs_.tech_.playbackRate()], ((n.length ? n.end(n.length - 1) : 0) - r) / a - 1); if (!(t <= n)) { var r = function (e) { const { main: t, currentTime: i, bandwidth: s, duration: n, segmentDuration: r, timeUntilRebuffer: a, currentTimeline: o, syncController: l } = e; e = t.playlists.filter(e => !yd.isIncompatible(e)); let d = e.filter(yd.isEnabled); var e = (d = d.length ? d : e.filter(e => !yd.isDisabled(e))).filter(yd.hasAttribute.bind(null, "BANDWIDTH")).map(e => { var t = l.getSyncPoint(e, n, o, i) ? 1 : 2; return { playlist: e, rebufferingImpact: yd.estimateSegmentRequestTime(r, s, e) * t - a } }), h = e.filter(e => e.rebufferingImpact <= 0); return Uh(h, (e, t) => vh(t.playlist, e.playlist)), h.length ? h[0] : (Uh(e, (e, t) => e.rebufferingImpact - t.rebufferingImpact), e[0] || null) }({ main: this.vhs_.playlists.main, currentTime: e, bandwidth: i, duration: this.duration_(), segmentDuration: s, timeUntilRebuffer: n, currentTimeline: this.currentTimeline_, syncController: this.syncController_ }); if (r) { var a = t - n - r.rebufferingImpact; let e = .5; n <= Kl && (e = 1), !r.playlist || r.playlist.uri === this.playlist_.uri || a < e || (this.bandwidth = r.playlist.attributes.BANDWIDTH * O.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort")) } } } } handleAbort_(e) { this.logger_("Aborting " + qh(e)), this.mediaRequestsAborted += 1 } handleProgress_(e, t) { this.earlyAbortWhenNeeded_(t.stats), this.checkForAbort_(t.requestId) || this.trigger("progress") } handleTrackInfo_(e, t) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || this.checkForIllegalMediaSwitch(t) || (function (t, i) { if (!t && !i || !t && i || t && !i) return !1; if (t !== i) { var s = Object.keys(t).sort(), n = Object.keys(i).sort(); if (s.length !== n.length) return !1; for (let e = 0; e < s.length; e++) { var r = s[e]; if (r !== n[e]) return !1; if (t[r] !== i[r]) return !1 } } return !0 }(this.currentMediaInfo_, t = t || {}) || (this.appendInitSegment_ = { audio: !0, video: !0 }, this.startingMediaInfo_ = t, this.currentMediaInfo_ = t, this.logger_("trackinfo update", t), this.trigger("trackinfo")), this.checkForAbort_(e.requestId)) || (this.pendingSegment_.trackInfo = t, this.hasEnoughInfoToAppend_() && this.processCallQueue_()) } handleTimingInfo_(e, t, i, s) { var n; this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || ((e = this.pendingSegment_)[n = zh(t)] = e[n] || {}, e[n][i] = s, this.logger_(`timinginfo: ${t} - ${i} - ` + s), this.hasEnoughInfoToAppend_() && this.processCallQueue_()) } handleCaptions_(e, t) { if (this.earlyAbortWhenNeeded_(e.stats), !this.checkForAbort_(e.requestId)) if (0 === t.length) this.logger_("SegmentLoader received no captions from a caption event"); else if (this.pendingSegment_.hasAppendedData_) { const c = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), p = {}; t.forEach(e => { p[e.stream] = p[e.stream] || { startTime: 1 / 0, captions: [], endTime: 0 }; var t = p[e.stream]; t.startTime = Math.min(t.startTime, e.startTime + c), t.endTime = Math.max(t.endTime, e.endTime + c), t.captions.push(e) }), Object.keys(p).forEach(e => { var { startTime: t, endTime: i, captions: s } = p[e], n = this.inbandTextTracks_, r = (this.logger_(`adding cues from ${t} -> ${i} for ` + e), n), a = this.vhs_.tech_, o = e; if (!r[o]) { a.trigger({ type: "usage", name: "vhs-608" }); let s = o; /^cc708_/.test(o) && (s = "SERVICE" + o.split("_")[1]); var l = a.textTracks().getTrackById(s); if (l) r[o] = l; else { let e = o, t = o, i = !1; l = (a.options_.vhs && a.options_.vhs.captionServices || {})[s]; l && (e = l.label, t = l.language, i = l.default), r[o] = a.addRemoteTextTrack({ kind: "captions", id: s, default: i, label: e, language: t }, !1).track } } jh(t, i, n[e]); var { inbandTextTracks: d, captionArray: l, timestampOffset: h } = { captionArray: s, inbandTextTracks: n, timestampOffset: c }; if (l) { const u = window.WebKitDataCue || window.VTTCue; l.forEach(e => { var t = e.stream; d[t].addCue(new u(e.startTime + h, e.endTime + h, e.text)) }) } }), this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearParsedMp4Captions" }) } else this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, e, t)) } handleId3_(e, t, i) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || (this.pendingSegment_.hasAppendedData_ ? this.addMetadataToTextTrack(i, t, this.duration_()) : this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, t, i))) } processMetadataQueue_() { this.metadataQueue_.id3.forEach(e => e()), this.metadataQueue_.caption.forEach(e => e()), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [] } processCallQueue_() { var e = this.callQueue_; this.callQueue_ = [], e.forEach(e => e()) } processLoadQueue_() { var e = this.loadQueue_; this.loadQueue_ = [], e.forEach(e => e()) } hasEnoughInfoToLoad_() { var e; return "audio" !== this.loaderType_ || !(!(e = this.pendingSegment_) || this.getCurrentMediaInfo_() && $h({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) } getCurrentMediaInfo_(e = this.pendingSegment_) { return e && e.trackInfo || this.currentMediaInfo_ } getMediaInfo_(e = this.pendingSegment_) { return this.getCurrentMediaInfo_(e) || this.startingMediaInfo_ } getPendingSegmentPlaylist() { return this.pendingSegment_ ? this.pendingSegment_.playlist : null } hasEnoughInfoToAppend_() { var e, t, i, s; return !!this.sourceUpdater_.ready() && !(this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_ || (e = this.pendingSegment_, t = this.getCurrentMediaInfo_(), !e) || !t || ({ hasAudio: t, hasVideo: i, isMuxed: s } = t, i && !e.videoTimingInfo) || t && !this.audioDisabled_ && !s && !e.audioTimingInfo || $h({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) } handleData_(t, e) { if (this.earlyAbortWhenNeeded_(t.stats), !this.checkForAbort_(t.requestId)) if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) this.callQueue_.push(this.handleData_.bind(this, t, e)); else { var i = this.pendingSegment_; if (this.setTimeMapping_(i.timeline), this.updateMediaSecondsLoaded_(i.part || i.segment), "closed" !== this.mediaSource_.readyState) { if (t.map && (t.map = this.initSegmentForMap(t.map, !0), i.segment.map = t.map), t.key && this.segmentKey(t.key, !0), i.isFmp4 = t.isFmp4, i.timingInfo = i.timingInfo || {}, i.isFmp4) this.trigger("fmp4"), i.timingInfo.start = i[zh(e.type)].start; else { t = this.getCurrentMediaInfo_(), t = "main" === this.loaderType_ && t && t.hasVideo; let e; t && (e = i.videoTimingInfo.start), i.timingInfo.start = this.trueSegmentStart_({ currentStart: i.timingInfo.start, playlist: i.playlist, mediaIndex: i.mediaIndex, currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(), useVideoTimingInfo: t, firstVideoFrameTimeForData: e, videoTimingInfo: i.videoTimingInfo, audioTimingInfo: i.audioTimingInfo }) } if (this.updateAppendInitSegmentStatus(i, e.type), this.updateSourceBufferTimestampOffset_(i), i.isSyncRequest) { this.updateTimingInfoEnd_(i), this.syncController_.saveSegmentTimingInfo({ segmentInfo: i, shouldSaveTimelineMapping: "main" === this.loaderType_ }); t = this.chooseNextRequest_(); if (t.mediaIndex !== i.mediaIndex || t.partIndex !== i.partIndex) return void this.logger_("sync segment was incorrect, not appending"); this.logger_("sync segment was correct, appending") } i.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(i, e) } } } updateAppendInitSegmentStatus(e, t) { "main" !== this.loaderType_ || "number" != typeof e.timestampOffset || e.changedTimestampOffset || (this.appendInitSegment_ = { audio: !0, video: !0 }), this.playlistOfLastInitSegment_[t] !== e.playlist && (this.appendInitSegment_[t] = !0) } getInitSegmentAndUpdateState_({ type: e, initSegment: t, map: i, playlist: s }) { if (i) { var n = Rd(i); if (this.activeInitSegmentId_ === n) return null; t = this.initSegmentForMap(i, !0).bytes, this.activeInitSegmentId_ = n } return t && this.appendInitSegment_[e] ? (this.playlistOfLastInitSegment_[e] = s, this.appendInitSegment_[e] = !1, this.activeInitSegmentId_ = null, t) : null } handleQuotaExceededError_({ segmentInfo: e, type: t, bytes: i }, s) { var n = this.sourceUpdater_.audioBuffered(), r = this.sourceUpdater_.videoBuffered(), a = (1 < n.length && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + Zl(n).join(", ")), 1 < r.length && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + Zl(r).join(", ")), n.length ? n.start(0) : 0), o = n.length ? n.end(n.length - 1) : 0, l = r.length ? r.start(0) : 0, d = r.length ? r.end(r.length - 1) : 0; o - a <= 1 && d - l <= 1 ? (this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + `Appended byte length: ${i.byteLength}, ` + `audio buffer: ${Zl(n).join(", ")}, ` + `video buffer: ${Zl(r).join(", ")}, `), this.error({ message: "Quota exceeded error with append of a single segment of content", excludeUntil: 1 / 0 }), this.trigger("error")) : (this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, { segmentInfo: e, type: t, bytes: i })), o = this.currentTime_() - 1, this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + o), this.remove(0, o, () => { this.logger_("On QUOTA_EXCEEDED_ERR, retrying append in 1s"), this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = window.setTimeout(() => { this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), this.quotaExceededErrorRetryTimeout_ = null, this.processCallQueue_() }, 1e3) }, !0)) } handleAppendError_({ segmentInfo: e, type: t, bytes: i }, s) { s && (22 === s.code ? this.handleQuotaExceededError_({ segmentInfo: e, type: t, bytes: i }) : (this.logger_("Received non QUOTA_EXCEEDED_ERR on append", s), this.error(`${t} append of ${i.length}b failed for segment ` + `#${e.mediaIndex} in playlist ` + e.playlist.id), this.trigger("appenderror"))) } appendToSourceBuffer_({ segmentInfo: e, type: t, initSegment: i, data: s, bytes: n }) { if (!n) { var r = [s]; let e = s.byteLength; i && (r.unshift(i), e += i.byteLength), n = (e => { let t = 0, i; return e.bytes && (i = new Uint8Array(e.bytes), e.segments.forEach(e => { i.set(e, t), t += e.byteLength })), i })({ bytes: e, segments: r }) } this.sourceUpdater_.appendBuffer({ segmentInfo: e, type: t, bytes: n }, this.handleAppendError_.bind(this, { segmentInfo: e, type: t, bytes: n })) } handleSegmentTimingInfo_(e, t, i) { this.pendingSegment_ && t === this.pendingSegment_.requestId && ((t = this.pendingSegment_.segment)[e = e + "TimingInfo"] || (t[e] = {}), t[e].transmuxerPrependedSeconds = i.prependedContentDuration || 0, t[e].transmuxedPresentationStart = i.start.presentation, t[e].transmuxedDecodeStart = i.start.decode, t[e].transmuxedPresentationEnd = i.end.presentation, t[e].transmuxedDecodeEnd = i.end.decode, t[e].baseMediaDecodeTime = i.baseMediaDecodeTime) } appendData_(e, t) { var { type: i, data: s } = t; s && s.byteLength && ("audio" === i && this.audioDisabled_ || (t = this.getInitSegmentAndUpdateState_({ type: i, initSegment: t.initSegment, playlist: e.playlist, map: e.isFmp4 ? e.segment.map : null }), this.appendToSourceBuffer_({ segmentInfo: e, type: i, initSegment: t, data: s }))) } loadSegment_(t) { this.state = "WAITING", this.pendingSegment_ = t, this.trimBackBuffer_(t), "number" == typeof t.timestampOffset && this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }), this.hasEnoughInfoToLoad_() ? this.updateTransmuxerAndRequestSegment_(t) : this.loadQueue_.push(() => { var e = yi({}, t, { forceTimestampOffset: !0 }); yi(t, this.generateSegmentInfo_(e)), this.isPendingTimestampOffset_ = !1, this.updateTransmuxerAndRequestSegment_(t) }) } updateTransmuxerAndRequestSegment_(s) { this.shouldUpdateTransmuxerTimestampOffset_(s.timestampOffset) && (this.gopBuffer_.length = 0, s.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({ action: "reset" }), this.transmuxer_.postMessage({ action: "setTimestampOffset", timestampOffset: s.timestampOffset })); var e = this.createSimplifiedSegmentObj_(s), t = this.isEndOfStream_(s.mediaIndex, s.playlist, s.partIndex), i = null !== this.mediaIndex, n = s.timeline !== this.currentTimeline_ && 0 < s.timeline, t = t || i && n; this.logger_("Requesting " + qh(s)), e.map && !e.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = { video: !0, audio: !0 }), s.abortRequests = Ph({ xhr: this.vhs_.xhr, xhrOptions: this.xhrOptions_, decryptionWorker: this.decrypter_, segment: e, abortFn: this.handleAbort_.bind(this, s), progressFn: this.handleProgress_.bind(this), trackInfoFn: this.handleTrackInfo_.bind(this), timingInfoFn: this.handleTimingInfo_.bind(this), videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", s.requestId), audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", s.requestId), captionsFn: this.handleCaptions_.bind(this), isEndOfTimeline: t, endedTimelineFn: () => { this.logger_("received endedtimeline callback") }, id3Fn: this.handleId3_.bind(this), dataFn: this.handleData_.bind(this), doneFn: this.segmentRequestFinished_.bind(this), onTransmuxerLog: ({ message: e, level: t, stream: i }) => { this.logger_(qh(s) + ` logged from transmuxer stream ${i} as a ${t}: ` + e) } }) } trimBackBuffer_(e) { var t = ((e, t, i) => { let s = t - O.BACK_BUFFER_LENGTH; return e.length && (s = Math.max(s, e.start(0))), Math.min(t - i, s) })(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); 0 < t && this.remove(0, t) } createSimplifiedSegmentObj_(e) { var t = e.segment, i = e.part, i = { resolvedUri: (i || t).resolvedUri, byterange: (i || t).byterange, requestId: e.requestId, transmuxer: e.transmuxer, audioAppendStart: e.audioAppendStart, gopsToAlignWith: e.gopsToAlignWith, part: e.part }, s = e.playlist.segments[e.mediaIndex - 1]; return s && s.timeline === t.timeline && (s.videoTimingInfo ? i.baseStartTime = s.videoTimingInfo.transmuxedDecodeEnd : s.audioTimingInfo && (i.baseStartTime = s.audioTimingInfo.transmuxedDecodeEnd)), t.key && (s = t.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]), i.key = this.segmentKey(t.key), i.key.iv = s), t.map && (i.map = this.initSegmentForMap(t.map)), i } saveTransferStats_(e) { this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime) } saveBandwidthRelatedStats_(e, t) { this.pendingSegment_.byteLength = t.bytesReceived, e < 1 / 60 ? this.logger_("Ignoring segment's bandwidth because its duration of " + e + " is less than the min to record " + 1 / 60) : (this.bandwidth = t.bandwidth, this.roundTrip = t.roundTripTime) } handleTimeout_() { this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout") } segmentRequestFinished_(e, t, i) { if (this.callQueue_.length) this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, t, i)); else if (this.saveTransferStats_(t.stats), this.pendingSegment_ && t.requestId === this.pendingSegment_.requestId) { if (e) return this.pendingSegment_ = null, this.state = "READY", e.code === bh.ABORTED ? void 0 : (this.pause(), e.code === bh.TIMEOUT ? void this.handleTimeout_() : (this.mediaRequestsErrored += 1, this.error(e), void this.trigger("error"))); e = this.pendingSegment_; this.saveBandwidthRelatedStats_(e.duration, t.stats), e.endOfAllRequests = t.endOfAllRequests, i.gopInfo && (this.gopBuffer_ = ((e, t, i) => { if (!t.length) return e; if (i) return t.slice(); var s = t[0].pts; let n = 0; for (n; n < e.length && !(e[n].pts >= s); n++); return e.slice(0, n).concat(t) })(this.gopBuffer_, i.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(e) } } setTimeMapping_(e) { e = this.syncController_.mappingForTimeline(e); null !== e && (this.timeMapping_ = e) } updateMediaSecondsLoaded_(e) { "number" == typeof e.start && "number" == typeof e.end ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration } shouldUpdateTransmuxerTimestampOffset_(e) { return null !== e && ("main" === this.loaderType_ && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset()) } trueSegmentStart_({ currentStart: e, playlist: t, mediaIndex: i, firstVideoFrameTimeForData: s, currentVideoTimestampOffset: n, useVideoTimingInfo: r, videoTimingInfo: a, audioTimingInfo: o }) { return "undefined" != typeof e ? e : r ? (e = t.segments[i - 1], 0 !== i && e && "undefined" != typeof e.start && e.end === s + n ? a.start : s) : o.start } waitForAppendsToComplete_(e) { var t, i, s = this.getCurrentMediaInfo_(e); s ? ({ hasAudio: s, hasVideo: i, isMuxed: t } = s, i = "main" === this.loaderType_ && i, s = !this.audioDisabled_ && s && !t, e.waitingOnAppends = 0, e.hasAppendedData_ ? (i && e.waitingOnAppends++, s && e.waitingOnAppends++, i && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), s && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e))) : (e.timingInfo || "number" != typeof e.timestampOffset || (this.isPendingTimestampOffset_ = !0), e.timingInfo = { start: 0 }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), this.checkAppendsDone_(e))) : (this.error({ message: "No starting media returned, likely due to an unsupported media format.", playlistExclusionDuration: 1 / 0 }), this.trigger("error")) } checkAppendsDone_(e) { this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, 0 === e.waitingOnAppends && this.handleAppendsDone_()) } checkForIllegalMediaSwitch(e) { i = this.loaderType_, t = this.getCurrentMediaInfo_(), e = e; var t, i = "main" === i && t && e ? e.hasAudio || e.hasVideo ? t.hasVideo && !e.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !t.hasVideo && e.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null; return !!i && (this.error({ message: i, playlistExclusionDuration: 1 / 0 }), this.trigger("error"), !0) } updateSourceBufferTimestampOffset_(t) { if (null !== t.timestampOffset && "number" == typeof t.timingInfo.start && !t.changedTimestampOffset && "main" === this.loaderType_) { let e = !1; t.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: t.segment.videoTimingInfo, audioTimingInfo: t.segment.audioTimingInfo, timingInfo: t.timingInfo }), t.changedTimestampOffset = !0, t.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(t.timestampOffset), e = !0), t.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(t.timestampOffset), e = !0), e && this.trigger("timestampoffset") } } getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: e, audioTimingInfo: t, timingInfo: i }) { return this.useDtsForTimestampOffset_ ? e && "number" == typeof e.transmuxedDecodeStart ? e.transmuxedDecodeStart : t && "number" == typeof t.transmuxedDecodeStart ? t.transmuxedDecodeStart : i.start : i.start } updateTimingInfoEnd_(e) { e.timingInfo = e.timingInfo || {}; var t = this.getMediaInfo_(), t = "main" === this.loaderType_ && t && t.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo; t && (e.timingInfo.end = "number" == typeof t.end ? t.end : t.start + e.duration) } handleAppendsDone_() { var e, t, i; this.pendingSegment_ && this.trigger("appendsdone"), this.pendingSegment_ ? (e = this.pendingSegment_, this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({ segmentInfo: e, shouldSaveTimelineMapping: "main" === this.loaderType_ }), (t = Gh(e, this.sourceType_)) && ("warn" === t.severity ? T.log.warn(t.message) : this.logger_(t.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", e.isSyncRequest && (this.trigger("syncinfoupdate"), !e.hasAppendedData_) ? this.logger_("Throwing away un-appended sync request " + qh(e)) : (this.logger_("Appended " + qh(e)), this.addSegmentMetadataCue_(e), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline }), "main" !== this.loaderType_ || this.audioDisabled_ || this.timelineChangeController_.lastTimelineChange({ type: "audio", from: this.currentTimeline_, to: e.timeline })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate"), t = e.segment, i = e.part, t = t.end && this.currentTime_() - t.end > 3 * e.playlist.targetDuration, i = i && i.end && this.currentTime_() - i.end > 3 * e.playlist.partTargetDuration, t || i ? (this.logger_(`bad ${t ? "segment" : "part"} ` + qh(e)), this.resetEverything()) : (null !== this.mediaIndex && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_()))) : (this.state = "READY", this.paused() || this.monitorBuffer_()) } recordThroughput_(e) { var t, i; e.duration < 1 / 60 ? this.logger_("Ignoring segment's throughput because its duration of " + e.duration + " is less than the min to record " + 1 / 60) : (t = this.throughput.rate, i = Date.now() - e.endOfAllRequests + 1, e = Math.floor(e.byteLength / i * 8 * 1e3), this.throughput.rate += (e - t) / ++this.throughput.count) } addSegmentMetadataCue_(e) { var t, i, s, n; this.segmentMetadataTrack_ && (t = (n = e.segment).start, i = n.end, Vh(t)) && Vh(i) && (jh(t, i, this.segmentMetadataTrack_), s = window.WebKitDataCue || window.VTTCue, n = { custom: n.custom, dateTimeObject: n.dateTimeObject, dateTimeString: n.dateTimeString, bandwidth: e.playlist.attributes.BANDWIDTH, resolution: e.playlist.attributes.RESOLUTION, codecs: e.playlist.attributes.CODECS, byteLength: e.byteLength, uri: e.uri, timeline: e.timeline, playlist: e.playlist.id, start: t, end: i }, (e = new s(t, i, JSON.stringify(n))).value = n, this.segmentMetadataTrack_.addCue(e)) } } function Kh() { } function Yh(e) { return "string" != typeof e ? e : e.replace(/./, e => e.toUpperCase()) } const Qh = ["video", "audio"], Jh = (e, t) => { var i = t[e + "Buffer"]; return i && i.updating || t.queuePending[e] }, Zh = (i, s) => { if (0 !== s.queue.length) { let e = 0, t = s.queue[e]; if ("mediaSource" === t.type) s.updating() || "closed" === s.mediaSource.readyState || (s.queue.shift(), t.action(s), t.doneFn && t.doneFn(), Zh("audio", s), Zh("video", s)); else if ("mediaSource" !== i && s.ready() && "closed" !== s.mediaSource.readyState && !Jh(i, s)) { if (t.type !== i) { if (null === (e = ((t, i) => { for (let e = 0; e < i.length; e++) { var s = i[e]; if ("mediaSource" === s.type) return null; if (s.type === t) return e } return null })(i, s.queue))) return; t = s.queue[e] } s.queue.splice(e, 1), (s.queuePending[i] = t).action(i, s), t.doneFn || (s.queuePending[i] = null, Zh(i, s)) } } }, eu = (e, t) => { var i = t[e + "Buffer"], s = Yh(e); i && (i.removeEventListener("updateend", t[`on${s}UpdateEnd_`]), i.removeEventListener("error", t[`on${s}Error_`]), t.codecs[e] = null, t[e + "Buffer"] = null) }, tu = (e, t) => e && t && -1 !== Array.prototype.indexOf.call(e.sourceBuffers, t), iu = { appendBuffer: (s, n, r) => (t, i) => { var e = i[t + "Buffer"]; if (tu(i.mediaSource, e)) { i.logger_(`Appending segment ${n.mediaIndex}'s ${s.length} bytes to ${t}Buffer`); try { e.appendBuffer(s) } catch (e) { i.logger_(`Error with code ${e.code} ` + (22 === e.code ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${n.mediaIndex} to ${t}Buffer`), i.queuePending[t] = null, r(e) } } }, remove: (s, n) => (t, i) => { var e = i[t + "Buffer"]; if (tu(i.mediaSource, e)) { i.logger_(`Removing ${s} to ${n} from ${t}Buffer`); try { e.remove(s, n) } catch (e) { i.logger_(`Remove ${s} to ${n} from ${t}Buffer failed`) } } }, timestampOffset: s => (e, t) => { var i = t[e + "Buffer"]; tu(t.mediaSource, i) && (t.logger_(`Setting ${e}timestampOffset to ` + s), i.timestampOffset = s) }, callback: i => (e, t) => { i() }, endOfStream: t => e => { if ("open" === e.mediaSource.readyState) { e.logger_(`Calling mediaSource endOfStream(${t || ""})`); try { e.mediaSource.endOfStream(t) } catch (e) { T.log.warn("Failed to call media source endOfStream", e) } } }, duration: t => e => { e.logger_("Setting mediaSource duration to " + t); try { e.mediaSource.duration = t } catch (e) { T.log.warn("Failed to set media source duration", e) } }, abort: () => (t, e) => { if ("open" === e.mediaSource.readyState) { var i = e[t + "Buffer"]; if (tu(e.mediaSource, i)) { e.logger_(`calling abort on ${t}Buffer`); try { i.abort() } catch (e) { T.log.warn(`Failed to abort on ${t}Buffer`, e) } } } }, addSourceBuffer: (s, n) => e => { var t = Yh(s), i = jr(n), i = (e.logger_(`Adding ${s}Buffer with codec ${n} to mediaSource`), e.mediaSource.addSourceBuffer(i)); i.addEventListener("updateend", e[`on${t}UpdateEnd_`]), i.addEventListener("error", e[`on${t}Error_`]), e.codecs[s] = n, e[s + "Buffer"] = i }, removeSourceBuffer: i => e => { var t = e[i + "Buffer"]; if (eu(i, e), tu(e.mediaSource, t)) { e.logger_(`Removing ${i}Buffer with codec ${e.codecs[i]} from mediaSource`); try { e.mediaSource.removeSourceBuffer(t) } catch (e) { T.log.warn(`Failed to removeSourceBuffer ${i}Buffer`, e) } } }, changeType: n => (e, t) => { var i = t[e + "Buffer"], s = jr(n); tu(t.mediaSource, i) && t.codecs[e] !== n && (t.logger_(`changing ${e}Buffer codec from ${t.codecs[e]} to ` + n), i.changeType(s), t.codecs[e] = n) } }, su = ({ type: e, sourceUpdater: t, action: i, doneFn: s, name: n }) => { t.queue.push({ type: e, action: i, doneFn: s, name: n }), Zh(e, t) }, nu = (i, s) => e => { var t; s.queuePending[i] && (t = s.queuePending[i].doneFn, s.queuePending[i] = null, t) && t(s[i + "Error_"]), Zh(i, s) }; class ru extends T.EventTarget { constructor(e) { super(), this.mediaSource = e, this.sourceopenListener_ = () => Zh("mediaSource", this), this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_), this.logger_ = Hl("SourceUpdater"), this.audioTimestampOffset_ = 0, this.videoTimestampOffset_ = 0, this.queue = [], this.queuePending = { audio: null, video: null }, this.delayedAudioAppendQueue_ = [], this.videoAppendQueued_ = !1, this.codecs = {}, this.onVideoUpdateEnd_ = nu("video", this), this.onAudioUpdateEnd_ = nu("audio", this), this.onVideoError_ = e => { this.videoError_ = e }, this.onAudioError_ = e => { this.audioError_ = e }, this.createdSourceBuffers_ = !1, this.initializedEme_ = !1, this.triggeredReady_ = !1 } initializedEme() { this.initializedEme_ = !0, this.triggerReady() } hasCreatedSourceBuffers() { return this.createdSourceBuffers_ } hasInitializedAnyEme() { return this.initializedEme_ } ready() { return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme() } createSourceBuffers(e) { this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady()) } triggerReady() { this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready")) } addSourceBuffer(e, t) { su({ type: "mediaSource", sourceUpdater: this, action: iu.addSourceBuffer(e, t), name: "addSourceBuffer" }) } abort(e) { su({ type: e, sourceUpdater: this, action: iu.abort(e), name: "abort" }) } removeSourceBuffer(e) { this.canRemoveSourceBuffer() ? su({ type: "mediaSource", sourceUpdater: this, action: iu.removeSourceBuffer(e), name: "removeSourceBuffer" }) : T.log.error("removeSourceBuffer is not supported!") } canRemoveSourceBuffer() { return !T.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && "function" == typeof window.MediaSource.prototype.removeSourceBuffer } static canChangeType() { return window.SourceBuffer && window.SourceBuffer.prototype && "function" == typeof window.SourceBuffer.prototype.changeType } canChangeType() { return this.constructor.canChangeType() } changeType(e, t) { this.canChangeType() ? su({ type: e, sourceUpdater: this, action: iu.changeType(t), name: "changeType" }) : T.log.error("changeType is not supported!") } addOrChangeSourceBuffers(i) { if (!i || "object" != typeof i || 0 === Object.keys(i).length) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs"); Object.keys(i).forEach(e => { var t = i[e]; if (!this.hasCreatedSourceBuffers()) return this.addSourceBuffer(e, t); this.canChangeType() && this.changeType(e, t) }) } appendBuffer(e, t) { var { segmentInfo: i, type: s, bytes: n } = e; this.processedAppend_ = !0, "audio" === s && this.videoBuffer && !this.videoAppendQueued_ ? (this.delayedAudioAppendQueue_.push([e, t]), this.logger_(`delayed audio append of ${n.length} until video append`)) : (e = t, su({ type: s, sourceUpdater: this, action: iu.appendBuffer(n, i || { mediaIndex: -1 }, e), doneFn: t, name: "appendBuffer" }), "video" === s && (this.videoAppendQueued_ = !0, this.delayedAudioAppendQueue_.length) && (n = this.delayedAudioAppendQueue_.slice(), this.logger_(`queuing delayed audio ${n.length} appendBuffers`), this.delayedAudioAppendQueue_.length = 0, n.forEach(e => { this.appendBuffer.apply(this, e) }))) } audioBuffered() { return tu(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered || Vl() } videoBuffered() { return tu(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered || Vl() } buffered() { var e = tu(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, t = tu(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null; if (t && !e) return this.audioBuffered(); if (e && !t) return this.videoBuffered(); { var n = this.audioBuffered(); var r = this.videoBuffered(); let e = null, t = null, i = 0; var a = [], o = []; if (!(n && n.length && r && r.length)) return Vl(); let s = n.length; for (; s--;)a.push({ time: n.start(s), type: "start" }), a.push({ time: n.end(s), type: "end" }); for (s = r.length; s--;)a.push({ time: r.start(s), type: "start" }), a.push({ time: r.end(s), type: "end" }); for (a.sort(function (e, t) { return e.time - t.time }), s = 0; s < a.length; s++)"start" === a[s].type ? 2 === ++i && (e = a[s].time) : "end" === a[s].type && 1 === --i && (t = a[s].time), null !== e && null !== t && (o.push([e, t]), e = null, t = null); return Vl(o); return } } setDuration(e, t = Kh) { su({ type: "mediaSource", sourceUpdater: this, action: iu.duration(e), name: "duration", doneFn: t }) } endOfStream(e = null, t = Kh) { "string" != typeof e && (e = void 0), su({ type: "mediaSource", sourceUpdater: this, action: iu.endOfStream(e), name: "endOfStream", doneFn: t }) } removeAudio(e, t, i = Kh) { this.audioBuffered().length && 0 !== this.audioBuffered().end(0) ? su({ type: "audio", sourceUpdater: this, action: iu.remove(e, t), doneFn: i, name: "remove" }) : i() } removeVideo(e, t, i = Kh) { this.videoBuffered().length && 0 !== this.videoBuffered().end(0) ? su({ type: "video", sourceUpdater: this, action: iu.remove(e, t), doneFn: i, name: "remove" }) : i() } updating() { return !(!Jh("audio", this) && !Jh("video", this)) } audioTimestampOffset(e) { return "undefined" != typeof e && this.audioBuffer && this.audioTimestampOffset_ !== e && (su({ type: "audio", sourceUpdater: this, action: iu.timestampOffset(e), name: "timestampOffset" }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_ } videoTimestampOffset(e) { return "undefined" != typeof e && this.videoBuffer && this.videoTimestampOffset !== e && (su({ type: "video", sourceUpdater: this, action: iu.timestampOffset(e), name: "timestampOffset" }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_ } audioQueueCallback(e) { this.audioBuffer && su({ type: "audio", sourceUpdater: this, action: iu.callback(e), name: "callback" }) } videoQueueCallback(e) { this.videoBuffer && su({ type: "video", sourceUpdater: this, action: iu.callback(e), name: "callback" }) } dispose() { this.trigger("dispose"), Qh.forEach(e => { this.abort(e), this.canRemoveSourceBuffer() ? this.removeSourceBuffer(e) : this[e + "QueueCallback"](() => eu(e, this)) }), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off() } } const au = e => decodeURIComponent(escape(String.fromCharCode.apply(null, e))), ou = new Uint8Array("\n\n".split("").map(e => e.charCodeAt(0))); class lu extends Error { constructor() { super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.") } } class du extends Xh { constructor(e, t = {}) { super(e, t), this.mediaSource_ = null, this.subtitlesTrack_ = null, this.loaderType_ = "subtitle", this.featuresNativeTextTracks_ = e.featuresNativeTextTracks, this.loadVttJs = e.loadVttJs, this.shouldSaveSegmentTimingInfo_ = !1 } createTransmuxer_() { return null } buffered_() { var e; return this.subtitlesTrack_ && this.subtitlesTrack_.cues && this.subtitlesTrack_.cues.length ? Vl([[(e = this.subtitlesTrack_.cues)[0].startTime, e[e.length - 1].startTime]]) : Vl() } initSegmentForMap(e, t = !1) { if (!e) return null; var i = Rd(e); let s = this.initSegments_[i]; return t && !s && e.bytes && (t = ou.byteLength + e.bytes.byteLength, (t = new Uint8Array(t)).set(e.bytes), t.set(ou, e.bytes.byteLength), this.initSegments_[i] = s = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: t }), s || e } couldBeginLoading_() { return this.playlist_ && this.subtitlesTrack_ && !this.paused() } init_() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } track(e) { return "undefined" != typeof e && (this.subtitlesTrack_ = e, "INIT" === this.state && this.couldBeginLoading_()) && this.init_(), this.subtitlesTrack_ } remove(e, t) { jh(e, t, this.subtitlesTrack_) } fillBuffer_() { var e = this.chooseNextRequest_(); e && (null === this.syncController_.timestampOffsetForTimeline(e.timeline) ? (this.syncController_.one("timestampoffset", () => { this.state = "READY", this.paused() || this.monitorBuffer_() }), this.state = "WAITING_ON_TIMELINE") : this.loadSegment_(e)) } timestampOffsetForSegment_() { return null } chooseNextRequest_() { return this.skipEmptySegments_(super.chooseNextRequest_()) } skipEmptySegments_(e) { for (; e && e.segment.empty;) { if (e.mediaIndex + 1 >= e.playlist.segments.length) { e = null; break } e = this.generateSegmentInfo_({ playlist: e.playlist, mediaIndex: e.mediaIndex + 1, startOfSegment: e.startOfSegment + e.duration, isSyncRequest: e.isSyncRequest }) } return e } stopForError(e) { this.error(e), this.state = "READY", this.pause(), this.trigger("error") } segmentRequestFinished_(e, t, i) { if (this.subtitlesTrack_) if (this.saveTransferStats_(t.stats), this.pendingSegment_) if (e) e.code === bh.TIMEOUT && this.handleTimeout_(), e.code === bh.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, this.stopForError(e); else { var s = this.pendingSegment_, n = (this.saveBandwidthRelatedStats_(s.duration, t.stats), t.key && this.segmentKey(t.key, !0), this.state = "APPENDING", this.trigger("appending"), s.segment); if (n.map && (n.map.bytes = t.map.bytes), s.bytes = t.bytes, "function" != typeof window.WebVTT && "function" == typeof this.loadVttJs) this.state = "WAITING_ON_VTTJS", this.loadVttJs().then(() => this.segmentRequestFinished_(e, t, i), () => this.stopForError({ message: "Error loading vtt.js" })); else { n.requested = !0; try { this.parseVTTCues_(s) } catch (e) { return void this.stopForError({ message: e.message }) } if (this.updateTimeMapping_(s, this.syncController_.timelines[s.timeline], this.playlist_), s.cues.length ? s.timingInfo = { start: s.cues[0].startTime, end: s.cues[s.cues.length - 1].endTime } : s.timingInfo = { start: s.startOfSegment, end: s.startOfSegment + s.duration }, s.isSyncRequest) this.trigger("syncinfoupdate"), this.pendingSegment_ = null, this.state = "READY"; else { s.byteLength = s.bytes.byteLength, this.mediaSecondsLoaded += n.duration, s.cues.forEach(e => { this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window.VTTCue(e.startTime, e.endTime, e.text) : e) }); var r = this.subtitlesTrack_, a = r.cues; if (a) { var o = {}; for (let e = a.length - 1; 0 <= e; e--) { var l = a[e], d = `${l.startTime}-${l.endTime}-` + l.text; o[d] ? r.removeCue(l) : o[d] = l } } this.handleAppendsDone_() } } } else this.state = "READY", this.mediaRequestsAborted += 1; else this.state = "READY" } handleData_() { } updateTimingInfoEnd_() { } parseVTTCues_(t) { let e, i = !1; if ("function" != typeof window.WebVTT) throw new lu; "function" == typeof window.TextDecoder ? e = new window.TextDecoder("utf8") : (e = window.WebVTT.StringDecoder(), i = !0); var s = new window.WebVTT.Parser(window, window.vttjs, e); if (t.cues = [], t.timestampmap = { MPEGTS: 0, LOCAL: 0 }, s.oncue = t.cues.push.bind(t.cues), s.ontimestampmap = e => { t.timestampmap = e }, s.onparsingerror = e => { T.log.warn("Error encountered when parsing cues: " + e.message) }, t.segment.map) { let e = t.segment.map.bytes; i && (e = au(e)), s.parse(e) } let n = t.bytes; i && (n = au(n)), s.parse(n), s.flush() } updateTimeMapping_(e, t, i) { var s = e.segment; if (t) if (e.cues.length) { var n = e.timestampmap; const r = n.MPEGTS / Bl - n.LOCAL + t.mapping; e.cues.forEach(e => { e.startTime += r, e.endTime += r }), i.syncInfo || (n = e.cues[0].startTime, t = e.cues[e.cues.length - 1].startTime, i.syncInfo = { mediaSequence: i.mediaSequence + e.mediaIndex, time: Math.min(n, t - s.duration) }) } else s.empty = !0 } } const hu = [{ name: "VOD", run: (e, t, i, s, n) => { return i !== 1 / 0 ? { time: 0, segmentIndex: 0, partIndex: null } : null } }, { name: "ProgramDateTime", run: (t, i, e, s, n) => { if (!Object.keys(t.timelineToDatetimeMappings).length) return null; let r = null, a = null; var o = td(i); n = n || 0; for (let e = 0; e < o.length; e++) { var l = o[i.endList || 0 === n ? e : o.length - (e + 1)], d = l.segment, h = t.timelineToDatetimeMappings[d.timeline]; if (h && d.dateTimeObject) { let t = d.dateTimeObject.getTime() / 1e3 + h; if (d.parts && "number" == typeof l.partIndex) for (let e = 0; e < l.partIndex; e++)t += d.parts[e].duration; h = Math.abs(n - t); if (null !== a && (0 === h || a < h)) break; a = h, r = { time: t, segmentIndex: l.segmentIndex, partIndex: l.partIndex } } } return r } }, { name: "Segment", run: (e, t, i, s, n) => { let r = null, a = null; n = n || 0; var o = td(t); for (let e = 0; e < o.length; e++) { var l = o[t.endList || 0 === n ? e : o.length - (e + 1)], d = l.segment, h = l.part && l.part.start || d && d.start; if (d.timeline === s && "undefined" != typeof h) { d = Math.abs(n - h); if (null !== a && a < d) break; (!r || null === a || a >= d) && (a = d, r = { time: h, segmentIndex: l.segmentIndex, partIndex: l.partIndex }) } } return r } }, { name: "Discontinuity", run: (i, s, e, t, n) => { let r = null; if (n = n || 0, s.discontinuityStarts && s.discontinuityStarts.length) { let t = null; for (let e = 0; e < s.discontinuityStarts.length; e++) { var a = s.discontinuityStarts[e], o = s.discontinuitySequence + e + 1, o = i.discontinuities[o]; if (o) { var l = Math.abs(n - o.time); if (null !== t && t < l) break; (!r || null === t || t >= l) && (t = l, r = { time: o.time, segmentIndex: a, partIndex: null }) } } } return r } }, { name: "Playlist", run: (e, t, i, s, n) => { return t.syncInfo ? { time: t.syncInfo.time, segmentIndex: t.syncInfo.mediaSequence - t.mediaSequence, partIndex: null } : null } }]; class uu extends T.EventTarget { constructor(e = 0) { super(), this.timelines = [], this.discontinuities = [], this.timelineToDatetimeMappings = {}, this.logger_ = Hl("SyncController") } getSyncPoint(e, t, i, s) { e = this.runStrategies_(e, t, i, s); return e.length ? this.selectSyncPoint_(e, { key: "time", value: s }) : null } getExpiredTime(e, t) { return e && e.segments && (t = this.runStrategies_(e, t, e.discontinuitySequence, 0)).length ? (0 < (t = this.selectSyncPoint_(t, { key: "segmentIndex", value: 0 })).segmentIndex && (t.time *= -1), Math.abs(t.time + Gl({ defaultDuration: e.targetDuration, durationList: e.segments, startIndex: t.segmentIndex, endIndex: 0 }))) : null } runStrategies_(t, i, s, n) { var r = []; for (let e = 0; e < hu.length; e++) { var a = hu[e], o = a.run(this, t, i, s, n); o && (o.strategy = a.name, r.push({ strategy: a.name, syncPoint: o })) } return r } selectSyncPoint_(t, i) { let s = t[0].syncPoint, n = Math.abs(t[0].syncPoint[i.key] - i.value), r = t[0].strategy; for (let e = 1; e < t.length; e++) { var a = Math.abs(t[e].syncPoint[i.key] - i.value); a < n && (n = a, s = t[e].syncPoint, r = t[e].strategy) } return this.logger_(`syncPoint for [${i.key}: ${i.value}] chosen with strategy` + ` [${r}]: [time:${s.time},` + " segmentIndex:" + s.segmentIndex + ("number" == typeof s.partIndex ? ",partIndex:" + s.partIndex : "") + "]"), s } saveExpiredSegmentInfo(t, i) { var s = i.mediaSequence - t.mediaSequence; if (86400 < s) T.log.warn(`Not saving expired segment info. Media sequence gap ${s} is too large.`); else for (let e = s - 1; 0 <= e; e--) { var n = t.segments[e]; if (n && "undefined" != typeof n.start) { i.syncInfo = { mediaSequence: t.mediaSequence + e, time: n.start }, this.logger_(`playlist refresh sync: [time:${i.syncInfo.time},` + ` mediaSequence: ${i.syncInfo.mediaSequence}]`), this.trigger("syncinfoupdate"); break } } } setDateTimeMappingForStart(e) { var t; this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject && (t = (e = e.segments[0]).dateTimeObject.getTime() / 1e3, this.timelineToDatetimeMappings[e.timeline] = -t) } saveSegmentTimingInfo({ segmentInfo: e, shouldSaveTimelineMapping: t }) { var i = this.calculateSegmentTimeMapping_(e, e.timingInfo, t), s = e.segment, i = (i && (this.saveDiscontinuitySyncInfo_(e), e.playlist.syncInfo || (e.playlist.syncInfo = { mediaSequence: e.playlist.mediaSequence + e.mediaIndex, time: s.start })), s.dateTimeObject); s.discontinuity && t && i && (this.timelineToDatetimeMappings[s.timeline] = -i.getTime() / 1e3) } timestampOffsetForTimeline(e) { return "undefined" == typeof this.timelines[e] ? null : this.timelines[e].time } mappingForTimeline(e) { return "undefined" == typeof this.timelines[e] ? null : this.timelines[e].mapping } calculateSegmentTimeMapping_(e, t, i) { var s = e.segment, n = e.part; let r = this.timelines[e.timeline], a, o; if ("number" == typeof e.timestampOffset) r = { time: e.startOfSegment, mapping: e.startOfSegment - t.start }, i && (this.timelines[e.timeline] = r, this.trigger("timestampoffset"), this.logger_(`time mapping for timeline ${e.timeline}: ` + `[time: ${r.time}] [mapping: ${r.mapping}]`)), a = e.startOfSegment; else { if (!r) return !1; a = t.start + r.mapping } return o = t.end + r.mapping, n && (n.start = a, n.end = o), (!s.start || a < s.start) && (s.start = a), s.end = o, !0 } saveDiscontinuitySyncInfo_(t) { var i = t.playlist, s = t.segment; if (s.discontinuity) this.discontinuities[s.timeline] = { time: s.start, accuracy: 0 }; else if (i.discontinuityStarts && i.discontinuityStarts.length) for (let e = 0; e < i.discontinuityStarts.length; e++) { var n = i.discontinuityStarts[e], r = i.discontinuitySequence + e + 1, a = n - t.mediaIndex, o = Math.abs(a); if (!this.discontinuities[r] || this.discontinuities[r].accuracy > o) { let e; e = a < 0 ? s.start - Gl({ defaultDuration: i.targetDuration, durationList: i.segments, startIndex: t.mediaIndex, endIndex: n }) : s.end + Gl({ defaultDuration: i.targetDuration, durationList: i.segments, startIndex: t.mediaIndex + 1, endIndex: n }), this.discontinuities[r] = { time: e, accuracy: o } } } } dispose() { this.trigger("dispose"), this.off() } } class cu extends T.EventTarget { constructor() { super(), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {} } clearPendingTimelineChange(e) { this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange") } pendingTimelineChange({ type: e, from: t, to: i }) { return "number" == typeof t && "number" == typeof i && (this.pendingTimelineChanges_[e] = { type: e, from: t, to: i }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[e] } lastTimelineChange({ type: e, from: t, to: i }) { return "number" == typeof t && "number" == typeof i && (this.lastTimelineChanges_[e] = { type: e, from: t, to: i }, delete this.pendingTimelineChanges_[e], this.trigger("timelinechange")), this.lastTimelineChanges_[e] } dispose() { this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off() } } var pu = th(ih(sh(function () {
    var e = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { return !!this.listeners[e] && (t = this.listeners[e].indexOf(t), this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(t, 1), -1 < t) }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var i = t.length, s = 0; s < i; ++s)t[s].call(this, arguments[1]); else for (var n = Array.prototype.slice.call(arguments, 1), r = t.length, a = 0; a < r; ++a)t[a].apply(this, n) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (t) { this.on("data", function (e) { t.push(e) }) }, e }();
/*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */let h = null; class g { constructor(e) { h = h || function () { var e = [[[], [], [], [], []], [[], [], [], [], []]], t = e[0], i = e[1], s = t[4], n = i[4]; let r, a, o; var l, d, h, u, c = [], p = []; let m, g; for (r = 0; r < 256; r++)p[(c[r] = r << 1 ^ 283 * (r >> 7)) ^ r] = r; for (a = o = 0; !s[a]; a ^= l || 1, o = p[o] || 1)for (u = (u = o ^ o << 1 ^ o << 2 ^ o << 3 ^ o << 4) >> 8 ^ 255 & u ^ 99, h = c[d = c[l = c[n[s[a] = u] = a]]], g = 16843009 * h ^ 65537 * d ^ 257 * l ^ 16843008 * a, m = 257 * c[u] ^ 16843008 * u, r = 0; r < 4; r++)t[r][a] = m = m << 24 ^ m >>> 8, i[r][u] = g = g << 24 ^ g >>> 8; for (r = 0; r < 5; r++)t[r] = t[r].slice(0), i[r] = i[r].slice(0); return e }(), this._tables = [[h[0][0].slice(), h[0][1].slice(), h[0][2].slice(), h[0][3].slice(), h[0][4].slice()], [h[1][0].slice(), h[1][1].slice(), h[1][2].slice(), h[1][3].slice(), h[1][4].slice()]]; let t, i, s; var n = this._tables[0][4], r = this._tables[1], a = e.length; let o = 1; if (4 !== a && 6 !== a && 8 !== a) throw new Error("Invalid aes key size"); var l = e.slice(0), d = []; for (this._key = [l, d], t = a; t < 4 * a + 28; t++)s = l[t - 1], (t % a == 0 || 8 === a && t % a == 4) && (s = n[s >>> 24] << 24 ^ n[s >> 16 & 255] << 16 ^ n[s >> 8 & 255] << 8 ^ n[255 & s], t % a == 0) && (s = s << 8 ^ s >>> 24 ^ o << 24, o = o << 1 ^ 283 * (o >> 7)), l[t] = l[t - a] ^ s; for (i = 0; t; i++, t--)s = l[3 & i ? t : t - 4], t <= 4 || i < 4 ? d[i] = s : d[i] = r[0][n[s >>> 24]] ^ r[1][n[s >> 16 & 255]] ^ r[2][n[s >> 8 & 255]] ^ r[3][n[255 & s]] } decrypt(e, t, i, s, n, r) { var a, o, l = this._key[1]; let d = e ^ l[0], h = s ^ l[1], u = i ^ l[2], c = t ^ l[3], p; var m = l.length / 4 - 2; let g, f = 4; var e = this._tables[1], y = e[0], _ = e[1], v = e[2], b = e[3], T = e[4]; for (g = 0; g < m; g++)p = y[d >>> 24] ^ _[h >> 16 & 255] ^ v[u >> 8 & 255] ^ b[255 & c] ^ l[f], a = y[h >>> 24] ^ _[u >> 16 & 255] ^ v[c >> 8 & 255] ^ b[255 & d] ^ l[f + 1], o = y[u >>> 24] ^ _[c >> 16 & 255] ^ v[d >> 8 & 255] ^ b[255 & h] ^ l[f + 2], c = y[c >>> 24] ^ _[d >> 16 & 255] ^ v[h >> 8 & 255] ^ b[255 & u] ^ l[f + 3], f += 4, d = p, h = a, u = o; for (g = 0; g < 4; g++)n[(3 & -g) + r] = T[d >>> 24] << 24 ^ T[h >> 16 & 255] << 16 ^ T[u >> 8 & 255] << 8 ^ T[255 & c] ^ l[f++], p = d, d = h, h = u, u = c, c = p } } class l extends e { constructor() { super(e), this.jobs = [], this.delay = 1, this.timeout_ = null } processJob_() { this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null } push(e) { this.jobs.push(e), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay)) } } function f(e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 } class d {
      constructor(e, t, i, s) {
        var n = d.STEP, r = new Int32Array(e.buffer); const a = new Uint8Array(e.byteLength); let o = 0; for (this.asyncStream_ = new l, this.asyncStream_.push(this.decryptChunk_(r.subarray(o, o + n), t, i, a)), o = n; o < r.length; o += n)i = new Uint32Array([f(r[o - 4]), f(r[o - 3]), f(r[o - 2]), f(r[o - 1])]), this.asyncStream_.push(this.decryptChunk_(r.subarray(o, o + n), t, i, a)); this.asyncStream_.push(function () {
          var e;
/*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */s(null, (e = a).subarray(0, e.byteLength - e[e.byteLength - 1]))
        })
      } static get STEP() { return 32e3 } decryptChunk_(t, i, s, n) { return function () { var e = function (e, t, i) { var s, n, r, a, o = new Int32Array(e.buffer, e.byteOffset, e.byteLength >> 2), l = new g(Array.prototype.slice.call(t)), t = new Uint8Array(e.byteLength), d = new Int32Array(t.buffer); let h, u, c, p, m; for (h = i[0], u = i[1], c = i[2], p = i[3], m = 0; m < o.length; m += 4)s = f(o[m]), n = f(o[m + 1]), r = f(o[m + 2]), a = f(o[m + 3]), l.decrypt(s, n, r, a, d, m), d[m] = f(d[m] ^ h), d[m + 1] = f(d[m + 1] ^ u), d[m + 2] = f(d[m + 2] ^ c), d[m + 3] = f(d[m + 3] ^ p), h = s, u = n, c = r, p = a; return t }(t, i, s); n.set(e, t.byteOffset) } }
    } var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, t = "undefined" != typeof window ? window : "undefined" != typeof t ? t : "undefined" != typeof self ? self : {}, t = t.BigInt || Number; t("0x1"), t("0x100"), t("0x10000"), t("0x1000000"), t("0x100000000"), t("0x10000000000"), t("0x1000000000000"), t("0x100000000000000"), t("0x10000000000000000"), t = new Uint16Array([65484]), 255 !== (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))[0] && t[0]; function n(s) { const n = {}; return Object.keys(s).forEach(e => { var t, i = s[e]; t = i, ("function" === ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer) ? n[e] = { bytes: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength } : n[e] = i }), n } self.onmessage = function (e) { const i = e.data; var e = new Uint8Array(i.encrypted.bytes, i.encrypted.byteOffset, i.encrypted.byteLength), t = new Uint32Array(i.key.bytes, i.key.byteOffset, i.key.byteLength / 4), s = new Uint32Array(i.iv.bytes, i.iv.byteOffset, i.iv.byteLength / 4); new d(e, t, s, function (e, t) { self.postMessage(n({ source: i.source, decrypted: t }), [t.buffer]) }) }
  }))); const mu = (e, t) => { e.abort(), e.pause(), t && t.activePlaylistLoader && (t.activePlaylistLoader.pause(), t.activePlaylistLoader = null) }, gu = (e, t) => { (t.activePlaylistLoader = e).load() }, fu = { AUDIO: (a, o) => () => { var { segmentLoaders: { [a]: e }, mediaTypes: { [a]: t }, excludePlaylist: i } = o, e = (mu(e, t), t.activeTrack()), s = t.activeGroup(), s = (s.filter(e => e.default)[0] || s[0]).id, n = t.tracks[s]; if (e === n) i({ error: { message: "Problem encountered loading the default audio track." } }); else { T.log.warn("Problem encountered loading the alternate audio track.Switching back to default."); for (const r in t.tracks) t.tracks[r].enabled = t.tracks[r] === n; t.onTrackChanged() } }, SUBTITLES: (i, s) => () => { var { segmentLoaders: { [i]: e }, mediaTypes: { [i]: t } } = s, e = (T.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track."), mu(e, t), t.activeTrack()); e && (e.mode = "disabled"), t.onTrackChanged() } }, yu = { AUDIO: (e, t, i) => { if (!t) return; const { tech: s, requestOptions: n, segmentLoaders: { [e]: r } } = i; t.on("loadedmetadata", () => { var e = t.media(); r.playlist(e, n), (!s.paused() || e.endList && "none" !== s.preload()) && r.load() }), t.on("loadedplaylist", () => { r.playlist(t.media(), n), s.paused() || r.load() }), t.on("error", fu[e](e, i)) }, SUBTITLES: (e, t, i) => { const { tech: s, requestOptions: n, segmentLoaders: { [e]: r }, mediaTypes: { [e]: a } } = i; t.on("loadedmetadata", () => { var e = t.media(); r.playlist(e, n), r.track(a.activeTrack()), (!s.paused() || e.endList && "none" !== s.preload()) && r.load() }), t.on("loadedplaylist", () => { r.playlist(t.media(), n), s.paused() || r.load() }), t.on("error", fu[e](e, i)) } }, _u = { AUDIO: (i, s) => { var n, { vhs: r, sourceType: a, segmentLoaders: { [i]: e }, requestOptions: o, main: { mediaGroups: l }, mediaTypes: { [i]: { groups: d, tracks: h, logger_: u } }, mainPlaylistLoader: c } = s, p = fd(c.main); l[i] && 0 !== Object.keys(l[i]).length || (l[i] = { main: { default: { default: !0 } } }, p && (l[i].main.default.playlists = c.main.playlists)); for (const m in l[i]) { d[m] || (d[m] = []); for (const g in l[i][m]) { let e = l[i][m][g], t; t = p ? (u(`AUDIO group '${m}' label '${g}' is a main playlist`), e.isMainPlaylist = !0, null) : "vhs-json" === a && e.playlists ? new Ad(e.playlists[0], r, o) : e.resolvedUri ? new Ad(e.resolvedUri, r, o) : e.playlists && "dash" === a ? new Jd(e.playlists[0], r, o, c) : null, e = D({ id: g, playlistLoader: t }, e), yu[i](i, e.playlistLoader, s), d[m].push(e), "undefined" == typeof h[g] && (n = new T.AudioTrack({ id: g, kind: (e => { let t = e.default ? "main" : "alternative"; return t = e.characteristics && 0 <= e.characteristics.indexOf("public.accessibility.describes-video") ? "main-desc" : t })(e), enabled: !1, language: e.language, default: e.default, label: g }), h[g] = n) } } e.on("error", fu[i](i, s)) }, SUBTITLES: (i, s) => { var n, { tech: r, vhs: a, sourceType: o, segmentLoaders: { [i]: e }, requestOptions: l, main: { mediaGroups: d }, mediaTypes: { [i]: { groups: h, tracks: u } }, mainPlaylistLoader: c } = s; for (const p in d[i]) { h[p] || (h[p] = []); for (const m in d[i][p]) if (a.options_.useForcedSubtitles || !d[i][p][m].forced) { let e = d[i][p][m], t; if ("hls" === o) t = new Ad(e.resolvedUri, a, l); else if ("dash" === o) { if (!e.playlists.filter(e => e.excludeUntil !== 1 / 0).length) return; t = new Jd(e.playlists[0], a, l, c) } else "vhs-json" === o && (t = new Ad(e.playlists ? e.playlists[0] : e.resolvedUri, a, l)); e = D({ id: m, playlistLoader: t }, e), yu[i](i, e.playlistLoader, s), h[p].push(e), "undefined" == typeof u[m] && (n = r.addRemoteTextTrack({ id: m, kind: "subtitles", default: e.default && e.autoselect, language: e.language, label: m }, !1).track, u[m] = n) } } e.on("error", fu[i](i, s)) }, "CLOSED-CAPTIONS": (e, t) => { var { tech: i, main: { mediaGroups: s }, mediaTypes: { [e]: { groups: n, tracks: r } } } = t; for (const l in s[e]) { n[l] || (n[l] = []); for (const d in s[e][l]) { var a = s[e][l][d]; if (/^(?:CC|SERVICE)/.test(a.instreamId)) { var o = i.options_.vhs && i.options_.vhs.captionServices || {}; let e = { label: d, language: a.language, instreamId: a.instreamId, default: a.default && a.autoselect }; void 0 === (e = o[e.instreamId] ? D(e, o[e.instreamId]) : e).default && delete e.default, n[l].push(D({ id: d }, a)), "undefined" == typeof r[d] && (o = i.addRemoteTextTrack({ id: e.instreamId, kind: "captions", default: e.default, language: e.language, label: e.label }, !1).track, r[d] = o) } } } } }, vu = (t, i) => { for (let e = 0; e < t.length; e++) { if (gd(i, t[e])) return !0; if (t[e].playlists && vu(t[e].playlists, i)) return !0 } return !1 }, bu = { AUDIO: (i, s) => () => { var { [i]: { tracks: e } } = s["mediaTypes"]; for (const t in e) if (e[t].enabled) return e[t]; return null }, SUBTITLES: (i, s) => () => { var { [i]: { tracks: e } } = s["mediaTypes"]; for (const t in e) if ("showing" === e[t].mode || "hidden" === e[t].mode) return e[t]; return null } }, Tu = r => { ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(e => { _u[e](e, r) }); const { mediaTypes: a, mainPlaylistLoader: e, tech: t, vhs: i, segmentLoaders: { AUDIO: s, main: n } } = r;["AUDIO", "SUBTITLES"].forEach(e => { var o, l, d, h, i, s, u, c, t, n; a[e].activeGroup = (o = e, l = r, t => { var { mainPlaylistLoader: e, mediaTypes: { [o]: { groups: i } } } = l, s = e.media(); if (!s) return null; let n = null; s.attributes[o] && (n = i[s.attributes[o]]); var r = Object.keys(i); if (!n) if ("AUDIO" === o && 1 < r.length && fd(l.main)) for (let e = 0; e < r.length; e++) { var a = i[r[e]]; if (vu(a, s)) { n = a; break } } else i.main ? n = i.main : 1 === r.length && (n = i[r[0]]); return "undefined" == typeof t ? n : null !== t && n && n.filter(e => e.id === t.id)[0] || null }), a[e].activeTrack = bu[e](e, r), a[e].onGroupChanged = (d = e, h = r, () => { var { segmentLoaders: { [d]: e, main: t }, mediaTypes: { [d]: i } } = h, s = i.activeTrack(), n = i.getActiveGroup(), r = i.activePlaylistLoader, a = i.lastGroup_; n && a && n.id === a.id || (i.lastGroup_ = n, i.lastTrack_ = s, mu(e, i), n && !n.isMainPlaylist && (n.playlistLoader ? (e.resyncLoader(), gu(n.playlistLoader, i)) : r && t.resetEverything())) }), a[e].onGroupChanging = (i = e, s = r, () => { var { segmentLoaders: { [i]: e }, mediaTypes: { [i]: t } } = s; t.lastGroup_ = null, e.abort(), e.pause() }), a[e].onTrackChanged = (u = e, c = r, () => { var e, t, { mainPlaylistLoader: i, segmentLoaders: { [u]: s, main: n }, mediaTypes: { [u]: r } } = c, a = r.activeTrack(), o = r.getActiveGroup(), l = r.activePlaylistLoader, d = r.lastTrack_; if ((!d || !a || d.id !== a.id) && (r.lastGroup_ = o, r.lastTrack_ = a, mu(s, r), o)) { if (o.isMainPlaylist) return !a || !d || a.id === d.id || (t = (e = c.vhs.playlistController_).selectPlaylist(), e.media() === t) ? void 0 : (r.logger_(`track change. Switching main audio from ${d.id} to ` + a.id), i.pause(), n.resetEverything(), void e.fastQualityChange_(t)); if ("AUDIO" === u) { if (!o.playlistLoader) return n.setAudio(!0), void n.resetEverything(); s.setAudio(!0), n.setAudio(!1) } l === o.playlistLoader || (s.track && s.track(a), s.resetEverything()), gu(o.playlistLoader, r) } }), a[e].getActiveGroup = ([t, n] = [e, r["mediaTypes"]], () => { var e = n[t].activeTrack(); return e ? n[t].activeGroup(e) : null }) }); var o = a.AUDIO.activeGroup(); o && (o = (o.filter(e => e.default)[0] || o[0]).id, a.AUDIO.tracks[o].enabled = !0, a.AUDIO.onGroupChanged(), a.AUDIO.onTrackChanged(), (a.AUDIO.getActiveGroup().playlistLoader ? (n.setAudio(!1), s) : n).setAudio(!0)), e.on("mediachange", () => { ["AUDIO", "SUBTITLES"].forEach(e => a[e].onGroupChanged()) }), e.on("mediachanging", () => { ["AUDIO", "SUBTITLES"].forEach(e => a[e].onGroupChanging()) }); const l = () => { a.AUDIO.onTrackChanged(), t.trigger({ type: "usage", name: "vhs-audio-change" }) }; t.audioTracks().addEventListener("change", l), t.remoteTextTracks().addEventListener("change", a.SUBTITLES.onTrackChanged), i.on("dispose", () => { t.audioTracks().removeEventListener("change", l), t.remoteTextTracks().removeEventListener("change", a.SUBTITLES.onTrackChanged) }), t.clearTracks("audio"); for (const d in a.AUDIO.tracks) t.audioTracks().addTrack(a.AUDIO.tracks[d]) }; let Su; const wu = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"]; class Eu extends T.EventTarget { constructor(e) { super(); const { src: t, withCredentials: i, tech: n, bandwidth: s, externVhs: r, useCueTags: a, playlistExclusionDuration: o, enableLowInitialPlaylist: l, sourceType: d, cacheEncryptionKeys: h, bufferBasedABR: u, leastPixelDiffSelector: c, captionServices: p } = e; if (!t) throw new Error("A non-empty playlist URL or JSON manifest string is required"); let m = e["maxPlaylistRetries"]; null !== m && "undefined" != typeof m || (m = 1 / 0), Su = r, this.bufferBasedABR = Boolean(u), this.leastPixelDiffSelector = Boolean(c), this.withCredentials = i, this.tech_ = n, this.vhs_ = n.vhs, this.sourceType_ = d, this.useCueTags_ = a, this.playlistExclusionDuration = o, this.maxPlaylistRetries = m, this.enableLowInitialPlaylist = l, this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"), this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), this.requestOptions_ = { withCredentials: i, maxPlaylistRetries: m, timeout: null }, this.on("error", this.pauseLoading), this.mediaTypes_ = (() => { const t = {}; return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(e => { t[e] = { groups: {}, tracks: {}, activePlaylistLoader: null, activeGroup: Kh, activeTrack: Kh, getActiveGroup: Kh, onGroupChanged: Kh, onTrackChanged: Kh, lastTrack_: null, logger_: Hl(`MediaGroups[${e}]`) } }), t })(), this.mediaSource = new window.MediaSource, this.handleDurationChange_ = this.handleDurationChange_.bind(this), this.handleSourceOpen_ = this.handleSourceOpen_.bind(this), this.handleSourceEnded_ = this.handleSourceEnded_.bind(this), this.mediaSource.addEventListener("durationchange", this.handleDurationChange_), this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_), this.seekable_ = Vl(), this.hasPlayed_ = !1, this.syncController_ = new uu(e), this.segmentMetadataTrack_ = n.addRemoteTextTrack({ kind: "metadata", label: "segment-metadata" }, !1).track, this.decrypter_ = new pu, this.sourceUpdater_ = new ru(this.mediaSource), this.inbandTextTracks_ = {}, this.timelineChangeController_ = new cu; var g = { vhs: this.vhs_, parse708captions: e.parse708captions, useDtsForTimestampOffset: e.useDtsForTimestampOffset, captionServices: p, mediaSource: this.mediaSource, currentTime: this.tech_.currentTime.bind(this.tech_), seekable: () => this.seekable(), seeking: () => this.tech_.seeking(), duration: () => this.duration(), hasPlayed: () => this.hasPlayed_, goalBufferLength: () => this.goalBufferLength(), bandwidth: s, syncController: this.syncController_, decrypter: this.decrypter_, sourceType: this.sourceType_, inbandTextTracks: this.inbandTextTracks_, cacheEncryptionKeys: h, sourceUpdater: this.sourceUpdater_, timelineChangeController: this.timelineChangeController_, exactManifestTimings: e.exactManifestTimings, addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this) }, g = (this.mainPlaylistLoader_ = "dash" === this.sourceType_ ? new Jd(t, this.vhs_, D(this.requestOptions_, { addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this) })) : new Ad(t, this.vhs_, this.requestOptions_), this.setupMainPlaylistLoaderListeners_(), this.mainSegmentLoader_ = new Xh(D(g, { segmentMetadataTrack: this.segmentMetadataTrack_, loaderType: "main" }), e), this.audioSegmentLoader_ = new Xh(D(g, { loaderType: "audio" }), e), this.subtitleSegmentLoader_ = new du(D(g, { loaderType: "vtt", featuresNativeTextTracks: this.tech_.featuresNativeTextTracks, loadVttJs: () => new Promise((e, t) => { function i() { n.off("vttjserror", s), e() } function s() { n.off("vttjsloaded", i), t() } n.one("vttjsloaded", i), n.one("vttjserror", s), n.addWebVttScript_() }) }), e), this.setupSegmentLoaderListeners_(), this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", () => this.startABRTimer_()), this.tech_.on("pause", () => this.stopABRTimer_()), this.tech_.on("play", () => this.startABRTimer_())), wu.forEach(e => { this[e + "_"] = function (e) { return this.audioSegmentLoader_[e] + this.mainSegmentLoader_[e] }.bind(this, e) }), this.logger_ = Hl("pc"), this.triggeredFmp4Usage = !1, "none" === this.tech_.preload() ? (this.loadOnPlay_ = () => { this.loadOnPlay_ = null, this.mainPlaylistLoader_.load() }, this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(), this.timeToLoadedData__ = -1, this.mainAppendsToLoadedData__ = -1, this.audioAppendsToLoadedData__ = -1, "none" === this.tech_.preload() ? "play" : "loadstart"); this.tech_.one(g, () => { const e = Date.now(); this.tech_.one("loadeddata", () => { this.timeToLoadedData__ = Date.now() - e, this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends, this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends }) }) } mainAppendsToLoadedData_() { return this.mainAppendsToLoadedData__ } audioAppendsToLoadedData_() { return this.audioAppendsToLoadedData__ } appendsToLoadedData_() { var e = this.mainAppendsToLoadedData_(), t = this.audioAppendsToLoadedData_(); return -1 === e || -1 === t ? -1 : e + t } timeToLoadedData_() { return this.timeToLoadedData__ } checkABR_(e = "abr") { var t = this.selectPlaylist(); t && this.shouldSwitchToMedia_(t) && this.switchMedia_(t, e) } switchMedia_(e, t, i) { var s = this.media(), s = s && (s.id || s.uri), n = e.id || e.uri; s && s !== n && (this.logger_(`switch media ${s} -> ${n} from ` + t), this.tech_.trigger({ type: "usage", name: "vhs-rendition-change-" + t })), this.mainPlaylistLoader_.media(e, i) } startABRTimer_() { this.stopABRTimer_(), this.abrTimer_ = window.setInterval(() => this.checkABR_(), 250) } stopABRTimer_() { this.tech_.scrubbing && this.tech_.scrubbing() || (window.clearInterval(this.abrTimer_), this.abrTimer_ = null) } getAudioTrackPlaylists_() { var t = this.main(), e = t && t.playlists || []; if (!t || !t.mediaGroups || !t.mediaGroups.AUDIO) return e; var i = t.mediaGroups.AUDIO, s = Object.keys(i); let n; if (Object.keys(this.mediaTypes_.AUDIO.groups).length) n = this.mediaTypes_.AUDIO.activeTrack(); else { var r = i.main || s.length && i[s[0]]; for (const d in r) if (r[d].default) { n = { label: d }; break } } if (!n) return e; var a = []; for (const h in i) if (i[h][n.label]) { var o = i[h][n.label]; if (o.playlists && o.playlists.length) a.push.apply(a, o.playlists); else if (o.uri) a.push(o); else if (t.playlists.length) for (let e = 0; e < t.playlists.length; e++) { var l = t.playlists[e]; l.attributes && l.attributes.AUDIO && l.attributes.AUDIO === h && a.push(l) } } return a.length ? a : e } setupMainPlaylistLoaderListeners_() { this.mainPlaylistLoader_.on("loadedmetadata", () => { var e = this.mainPlaylistLoader_.media(), t = 1.5 * e.targetDuration * 1e3; md(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, e.endList && "none" !== this.tech_.preload() && (this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load()), Tu({ sourceType: this.sourceType_, segmentLoaders: { AUDIO: this.audioSegmentLoader_, SUBTITLES: this.subtitleSegmentLoader_, main: this.mainSegmentLoader_ }, tech: this.tech_, requestOptions: this.requestOptions_, mainPlaylistLoader: this.mainPlaylistLoader_, vhs: this.vhs_, main: this.main(), mediaTypes: this.mediaTypes_, excludePlaylist: this.excludePlaylist.bind(this) }), this.triggerPresenceUsage_(this.main(), e), this.setupFirstPlay(), !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", () => { this.trigger("selectedinitialmedia") }) }), this.mainPlaylistLoader_.on("loadedplaylist", () => { this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_); let t = this.mainPlaylistLoader_.media(); if (!t) { this.excludeUnsupportedVariants_(); let e; if (!(e = (e = this.enableLowInitialPlaylist ? this.selectInitialPlaylist() : e) || this.selectPlaylist()) || !this.shouldSwitchToMedia_(e)) return; if (this.initialMedia_ = e, this.switchMedia_(this.initialMedia_, "initial"), !("vhs-json" === this.sourceType_ && this.initialMedia_.segments)) return; t = this.initialMedia_ } this.handleUpdatedMediaPlaylist(t) }), this.mainPlaylistLoader_.on("error", () => { var e = this.mainPlaylistLoader_.error; this.excludePlaylist({ playlistToExclude: e.playlist, error: e }) }), this.mainPlaylistLoader_.on("mediachanging", () => { this.mainSegmentLoader_.abort(), this.mainSegmentLoader_.pause() }), this.mainPlaylistLoader_.on("mediachange", () => { var e = this.mainPlaylistLoader_.media(), t = 1.5 * e.targetDuration * 1e3; md(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, this.mainPlaylistLoader_.load(), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load(), this.tech_.trigger({ type: "mediachange", bubbles: !0 }) }), this.mainPlaylistLoader_.on("playlistunchanged", () => { var e = this.mainPlaylistLoader_.media(); "playlist-unchanged" !== e.lastExcludeReason_ && this.stuckAtPlaylistEnd_(e) && (this.excludePlaylist({ error: { message: "Playlist no longer updating.", reason: "playlist-unchanged" } }), this.tech_.trigger("playliststuck")) }), this.mainPlaylistLoader_.on("renditiondisabled", () => { this.tech_.trigger({ type: "usage", name: "vhs-rendition-disabled" }) }), this.mainPlaylistLoader_.on("renditionenabled", () => { this.tech_.trigger({ type: "usage", name: "vhs-rendition-enabled" }) }) } handleUpdatedMediaPlaylist(e) { this.useCueTags_ && this.updateAdCues_(e), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load()) } triggerPresenceUsage_(e, t) { var i = e.mediaGroups || {}; let s = !0; e = Object.keys(i.AUDIO); for (const n in i.AUDIO) for (const r in i.AUDIO[n]) i.AUDIO[n][r].uri || (s = !1); s && this.tech_.trigger({ type: "usage", name: "vhs-demuxed" }), Object.keys(i.SUBTITLES).length && this.tech_.trigger({ type: "usage", name: "vhs-webvtt" }), Su.Playlist.isAes(t) && this.tech_.trigger({ type: "usage", name: "vhs-aes" }), e.length && 1 < Object.keys(i.AUDIO[e[0]]).length && this.tech_.trigger({ type: "usage", name: "vhs-alternate-audio" }), this.useCueTags_ && this.tech_.trigger({ type: "usage", name: "vhs-playlist-cue-tags" }) } shouldSwitchToMedia_(t) { var e = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_, i = this.tech_.currentTime(), s = this.bufferLowWaterLine(), n = this.bufferHighWaterLine(), { currentPlaylist: i, buffered: e, currentTime: t, nextPlaylist: s, bufferLowWaterLine: n, bufferHighWaterLine: r, duration: a, bufferBasedABR: o, log: l } = [{ buffered: this.tech_.buffered(), currentTime: i, currentPlaylist: e, nextPlaylist: t, bufferLowWaterLine: s, bufferHighWaterLine: n, duration: this.duration(), bufferBasedABR: this.bufferBasedABR, log: this.logger_ }][0]; if (s) { var d = `allowing switch ${i && i.id || "null"} -> ` + s.id; if (!i) return l(d + " as current playlist is not set"), !0; if (s.id !== i.id) { var h = Boolean(ql(e, t).length); if (!i.endList) return h || "number" != typeof i.partTargetDuration ? (l(d + " as current playlist is live"), !0) : (l(`not ${d} as current playlist is live llhls, but currentTime isn't in buffered.`), !1); h = Wl(e, t), e = o ? O.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : O.MAX_BUFFER_LOW_WATER_LINE; if (a < e) return l(d + ` as duration < max low water line (${a} < ${e})`), !0; t = s.attributes.BANDWIDTH, a = i.attributes.BANDWIDTH; if (t < a && (!o || h < r)) { let e = d + ` as next bandwidth < current bandwidth (${t} < ${a})`; return o && (e += ` and forwardBuffer < bufferHighWaterLine (${h} < ${r})`), l(e), !0 } if ((!o || a < t) && n <= h) { let e = d + ` as forwardBuffer >= bufferLowWaterLine (${h} >= ${n})`; return o && (e += ` and next bandwidth > current bandwidth (${t} > ${a})`), l(e), !0 } l(`not ${d} as no switching criteria met`) } } else T.log.warn("We received no playlist to switch to. Please check your stream."); return !1 } setupSegmentLoaderListeners_() { this.mainSegmentLoader_.on("bandwidthupdate", () => { this.checkABR_("bandwidthupdate"), this.tech_.trigger("bandwidthupdate") }), this.mainSegmentLoader_.on("timeout", () => { this.bufferBasedABR && this.mainSegmentLoader_.load() }), this.bufferBasedABR || this.mainSegmentLoader_.on("progress", () => { this.trigger("progress") }), this.mainSegmentLoader_.on("error", () => { var e = this.mainSegmentLoader_.error(); this.excludePlaylist({ playlistToExclude: e.playlist, error: e }) }), this.mainSegmentLoader_.on("appenderror", () => { this.error = this.mainSegmentLoader_.error_, this.trigger("error") }), this.mainSegmentLoader_.on("syncinfoupdate", () => { this.onSyncInfoUpdate_() }), this.mainSegmentLoader_.on("timestampoffset", () => { this.tech_.trigger({ type: "usage", name: "vhs-timestamp-offset" }) }), this.audioSegmentLoader_.on("syncinfoupdate", () => { this.onSyncInfoUpdate_() }), this.audioSegmentLoader_.on("appenderror", () => { this.error = this.audioSegmentLoader_.error_, this.trigger("error") }), this.mainSegmentLoader_.on("ended", () => { this.logger_("main segment loader ended"), this.onEndOfStream() }), this.mainSegmentLoader_.on("earlyabort", e => { this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]), this.excludePlaylist({ error: { message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering." }, playlistExclusionDuration: 120 })) }); var e = () => { if (!this.sourceUpdater_.hasCreatedSourceBuffers()) return this.tryToCreateSourceBuffers_(); var e = this.getCodecsOrExclude_(); e && this.sourceUpdater_.addOrChangeSourceBuffers(e) }; this.mainSegmentLoader_.on("trackinfo", e), this.audioSegmentLoader_.on("trackinfo", e), this.mainSegmentLoader_.on("fmp4", () => { this.triggeredFmp4Usage || (this.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), this.triggeredFmp4Usage = !0) }), this.audioSegmentLoader_.on("fmp4", () => { this.triggeredFmp4Usage || (this.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), this.triggeredFmp4Usage = !0) }), this.audioSegmentLoader_.on("ended", () => { this.logger_("audioSegmentLoader ended"), this.onEndOfStream() }) } mediaSecondsLoaded_() { return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded) } load() { this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load() } fastQualityChange_(e = this.selectPlaylist()) { e === this.mainPlaylistLoader_.media() ? this.logger_("skipping fastQualityChange because new media is same as old") : (this.switchMedia_(e, "fast-quality"), this.mainSegmentLoader_.resetEverything(() => { this.tech_.setCurrentTime(this.tech_.currentTime()) })) } play() { var e; if (!this.setupFirstPlay()) return this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load(), e = this.tech_.seekable(), this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0) ? this.tech_.setCurrentTime(e.end(e.length - 1)) : void 0 } setupFirstPlay() { var t = this.mainPlaylistLoader_.media(); if (!t || this.tech_.paused() || this.hasPlayed_) return !1; if (!t.endList || t.start) { var i = this.seekable(); if (!i.length) return !1; var s = i.end(0); let e = s; t.start && (t = t.start.timeOffset, e = t < 0 ? Math.max(s + t, i.start(0)) : Math.min(s, t)), this.trigger("firstplay"), this.tech_.setCurrentTime(e) } return this.hasPlayed_ = !0, this.load(), !0 } handleSourceOpen_() { var e; this.tryToCreateSourceBuffers_(), this.tech_.autoplay() && "undefined" != typeof (e = this.tech_.play()) && "function" == typeof e.then && e.then(null, e => { }), this.trigger("sourceopen") } handleSourceEnded_() { var e, t; this.inbandTextTracks_.metadataTrack_ && (e = this.inbandTextTracks_.metadataTrack_.cues) && e.length && (t = this.duration(), e[e.length - 1].endTime = isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t) } handleDurationChange_() { this.tech_.trigger("durationchange") } onEndOfStream() { let e = this.mainSegmentLoader_.ended_; var t; this.mediaTypes_.AUDIO.activePlaylistLoader && (t = this.mainSegmentLoader_.getCurrentMediaInfo_(), e = (t && !t.hasVideo || e) && this.audioSegmentLoader_.ended_), e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream()) } stuckAtPlaylistEnd_(e) { var t, i; return !!this.seekable().length && null !== (t = this.syncController_.getExpiredTime(e, this.duration())) && (e = Su.Playlist.playlistEnd(e, t), t = this.tech_.currentTime(), (i = this.tech_.buffered()).length ? (i = i.end(i.length - 1)) - t <= Yl && e - i <= Yl : e - t <= Yl) } excludePlaylist({ playlistToExclude: s = this.mainPlaylistLoader_.media(), error: t = {}, playlistExclusionDuration: i }) { if (s = s || this.mainPlaylistLoader_.media(), i = i || t.playlistExclusionDuration || this.playlistExclusionDuration, s) { s.playlistErrors_++; var n = this.mainPlaylistLoader_.main.playlists, r = n.filter(ud), r = 1 === r.length && r[0] === s; if (1 === n.length && i !== 1 / 0) return T.log.warn(`Problem encountered with playlist ${s.id}. ` + "Trying again since it is the only playlist."), this.tech_.trigger("retryplaylist"), this.mainPlaylistLoader_.load(r); if (r) { let i = !1; n.forEach(e => { var t; e !== s && "undefined" != typeof (t = e.excludeUntil) && t !== 1 / 0 && (i = !0, delete e.excludeUntil) }), i && (T.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist")) } let e; e = s.playlistErrors_ > this.maxPlaylistRetries ? 1 / 0 : Date.now() + 1e3 * i, s.excludeUntil = e, t.reason && (s.lastExcludeReason_ = t.reason), this.tech_.trigger("excludeplaylist"), this.tech_.trigger({ type: "usage", name: "vhs-rendition-excluded" }); var a, n = this.selectPlaylist(); if (n) return i = t.internal ? this.logger_ : T.log.warn, a = t.message ? " " + t.message : "", i(`${t.internal ? "Internal problem" : "Problem"} encountered with playlist ${s.id}.` + a + ` Switching to playlist ${n.id}.`), n.attributes.AUDIO !== s.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), n.attributes.SUBTITLES !== s.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]), i = n.targetDuration / 2 * 1e3 || 5e3, a = "number" == typeof n.lastRequest && Date.now() - n.lastRequest <= i, this.switchMedia_(n, "exclude", r || a); this.error = "Playback cannot continue. No available working or supported playlists.", this.trigger("error") } else this.error = t, "open" !== this.mediaSource.readyState ? this.trigger("error") : this.sourceUpdater_.endOfStream("network") } pauseLoading() { this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_() } delegateLoaders_(i, e) { const s = []; var t = "all" === i, n = (!t && "main" !== i || s.push(this.mainPlaylistLoader_), []); !t && "audio" !== i || n.push("AUDIO"), !t && "subtitle" !== i || (n.push("CLOSED-CAPTIONS"), n.push("SUBTITLES")), n.forEach(e => { e = this.mediaTypes_[e] && this.mediaTypes_[e].activePlaylistLoader; e && s.push(e) }), ["main", "audio", "subtitle"].forEach(e => { var t = this[e + "SegmentLoader_"]; !t || i !== e && "all" !== i || s.push(t) }), s.forEach(t => e.forEach(e => { "function" == typeof t[e] && t[e]() })) } setCurrentTime(e) { var t = ql(this.tech_.buffered(), e); return this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media() && this.mainPlaylistLoader_.media().segments ? t && t.length ? e : (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), void this.load()) : 0 } duration() { var e; return this.mainPlaylistLoader_ && (e = this.mainPlaylistLoader_.media()) ? e.endList ? this.mediaSource ? this.mediaSource.duration : Su.Playlist.duration(e) : 1 / 0 : 0 } seekable() { return this.seekable_ } onSyncInfoUpdate_() { let i; if (this.mainPlaylistLoader_) { var s = this.mainPlaylistLoader_.media(); if (s) { var n = this.syncController_.getExpiredTime(s, this.duration()); if (null !== n) { var r = this.mainPlaylistLoader_.main, a = Su.Playlist.seekable(s, n, Su.Playlist.liveEdgeDelay(r, s)); if (0 !== a.length) { if (this.mediaTypes_.AUDIO.activePlaylistLoader) { if (s = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), null === (n = this.syncController_.getExpiredTime(s, this.duration()))) return; if (0 === (i = Su.Playlist.seekable(s, n, Su.Playlist.liveEdgeDelay(r, s))).length) return } let e, t; this.seekable_ && this.seekable_.length && (e = this.seekable_.end(0), t = this.seekable_.start(0)), !i || i.start(0) > a.end(0) || a.start(0) > i.end(0) ? this.seekable_ = a : this.seekable_ = Vl([[(i.start(0) > a.start(0) ? i : a).start(0), (i.end(0) < a.end(0) ? i : a).end(0)]]), this.seekable_ && this.seekable_.length && this.seekable_.end(0) === e && this.seekable_.start(0) === t || (this.logger_(`seekable updated [${Jl(this.seekable_)}]`), this.tech_.trigger("seekablechanged")) } } } } } updateDuration(t) { if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), "open" !== this.mediaSource.readyState) this.updateDuration_ = this.updateDuration.bind(this, t), this.mediaSource.addEventListener("sourceopen", this.updateDuration_); else { if (t) return (t = this.seekable()).length ? void ((isNaN(this.mediaSource.duration) || this.mediaSource.duration < t.end(t.length - 1)) && this.sourceUpdater_.setDuration(t.end(t.length - 1))) : void 0; t = this.tech_.buffered(); let e = Su.Playlist.duration(this.mainPlaylistLoader_.media()); 0 < t.length && (e = Math.max(e, t.end(t.length - 1))), this.mediaSource.duration !== e && this.sourceUpdater_.setDuration(e) } } dispose() { this.trigger("dispose"), this.decrypter_.terminate(), this.mainPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach(e => { var t = this.mediaTypes_[e].groups; for (const i in t) t[i].forEach(e => { e.playlistLoader && e.playlistLoader.dispose() }) }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off() } main() { return this.mainPlaylistLoader_.main } media() { return this.mainPlaylistLoader_.media() || this.initialMedia_ } areMediaTypesKnown_() { var e = !!this.mediaTypes_.AUDIO.activePlaylistLoader, t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), e = !e || !!this.audioSegmentLoader_.getCurrentMediaInfo_(); return t && e } getCodecsOrExclude_() { const n = { main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {}, audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {} }, t = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media(); n.video = n.main; var e = yh(this.main(), t); const r = {}; var i = !!this.mediaTypes_.AUDIO.activePlaylistLoader; if (n.main.hasVideo && (r.video = e.video || n.main.videoCodec || "avc1.4d400d"), n.main.isMuxed && (r.video += "," + (e.audio || n.main.audioCodec || Hr)), (n.main.hasAudio && !n.main.isMuxed || n.audio.hasAudio || i) && (r.audio = e.audio || n.main.audioCodec || n.audio.audioCodec || Hr, n.audio.isFmp4 = (n.main.hasAudio && !n.main.isMuxed ? n.main : n.audio).isFmp4), r.audio || r.video) { const a = {}; let s; if (["video", "audio"].forEach(function (e) { var t, i; r.hasOwnProperty(e) && (t = n[e].isFmp4, i = r[e], !(t ? Ar : Lr)(i)) && (t = n[e].isFmp4 ? "browser" : "muxer", a[t] = a[t] || [], a[t].push(r[e]), "audio" === e && (s = t)) }), i && s && t.attributes.AUDIO) { const o = t.attributes.AUDIO; this.main().playlists.forEach(e => { (e.attributes && e.attributes.AUDIO) === o && e !== t && (e.excludeUntil = 1 / 0) }), this.logger_(`excluding audio group ${o} as ${s} does not support codec(s): "${r.audio}"`) } if (!Object.keys(a).length) { if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) { const l = []; if (["video", "audio"].forEach(e => { var t = (Fr(this.sourceUpdater_.codecs[e] || "")[0] || {}).type, i = (Fr(r[e] || "")[0] || {}).type; t && i && t.toLowerCase() !== i.toLowerCase() && l.push(`"${this.sourceUpdater_.codecs[e]}" -> "${r[e]}"`) }), l.length) return void this.excludePlaylist({ playlistToExclude: t, error: { message: `Codec switching not supported: ${l.join(", ")}.`, internal: !0 }, playlistExclusionDuration: 1 / 0 }) } return r } e = Object.keys(a).reduce((e, t) => (e && (e += ", "), e += `${t} does not support codec(s): "${a[t].join(",")}"`), "") + ".", this.excludePlaylist({ playlistToExclude: t, error: { internal: !0, message: e }, playlistExclusionDuration: 1 / 0 }) } else this.excludePlaylist({ playlistToExclude: t, error: { message: "Could not determine codecs for playlist." }, playlistExclusionDuration: 1 / 0 }) } tryToCreateSourceBuffers_() { var e; "open" !== this.mediaSource.readyState || this.sourceUpdater_.hasCreatedSourceBuffers() || this.areMediaTypesKnown_() && (e = this.getCodecsOrExclude_()) && (this.sourceUpdater_.createSourceBuffers(e), e = [e.video, e.audio].filter(Boolean).join(","), this.excludeIncompatibleVariants_(e)) } excludeUnsupportedVariants_() { const s = this.main().playlists, n = []; Object.keys(s).forEach(e => { var t, i, e = s[e]; -1 === n.indexOf(e.id) && (n.push(e.id), i = [], !(t = yh(this.main, e)).audio || Lr(t.audio) || Ar(t.audio) || i.push("audio codec " + t.audio), !t.video || Lr(t.video) || Ar(t.video) || i.push("video codec " + t.video), t.text && "stpp.ttml.im1t" === t.text && i.push("text codec " + t.text), i.length) && (e.excludeUntil = 1 / 0, this.logger_(`excluding ${e.id} for unsupported: ` + i.join(", "))) }) } excludeIncompatibleVariants_(e) { const n = [], r = this.main().playlists; e = Mh(Fr(e)); const a = fh(e), o = e.video && Fr(e.video)[0] || null, l = e.audio && Fr(e.audio)[0] || null; Object.keys(r).forEach(e => { var t, i, s, e = r[e]; -1 === n.indexOf(e.id) && e.excludeUntil !== 1 / 0 && (n.push(e.id), t = [], s = yh(this.mainPlaylistLoader_.main, e), i = fh(s), s.audio || s.video) && (i !== a && t.push(`codec count "${i}" !== "${a}"`), this.sourceUpdater_.canChangeType() || (i = s.video && Fr(s.video)[0] || null, s = s.audio && Fr(s.audio)[0] || null, i && o && i.type.toLowerCase() !== o.type.toLowerCase() && t.push(`video codec "${i.type}" !== "${o.type}"`), s && l && s.type.toLowerCase() !== l.type.toLowerCase() && t.push(`audio codec "${s.type}" !== "${l.type}"`)), t.length) && (e.excludeUntil = 1 / 0, this.logger_(`excluding ${e.id}: ` + t.join(" && "))) }) } updateAdCues_(e) { let t = 0; var s = this.seekable(), [n, r, s = 0] = (s.length && (t = s.start(0)), [e, this.cueTagsTrack_, t]); if (n.segments) { let t = s, i; for (let e = 0; e < n.segments.length; e++) { var a, o, l = n.segments[e]; if (i = i || function (e, t) { var i = e.cues; for (let e = 0; e < i.length; e++) { var s = i[e]; if (t >= s.adStartTime && t <= s.adEndTime) return s } return null }(r, t + l.duration / 2)) { if ("cueIn" in l) { i.endTime = t, i.adEndTime = t, t += l.duration, i = null; continue } if (t < i.endTime) { t += l.duration; continue } i.endTime += l.duration } else "cueOut" in l && ((i = new window.VTTCue(t, t + l.duration, l.cueOut)).adStartTime = t, i.adEndTime = t + parseFloat(l.cueOut), r.addCue(i)), "cueOutCont" in l && ([a, o] = l.cueOutCont.split("/").map(parseFloat), (i = new window.VTTCue(t, t + l.duration, "")).adStartTime = t - a, i.adEndTime = i.adStartTime + o, r.addCue(i)); t += l.duration } } } goalBufferLength() { var e = this.tech_.currentTime(), t = O.GOAL_BUFFER_LENGTH, i = O.GOAL_BUFFER_LENGTH_RATE, s = Math.max(t, O.MAX_GOAL_BUFFER_LENGTH); return Math.min(t + e * i, s) } bufferLowWaterLine() { var e = this.tech_.currentTime(), t = O.BUFFER_LOW_WATER_LINE, i = O.BUFFER_LOW_WATER_LINE_RATE, s = Math.max(t, O.MAX_BUFFER_LOW_WATER_LINE), n = Math.max(t, O.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE); return Math.min(t + e * i, this.bufferBasedABR ? n : s) } bufferHighWaterLine() { return O.BUFFER_HIGH_WATER_LINE } addMetadataToTextTrack(e, t, i) { var s, n, r = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset(); s = this.inbandTextTracks_, e = e, n = this.tech_, s.metadataTrack_ || (s.metadataTrack_ = n.addRemoteTextTrack({ kind: "metadata", label: "Timed Metadata" }, !1).track, s.metadataTrack_.inBandMetadataTrackDispatchType = e), Hh({ inbandTextTracks: this.inbandTextTracks_, metadataArray: t, timestampOffset: r, videoDuration: i }) } } class Cu { constructor(e, t, i) { var s, n, r, a, o = e["playlistController_"], l = o.fastQualityChange_.bind(o); t.attributes && (s = t.attributes.RESOLUTION, this.width = s && s.width, this.height = s && s.height, this.bandwidth = t.attributes.BANDWIDTH, this.frameRate = t.attributes["FRAME-RATE"]), this.codecs = yh(o.main(), t), this.playlist = t, this.id = i, this.enabled = (n = e.playlists, r = t.id, a = l, e => { var t = n.main.playlists[r], i = hd(t), s = ud(t); return "undefined" == typeof e ? s : (e ? delete t.disabled : t.disabled = !0, e === s || i || (a(), e ? n.trigger("renditionenabled") : n.trigger("renditiondisabled")), e) }) } } const ku = ["seeking", "seeked", "pause", "playing", "error"]; class Iu { constructor(e) { this.playlistController_ = e.playlistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = Hl("PlaybackWatcher"), this.logger_("initialize"); const t = () => this.monitorCurrentTime_(), i = () => this.monitorCurrentTime_(), s = () => this.techWaiting_(), n = () => this.resetTimeUpdate_(), r = this.playlistController_, a = ["main", "subtitle", "audio"], o = {}, l = (a.forEach(e => { o[e] = { reset: () => this.resetSegmentDownloads_(e), updateend: () => this.checkSegmentDownloads_(e) }, r[e + "SegmentLoader_"].on("appendsdone", o[e].updateend), r[e + "SegmentLoader_"].on("playlistupdate", o[e].reset), this.tech_.on(["seeked", "seeking"], o[e].reset) }), t => { ["main", "audio"].forEach(e => { r[e + "SegmentLoader_"][t]("appended", this.seekingAppendCheck_) }) }); this.seekingAppendCheck_ = () => { this.fixesBadSeeks_() && (this.consecutiveUpdates = 0, this.lastRecordedTime = this.tech_.currentTime(), l("off")) }, this.clearSeekingAppendCheck_ = () => l("off"), this.watchForBadSeeking_ = () => { this.clearSeekingAppendCheck_(), l("on") }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", s), this.tech_.on(ku, n), this.tech_.on("canplay", i), this.tech_.one("play", t), this.dispose = () => { this.clearSeekingAppendCheck_(), this.logger_("dispose"), this.tech_.off("waiting", s), this.tech_.off(ku, n), this.tech_.off("canplay", i), this.tech_.off("play", t), this.tech_.off("seeking", this.watchForBadSeeking_), this.tech_.off("seeked", this.clearSeekingAppendCheck_), a.forEach(e => { r[e + "SegmentLoader_"].off("appendsdone", o[e].updateend), r[e + "SegmentLoader_"].off("playlistupdate", o[e].reset), this.tech_.off(["seeked", "seeking"], o[e].reset) }), this.checkCurrentTimeTimeout_ && window.clearTimeout(this.checkCurrentTimeTimeout_), this.resetTimeUpdate_() } } monitorCurrentTime_() { this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && window.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250) } resetSegmentDownloads_(e) { var t = this.playlistController_[e + "SegmentLoader_"]; 0 < this[e + "StalledDownloads_"] && this.logger_(`resetting possible stalled download count for ${e} loader`), this[e + "StalledDownloads_"] = 0, this[e + "Buffered_"] = t.buffered_() } checkSegmentDownloads_(e) { var t = this.playlistController_, i = t[e + "SegmentLoader_"], s = i.buffered_(), n = function (t, i) { if (t !== i) { if (!t && i || !i && t) return !0; if (t.length !== i.length) return !0; for (let e = 0; e < t.length; e++)if (t.start(e) !== i.start(e) || t.end(e) !== i.end(e)) return !0 } return !1 }(this[e + "Buffered_"], s); this[e + "Buffered_"] = s, n ? this.resetSegmentDownloads_(e) : (this[e + "StalledDownloads_"]++, this.logger_(`found #${this[e + "StalledDownloads_"]} ${e} appends that did not increase buffer (possible stalled download)`, { playlistId: i.playlist_ && i.playlist_.id, buffered: Zl(s) }), this[e + "StalledDownloads_"] < 10 || (this.logger_(e + " loader stalled download exclusion"), this.resetSegmentDownloads_(e), this.tech_.trigger({ type: "usage", name: `vhs-${e}-download-exclusion` }), "subtitle" !== e && t.excludePlaylist({ error: { message: `Excessive ${e} segment downloading detected.` }, playlistExclusionDuration: 1 / 0 }))) } checkCurrentTime_() { var e, t; if (!this.tech_.paused() && !this.tech_.seeking()) return e = this.tech_.currentTime(), t = this.tech_.buffered(), this.lastRecordedTime === e && (!t.length || e + Yl >= t.end(t.length - 1)) ? this.techWaiting_() : void (5 <= this.consecutiveUpdates && e === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : e === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = e)) } resetTimeUpdate_() { this.consecutiveUpdates = 0 } fixesBadSeeks_() { if (!this.tech_.seeking()) return !1; var e = this.seekable(), t = this.tech_.currentTime(); let i; if (this.afterSeekableWindow_(e, t, this.media(), this.allowSeeksWithinUnsafeLiveWindow) && (s = e.end(e.length - 1), i = s), this.beforeSeekableWindow_(e, t) && (s = e.start(0), i = s + (s === e.end(0) ? 0 : Yl)), "undefined" != typeof i) this.logger_(`Trying to seek outside of seekable at time ${t} with ` + `seekable range ${Jl(e)}. Seeking to ` + i + "."); else { var s = this.playlistController_.sourceUpdater_, e = this.tech_.buffered(), n = s.audioBuffer ? s.audioBuffered() : null, s = s.videoBuffer ? s.videoBuffered() : null, r = this.media(), a = r.partTargetDuration || 2 * (r.targetDuration - Kl), o = [n, s]; for (let e = 0; e < o.length; e++)if (o[e]) if (Wl(o[e], t) < a) return !1; if (0 === (r = zl(e, t)).length) return !1; i = r.start(0) + Yl, this.logger_(`Buffered region starts (${r.start(0)}) ` + ` just beyond seek point (${t}). Seeking to ${i}.`) } return this.tech_.setCurrentTime(i), !0 } waiting_() { var e, t; this.techWaiting_() || (e = this.tech_.currentTime(), t = this.tech_.buffered(), (t = ql(t, e)).length && e + 3 <= t.end(0) && (this.resetTimeUpdate_(), this.tech_.setCurrentTime(e), this.logger_(`Stopped at ${e} while inside a buffered region ` + `[${t.start(0)} -> ${t.end(0)}]. Attempting to resume ` + "playback by seeking to the current time."), this.tech_.trigger({ type: "usage", name: "vhs-unknown-waiting" }))) } techWaiting_() { var e, t = this.seekable(), i = this.tech_.currentTime(); return !!this.tech_.seeking() || (this.beforeSeekableWindow_(t, i) ? (t = t.end(t.length - 1), this.logger_(`Fell out of live window at time ${i}. Seeking to ` + "live point (seekable end) " + t), this.resetTimeUpdate_(), this.tech_.setCurrentTime(t), this.tech_.trigger({ type: "usage", name: "vhs-live-resync" }), !0) : (t = this.tech_.vhs.playlistController_.sourceUpdater_, e = this.tech_.buffered(), this.videoUnderflow_({ audioBuffered: t.audioBuffered(), videoBuffered: t.videoBuffered(), currentTime: i }) ? (this.resetTimeUpdate_(), this.tech_.setCurrentTime(i), this.tech_.trigger({ type: "usage", name: "vhs-video-underflow" }), !0) : 0 < (t = zl(e, i)).length && (this.logger_(`Stopped at ${i} and seeking to ` + t.start(0)), this.resetTimeUpdate_(), this.skipTheGap_(i), !0))) } afterSeekableWindow_(e, t, i, s = !1) { if (!e.length) return !1; let n = e.end(e.length - 1) + Yl; var r = !i.endList; return t > (n = r && s ? e.end(e.length - 1) + 3 * i.targetDuration : n) } beforeSeekableWindow_(e, t) { return !!(e.length && 0 < e.start(0) && t < e.start(0) - this.liveRangeSafeTimeDelta) } videoUnderflow_({ videoBuffered: t, audioBuffered: i, currentTime: s }) { if (t) { let e; var n, r; return t.length && i.length ? (n = ql(t, s - 3), r = ql(t, s), (i = ql(i, s)).length && !r.length && n.length && (e = { start: n.end(0), end: i.end(0) })) : zl(t, s).length || (e = this.gapFromVideoUnderflow_(t, s)), !!e && (this.logger_(`Encountered a gap in video from ${e.start} to ${e.end}. ` + "Seeking to current time " + s), !0) } } skipTheGap_(e) { var t = this.tech_.buffered(), i = this.tech_.currentTime(), t = zl(t, i); this.resetTimeUpdate_(), 0 !== t.length && i === e && (this.logger_("skipTheGap_:", "currentTime:", i, "scheduled currentTime:", e, "nextRange start:", t.start(0)), this.tech_.setCurrentTime(t.start(0) + Kl), this.tech_.trigger({ type: "usage", name: "vhs-gap-skip" })) } gapFromVideoUnderflow_(e, t) { var i = function (t) { if (t.length < 2) return Vl(); var i = []; for (let e = 1; e < t.length; e++) { var s = t.end(e - 1), n = t.start(e); i.push([s, n]) } return Vl(i) }(e); for (let e = 0; e < i.length; e++) { var s = i.start(e), n = i.end(e); if (t - s < 4 && 2 < t - s) return { start: s, end: n } } return null } } const xu = { errorInterval: 30, getSource(e) { return e(this.tech({ IWillNotUseThisInPlugins: !0 }).currentSource_ || this.currentSource()) } }, Au = function (t, e) { let i = 0, s = 0; function n(e) { null != e && (s = t.duration() !== 1 / 0 && t.currentTime() || 0, t.one("loadedmetadata", l), t.src(e), t.trigger({ type: "usage", name: "vhs-error-reload" }), t.play()) } function r() { if (Date.now() - i < 1e3 * o.errorInterval) t.trigger({ type: "usage", name: "vhs-error-reload-canceled" }); else { if (o.getSource && "function" == typeof o.getSource) return i = Date.now(), o.getSource.call(t, n); T.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!") } } function a() { t.off("loadedmetadata", l), t.off("error", r), t.off("dispose", a) } const o = D(xu, e), l = (t.ready(() => { t.trigger({ type: "usage", name: "vhs-error-reload-initialized" }) }), function () { s && t.currentTime(s) }); t.on("error", r), t.on("dispose", a), t.reloadSourceOnError = function (e) { a(), Au(t, e) } }; function Lu(t, e) { var i = e.media(); let s = -1; for (let e = 0; e < t.length; e++)if (t[e].id === i.id) { s = e; break } t.selectedIndex_ = s, t.trigger({ selectedIndex: s, type: "change" }) } const M = { PlaylistLoader: Ad, Playlist: yd, utils: Nn, STANDARD_PLAYLIST_SELECTOR: Fh, INITIAL_PLAYLIST_SELECTOR: function () { var e = this.playlists.main.playlists.filter(yd.isEnabled), e = (Uh(e, (e, t) => vh(e, t)), e.filter(e => !!yh(this.playlists.main, e).video)); return e[0] || null }, lastBandwidthSelector: Fh, movingAverageBandwidthSelector: function (t) { let i = -1, s = -1; if (t < 0 || 1 < t) throw new Error("Moving average bandwidth decay must be between 0 and 1."); return function () { var e = this.useDevicePixelRatio && window.devicePixelRatio || 1; return i < 0 && (i = this.systemBandwidth, s = this.systemBandwidth), 0 < this.systemBandwidth && this.systemBandwidth !== s && (i = t * this.systemBandwidth + (1 - t) * i, s = this.systemBandwidth), Bh(this.playlists.main, i, parseInt(_h(this.tech_.el(), "width"), 10) * e, parseInt(_h(this.tech_.el(), "height"), 10) * e, this.limitRenditionByPlayerDimensions, this.playlistController_) } }, comparePlaylistBandwidth: vh, comparePlaylistResolution: function (e, t) { let i, s; return i = (i = e.attributes.RESOLUTION && e.attributes.RESOLUTION.width ? e.attributes.RESOLUTION.width : i) || window.Number.MAX_VALUE, s = (s = t.attributes.RESOLUTION && t.attributes.RESOLUTION.width ? t.attributes.RESOLUTION.width : s) || window.Number.MAX_VALUE, i === s && e.attributes.BANDWIDTH && t.attributes.BANDWIDTH ? e.attributes.BANDWIDTH - t.attributes.BANDWIDTH : i - s }, xhr: Pd() }, Pu = (Object.keys(O).forEach(t => { Object.defineProperty(M, t, { get() { return T.log.warn(`using Vhs.${t} is UNSAFE be sure you know what you are doing`), O[t] }, set(e) { T.log.warn(`using Vhs.${t} is UNSAFE be sure you know what you are doing`), "number" != typeof e || e < 0 ? T.log.warn(`value of Vhs.${t} must be greater than or equal to 0`) : O[t] = e } }) }), "tm_videojs-vhs"), Du = (M.canPlaySource = function () { return T.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.") }, ({ player: s, sourceKeySystems: e, audioMedia: t, mainPlaylists: i }) => { if (!s.eme.initializeMediaKeys) return Promise.resolve(); var n, t = t ? i.concat([t]) : i, t = (i = t, n = Object.keys(e), i.reduce((e, s) => { var t; return s.contentProtection && (t = n.reduce((e, t) => { var i = s.contentProtection[t]; return i && i.pssh && (e[t] = { pssh: i.pssh }), e }, {}), Object.keys(t).length) && e.push(t), e }, [])); const r = [], a = []; return t.forEach(e => { a.push(new Promise((e, t) => { s.tech_.one("keysessioncreated", e) })), r.push(new Promise((t, i) => { s.eme.initializeMediaKeys({ keySystems: e }, e => { e ? i(e) : t() }) })) }), Promise.race([Promise.all(r), Promise.race(a)]) }), Ou = ({ player: e, sourceKeySystems: t, media: i, audioMedia: s }) => { t = ((e, t, i) => { if (!e) return e; let s = {}; t && t.attributes && t.attributes.CODECS && (s = Mh(Fr(t.attributes.CODECS))), i && i.attributes && i.attributes.CODECS && (s.audio = i.attributes.CODECS); var n = jr(s.video), r = jr(s.audio), a = {}; for (const o in e) a[o] = {}, r && (a[o].audioContentType = r), n && (a[o].videoContentType = n), t.contentProtection && t.contentProtection[o] && t.contentProtection[o].pssh && (a[o].pssh = t.contentProtection[o].pssh), "string" == typeof e[o] && (a[o].url = e[o]); return D(e, a) })(t, i, s); return !(!t || (e.currentSource().keySystems = t) && !e.eme && (T.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), 1)) }, Mu = () => { if (!window.localStorage) return null; var e = window.localStorage.getItem(Pu); if (!e) return null; try { return JSON.parse(e) } catch (e) { return null } }, Nu = (e, t) => { e._requestCallbackSet || (e._requestCallbackSet = new Set), e._requestCallbackSet.add(t) }, Ru = (e, t) => { e._responseCallbackSet || (e._responseCallbackSet = new Set), e._responseCallbackSet.add(t) }, Uu = (e, t) => { e._requestCallbackSet && (e._requestCallbackSet.delete(t), e._requestCallbackSet.size || delete e._requestCallbackSet) }, Bu = (e, t) => { e._responseCallbackSet && (e._responseCallbackSet.delete(t), e._responseCallbackSet.size || delete e._responseCallbackSet) }; M.supportsNativeHls = function () { if (!document || !document.createElement) return !1; const t = document.createElement("video"); return !!T.getTech("Html5").isSupported() && ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some(function (e) { return /maybe|probably/i.test(t.canPlayType(e)) }) }(), M.supportsNativeDash = !!(document && document.createElement && T.getTech("Html5").isSupported()) && /maybe|probably/i.test(document.createElement("video").canPlayType("application/dash+xml")), M.supportsTypeNatively = e => "hls" === e ? M.supportsNativeHls : "dash" === e && M.supportsNativeDash, M.isSupported = function () { return T.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.") }, M.xhr.onRequest = function (e) { Nu(M.xhr, e) }, M.xhr.onResponse = function (e) { Ru(M.xhr, e) }, M.xhr.offRequest = function (e) { Uu(M.xhr, e) }, M.xhr.offResponse = function (e) { Bu(M.xhr, e) }; class Fu extends T.getComponent("Component") { constructor(e, t, i) { if (super(t, i.vhs), "number" == typeof i.initialBandwidth && (this.options_.bandwidth = i.initialBandwidth), this.logger_ = Hl("VhsHandler"), t.options_ && t.options_.playerId && (i = T.getPlayer(t.options_.playerId), this.player_ = i), this.tech_ = t, this.source_ = e, this.stats = {}, this.ignoreNextSeekingEvent_ = !1, this.setOptions_(), this.options_.overrideNative && t.overrideNativeAudioTracks && t.overrideNativeVideoTracks) t.overrideNativeAudioTracks(!0), t.overrideNativeVideoTracks(!0); else if (this.options_.overrideNative && (t.featuresNativeVideoTracks || t.featuresNativeAudioTracks)) throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB"); this.on(document, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], e => { var t = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; t && t.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_() }), this.on(this.tech_, "seeking", function () { this.ignoreNextSeekingEvent_ ? this.ignoreNextSeekingEvent_ = !1 : this.setCurrentTime(this.tech_.currentTime()) }), this.on(this.tech_, "error", function () { this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading() }), this.on(this.tech_, "play", this.play) } setOptions_() { var e; this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.useBandwidthFromLocalStorage = "undefined" != typeof this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, this.options_.llhls = !1 !== this.options_.llhls, this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1, "number" != typeof this.options_.playlistExclusionDuration && (this.options_.playlistExclusionDuration = 300), "number" != typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage && ((e = Mu()) && e.bandwidth && (this.options_.bandwidth = e.bandwidth, this.tech_.trigger({ type: "usage", name: "vhs-bandwidth-from-local-storage" })), e) && e.throughput && (this.options_.throughput = e.throughput, this.tech_.trigger({ type: "usage", name: "vhs-throughput-from-local-storage" })), "number" != typeof this.options_.bandwidth && (this.options_.bandwidth = O.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === O.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach(e => { "undefined" != typeof this.source_[e] && (this.options_[e] = this.source_[e]) }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio } src(e, t) { e && (this.setOptions_(), this.options_.src = 0 === (e = this.source_.src).toLowerCase().indexOf("data:application/vnd.tm_videojs.vhs+json,") ? JSON.parse(e.substring(e.indexOf(",") + 1)) : e, this.options_.tech = this.tech_, this.options_.externVhs = M, this.options_.sourceType = Pr(t), this.options_.seekTo = e => { this.tech_.setCurrentTime(e) }, this.playlistController_ = new Eu(this.options_), e = D({ liveRangeSafeTimeDelta: Yl }, this.options_, { seekable: () => this.seekable(), media: () => this.playlistController_.media(), playlistController: this.playlistController_ }), this.playbackWatcher_ = new Iu(e), this.playlistController_.on("error", () => { var e = T.players[this.tech_.options_.playerId]; let t = this.playlistController_.error; "object" != typeof t || t.code ? "string" == typeof t && (t = { message: t, code: 3 }) : t.code = 3, e.error(t) }), t = this.options_.bufferBasedABR ? M.movingAverageBandwidthSelector(.55) : M.STANDARD_PLAYLIST_SELECTOR, this.playlistController_.selectPlaylist = (this.selectPlaylist || t).bind(this), this.playlistController_.selectInitialPlaylist = M.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.playlistController_.mainPlaylistLoader_, this.mediaSource = this.playlistController_.mediaSource, Object.defineProperties(this, { selectPlaylist: { get() { return this.playlistController_.selectPlaylist }, set(e) { this.playlistController_.selectPlaylist = e.bind(this) } }, throughput: { get() { return this.playlistController_.mainSegmentLoader_.throughput.rate }, set(e) { this.playlistController_.mainSegmentLoader_.throughput.rate = e, this.playlistController_.mainSegmentLoader_.throughput.count = 1 } }, bandwidth: { get() { let e = this.playlistController_.mainSegmentLoader_.bandwidth; var t = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection; return this.options_.useNetworkInformationApi && t && (t = 1e3 * t.downlink * 1e3, e = 1e7 <= t && 1e7 <= e ? Math.max(e, t) : t), e }, set(e) { this.playlistController_.mainSegmentLoader_.bandwidth = e, this.playlistController_.mainSegmentLoader_.throughput = { rate: 0, count: 0 } } }, systemBandwidth: { get() { var e = 1 / (this.bandwidth || 1); let t; return t = 0 < this.throughput ? 1 / this.throughput : 0, Math.floor(1 / (e + t)) }, set() { T.log.error('The "systemBandwidth" property is read-only') } } }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, { bandwidth: { get: () => this.bandwidth || 0, enumerable: !0 }, mediaRequests: { get: () => this.playlistController_.mediaRequests_() || 0, enumerable: !0 }, mediaRequestsAborted: { get: () => this.playlistController_.mediaRequestsAborted_() || 0, enumerable: !0 }, mediaRequestsTimedout: { get: () => this.playlistController_.mediaRequestsTimedout_() || 0, enumerable: !0 }, mediaRequestsErrored: { get: () => this.playlistController_.mediaRequestsErrored_() || 0, enumerable: !0 }, mediaTransferDuration: { get: () => this.playlistController_.mediaTransferDuration_() || 0, enumerable: !0 }, mediaBytesTransferred: { get: () => this.playlistController_.mediaBytesTransferred_() || 0, enumerable: !0 }, mediaSecondsLoaded: { get: () => this.playlistController_.mediaSecondsLoaded_() || 0, enumerable: !0 }, mediaAppends: { get: () => this.playlistController_.mediaAppends_() || 0, enumerable: !0 }, mainAppendsToLoadedData: { get: () => this.playlistController_.mainAppendsToLoadedData_() || 0, enumerable: !0 }, audioAppendsToLoadedData: { get: () => this.playlistController_.audioAppendsToLoadedData_() || 0, enumerable: !0 }, appendsToLoadedData: { get: () => this.playlistController_.appendsToLoadedData_() || 0, enumerable: !0 }, timeToLoadedData: { get: () => this.playlistController_.timeToLoadedData_() || 0, enumerable: !0 }, buffered: { get: () => Zl(this.tech_.buffered()), enumerable: !0 }, currentTime: { get: () => this.tech_.currentTime(), enumerable: !0 }, currentSource: { get: () => this.tech_.currentSource_, enumerable: !0 }, currentTech: { get: () => this.tech_.name_, enumerable: !0 }, duration: { get: () => this.tech_.duration(), enumerable: !0 }, main: { get: () => this.playlists.main, enumerable: !0 }, playerDimensions: { get: () => this.tech_.currentDimensions(), enumerable: !0 }, seekable: { get: () => Zl(this.tech_.seekable()), enumerable: !0 }, timestamp: { get: () => Date.now(), enumerable: !0 }, videoPlaybackQuality: { get: () => this.tech_.getVideoPlaybackQuality(), enumerable: !0 } }), this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)), this.tech_.on("bandwidthupdate", () => { if (this.options_.useBandwidthFromLocalStorage) { var e = { bandwidth: this.bandwidth, throughput: Math.round(this.throughput) }; if (window.localStorage) { var t = (t = Mu()) ? D(t, e) : e; try { window.localStorage.setItem(Pu, JSON.stringify(t)) } catch (e) { return } } } }), this.playlistController_.on("selectedinitialmedia", () => { var i; (i = this).representations = () => { var e = i.playlistController_.main(), e = fd(e) ? i.playlistController_.getAudioTrackPlaylists_() : e.playlists; return e ? e.filter(e => !hd(e)).map((e, t) => new Cu(i, e, e.id)) : [] } }), this.playlistController_.sourceUpdater_.on("createdsourcebuffers", () => { this.setupEme_() }), this.on(this.playlistController_, "progress", function () { this.tech_.trigger("progress") }), this.on(this.playlistController_, "firstplay", function () { this.ignoreNextSeekingEvent_ = !0 }), this.setupQualityLevels_(), this.tech_.el()) && (this.mediaSourceUrl_ = window.URL.createObjectURL(this.playlistController_.mediaSource), this.tech_.src(this.mediaSourceUrl_)) } createKeySessions_() { var e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader; this.logger_("waiting for EME key session creation"), Du({ player: this.player_, sourceKeySystems: this.source_.keySystems, audioMedia: e && e.media(), mainPlaylists: this.playlists.main.playlists }).then(() => { this.logger_("created EME key session"), this.playlistController_.sourceUpdater_.initializedEme() }).catch(e => { this.logger_("error while creating EME key session", e), this.player_.error({ message: "Failed to initialize media keys for EME", code: 3 }) }) } handleWaitingForKey_() { this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_() } setupEme_() { var e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader, e = Ou({ player: this.player_, sourceKeySystems: this.source_.keySystems, media: this.playlists.media(), audioMedia: e && e.media() }); this.player_.tech_.on("keystatuschange", e => { if ("output-restricted" === e.status) { e = this.playlistController_.main(); if (e && e.playlists) { const t = []; e.playlists.forEach(e => { e && e.attributes && e.attributes.RESOLUTION && 720 <= e.attributes.RESOLUTION.height && (!e.excludeUntil || e.excludeUntil < 1 / 0) && (e.excludeUntil = 1 / 0, t.push(e)) }), t.length && (T.log.warn('DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.', ...t), this.playlistController_.fastQualityChange_()) } } }), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), e ? this.createKeySessions_() : this.playlistController_.sourceUpdater_.initializedEme() } setupQualityLevels_() { var e = T.players[this.tech_.options_.playerId]; e && e.qualityLevels && !this.qualityLevels_ && (this.qualityLevels_ = e.qualityLevels(), this.playlistController_.on("selectedinitialmedia", () => { var t, e; t = this.qualityLevels_, (e = this).representations().forEach(e => { t.addQualityLevel(e) }), Lu(t, e.playlists) }), this.playlists.on("mediachange", () => { Lu(this.qualityLevels_, this.playlists) })) } static version() { return { "@tm_videojs/http-streaming": "3.3.1", "mux.js": "6.3.0", "mpd-parser": "1.1.1", "m3u8-parser": "6.0.0", "aes-decrypter": "4.0.1" } } version() { return this.constructor.version() } canChangeType() { return ru.canChangeType() } play() { this.playlistController_.play() } setCurrentTime(e) { this.playlistController_.setCurrentTime(e) } duration() { return this.playlistController_.duration() } seekable() { return this.playlistController_.seekable() } dispose() { this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.playlistController_ && this.playlistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.mediaSourceUrl_ && window.URL.revokeObjectURL && (window.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), super.dispose() } convertToProgramTime(e, t) { return Vd({ playlist: this.playlistController_.media(), time: e, callback: t }) } seekToProgramTime(e, t, i = !0, s = 2) { return qd({ programTime: e, playlist: this.playlistController_.media(), retryCount: s, pauseAfterSeek: i, seekTo: this.options_.seekTo, tech: this.options_.tech, callback: t }) } setupXhrHooks_() { this.xhr.onRequest = e => { Nu(this.xhr, e) }, this.xhr.onResponse = e => { Ru(this.xhr, e) }, this.xhr.offRequest = e => { Uu(this.xhr, e) }, this.xhr.offResponse = e => { Bu(this.xhr, e) }, this.player_.trigger("xhr-hooks-ready") } } const ju = { name: "tm_videojs-http-streaming", VERSION: "3.3.1", canHandleSource(e, t = {}) { t = D(T.options, t); return ju.canPlayType(e.type, t) }, handleSource(e, t, i = {}) { i = D(T.options, i); return t.vhs = new Fu(e, t, i), t.vhs.xhr = Pd(), t.vhs.setupXhrHooks_(), t.vhs.src(e.src, e.type), t.vhs }, canPlayType(e, t) { e = Pr(e); return e && (t = ju.getOverrideNative(t), !M.supportsTypeNatively(e) || t) ? "maybe" : "" }, getOverrideNative(e = {}) { var { vhs: e = {} } = e, t = !(T.browser.IS_ANY_SAFARI || T.browser.IS_IOS), { overrideNative: e = t } = e; return e } }; return Ar("avc1.4d400d,mp4a.40.2") && T.getTech("Html5").registerSourceHandler(ju, 0), T.VhsHandler = Fu, T.VhsSourceHandler = ju, T.Vhs = M, T.use || T.registerComponent("Vhs", M), T.options.vhs = T.options.vhs || {}, T.getPlugin && T.getPlugin("reloadSourceOnError") || T.registerPlugin("reloadSourceOnError", function (e) { Au(this, e) }), T
});

/*! @name tm_videojs-contrib-ads @version 7.5.2 @license Apache-2.0 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require("video.js"), require("global/window"), require("global/document")) : "function" == typeof define && define.amd ? define(["video.js", "global/window", "global/document"], t) : (e = e || self).tm_videojsContribAds = t(e.tm_videojs, e.window, e.document) }(this, function (e, t, n) { "use strict"; e = e && e.hasOwnProperty("default") ? e.default : e, t = t && t.hasOwnProperty("default") ? t.default : t, n = n && n.hasOwnProperty("default") ? n.default : n; var a = "7.5.2"; var r = function (e, t) { t.isImmediatePropagationStopped = function () { return !0 }, t.cancelBubble = !0, t.isPropagationStopped = function () { return !0 } }, o = function (e, t, n) { r(0, n), e.trigger({ type: t + n.type, originalEvent: n }) }, i = function (e, t) { e.ads.isInAdMode() && (e.ads.isContentResuming() ? e.ads._contentEnding && o(e, "content", t) : o(e, "ad", t)) }, s = function (e, t) { e.ads.isInAdMode() ? e.ads.isContentResuming() ? (r(0, t), e.trigger("resumeended")) : o(e, "ad", t) : e.ads._contentHasEnded || e.ads.stitchedAds() || (o(e, "content", t), e.trigger("readyforpostroll")) }, A = function (e, t) { if (!("loadstart" === t.type && !e.ads._hasThereBeenALoadStartDuringPlayerLife || "loadeddata" === t.type && !e.ads._hasThereBeenALoadedData || "loadedmetadata" === t.type && !e.ads._hasThereBeenALoadedMetaData)) if (e.ads.inAdBreak()) o(e, "ad", t); else { if (e.currentSrc() !== e.ads.contentSrc) return; o(e, "content", t) } }, d = function (e, t) { e.ads.inAdBreak() ? o(e, "ad", t) : e.ads.isContentResuming() && o(e, "content", t) }; function l(e) { "playing" === e.type ? i(this, e) : "ended" === e.type ? s(this, e) : "loadstart" === e.type || "loadeddata" === e.type || "loadedmetadata" === e.type ? A(this, e) : "play" === e.type ? d(this, e) : this.ads.isInAdMode() && (this.ads.isContentResuming() ? o(this, "content", e) : o(this, "ad", e)) } function u() { return (u = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]) } return e }).apply(this, arguments) } function c(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, p(e, t) } function p(e, t) { return (p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e })(e, t) } var f = {}, h = function () { !function (n) { if (e.dom.isInFrame() && "function" != typeof t.__tcfapi) { for (var a, r = t, o = {}; r;) { try { if (r.frames.__tcfapiLocator) { a = r; break } } catch (e) { } if (r === t.top) break; r = r.parent } if (!a) return; t.__tcfapi = function (e, t, n, r) { var i = Math.random() + "", s = { __tcfapiCall: { command: e, parameter: r, version: t, callId: i } }; o[i] = n, a.postMessage(s, "*") }, t.addEventListener("message", function (e) { var t = {}; try { t = "string" == typeof e.data ? JSON.parse(e.data) : e.data } catch (e) { } var n = t.__tcfapiReturn; n && "function" == typeof o[n.callId] && (o[n.callId](n.returnValue, n.success), o[n.callId] = null) }, !1) } }(), "function" == typeof t.__tcfapi && t.__tcfapi("addEventListener", 2, function (e, t) { t && (f = e) }) }, g = "", y = function (e, n) { if (void 0 === n && (n = t), n.__uspapi) n.__uspapi("getUSPData", 1, function (t, n) { var a = n ? t.uspString : null; g = a, e(a) }); else { var a = function (e) { for (var t = e.parent; t !== e.top;) { try { if (t.frames && t.frames.__uspapiLocator) return t } catch (e) { } t = t.parent } try { if (e.top.frames && e.top.frames.__uspapiLocator) return e.top } catch (e) { } return null }(n); if (!a) return void e(null); var r = Math.random().toString(36).substring(2), o = { __uspapiCall: { command: "getUSPData", version: 1, callId: r } }; n.addEventListener("message", function t(a) { if (a && a.data && a.data.__uspapiReturn && a.data.__uspapiReturn.callId === r) { n.removeEventListener("message", t, !1); var o = a.data.__uspapiReturn, i = o.returnValue, s = o.success ? i.uspString : null; g = s, e(s) } }, !1), a.postMessage(o, "*") } }, m = { AdsBeforePrerollError: "ads-before-preroll-error", AdsPrerollError: "ads-preroll-error", AdsMidrollError: "ads-midroll-error", AdsPostrollError: "ads-postroll-error", AdsMacroReplacementFailed: "ads-macro-replacement-failed", AdsResumeContentFailed: "ads-resume-content-failed" }, v = function (e, t) { return t ? encodeURIComponent(e) : e }, b = function (e, t) { var n = {}; return ["description", "tags", "reference_id", "ad_keys"].forEach(function (a) { e && e[a] ? n["{mediainfo." + a + "}"] = e[a] : t["{mediainfo." + a + "}"] ? n["{mediainfo." + a + "}"] = t["{mediainfo." + a + "}"] : n["{mediainfo." + a + "}"] = "" }), ["custom_fields", "customFields"].forEach(function (t) { !function (e, t, n) { if (e && e[n]) for (var a = e[n], r = Object.keys(a), o = 0; o < r.length; o++)t["{mediainfo." + n + "." + r[o] + "}"] = a[r[o]] }(e, n, t) }), n }, S = function (e) { var t = {}, n = e.replace(/{([^}=]+)=([^}]*)}/g, function (e, n, a) { return t["{" + n + "}"] = a, "{" + n + "}" }); return { defaults: t, modifiedString: n } }, P = function (a) { return { "{player.id}": a.options_["data-player"] || a.id_, "{player.height}": a.currentHeight(), "{player.width}": a.currentWidth(), "{player.heightInt}": Math.round(a.currentHeight()), "{player.widthInt}": Math.round(a.currentWidth()), "{player.autoplay}": a.autoplay() ? 1 : 0, "{player.muted}": a.muted() ? 1 : 0, "{player.language}": a.language() || "", "{mediainfo.id}": a.mediainfo ? a.mediainfo.id : "", "{mediainfo.name}": a.mediainfo ? a.mediainfo.name : "", "{mediainfo.duration}": a.mediainfo ? a.mediainfo.duration : "", "{player.duration}": a.duration(), "{player.durationInt}": Math.round(a.duration()), "{player.live}": a.duration() === 1 / 0 ? 1 : 0, "{player.pageUrl}": e.dom.isInFrame() ? n.referrer : t.location.href, "{playlistinfo.id}": a.playlistinfo ? a.playlistinfo.id : "", "{playlistinfo.name}": a.playlistinfo ? a.playlistinfo.name : "", "{timestamp}": (new Date).getTime(), "{document.referrer}": n.referrer, "{window.location.href}": t.location.href, "{random}": Math.floor(1e12 * Math.random()) } }, k = function (e) { var t = {}; return Object.keys(e).forEach(function (n) { t["{tcf." + n + "}"] = e[n] }), t["{tcf.gdprAppliesInt}"] = e.gdprApplies ? 1 : 0, t }, B = function () { return { "{usp.uspString}": g } }, _ = function (n, a, r) { var o = new RegExp("{pageVariable\\.([^}]+)}", "g"), i = {}, s = (n.match(o) || []).concat(Object.keys(r).filter(function (e) { return o.test(e) && n.includes(r[e]) })); if (s) return s.forEach(function (n) { for (var r, o = n, s = n.slice(14, -1), A = s.split("."), d = t, l = 0; l < A.length; l++)if (l === A.length - 1) r = d[A[l]]; else if (void 0 === (d = d[A[l]])) break; var u = typeof r; null === r ? i[o] = "null" : void 0 === r ? a[o] ? i[o] = a[o] : (e.log.warn('Page variable "' + s + '" not found'), i[o] = "") : "string" !== u && "number" !== u && "boolean" !== u ? (e.log.warn('Page variable "' + s + '" is not a supported type'), i[o] = "") : i[o] = r }), i }, C = function (t, n, a, r, o) { for (var i in void 0 === r && (r = {}), n) { var s = r.hasOwnProperty(i) ? r[i] : i; if (s.startsWith("r:")) try { var A = new RegExp(s.slice(2), "g"); t = t.replace(A, v(n[i], a)) } catch (t) { o.ads.error({ errorType: m.AdsMacroReplacementFailed, macro: i, error: t }), e.log.warn('Unable to replace macro with regex "' + s + '". The provided regex may be invalid.') } else t = t.split(s).join(v(n[i], a)) } return t }; var R = { processMetadataTracks: function (e, t) { for (var n = e.textTracks(), a = function (n) { "metadata" === n.kind && (e.ads.cueTextTracks.setMetadataTrackMode(n), t(e, n)) }, r = 0; r < n.length; r++)a(n[r]); n.addEventListener("addtrack", function (e) { a(e.track) }) }, setMetadataTrackMode: function (e) { }, getSupportedAdCue: function (e, t) { return t }, isSupportedAdCue: function (e, t) { return !0 }, getCueId: function (e, t) { return t.id } }, T = function (e, t) { return void 0 !== t && e.ads.includedCues[t] }, w = function (e, t) { void 0 !== t && "" !== t && (e.ads.includedCues[t] = !0) }; function M() { !1 !== this.ads._shouldBlockPlay && (this.paused() || (this.ads.debug("Playback was canceled by cancelContentPlay"), this.pause()), this.ads._cancelledPlay = !0) } R.processAdTrack = function (t, n, a, r) { t.ads.includedCues = {}; for (var o = 0; o < n.length; o++) { var i = n[o], s = this.getSupportedAdCue(t, i); if (!this.isSupportedAdCue(t, i)) return void e.log.warn("Skipping as this is not a supported ad cue.", i); var A = this.getCueId(t, i), d = i.startTime; if (T(t, A)) return void e.log("Skipping ad already seen with ID " + A); r && r(t, s, A, d), a(t, s, A, d), w(t, A) } }; var L = {}, E = e; L.isMiddlewareMediatorSupported = function () { return !E.browser.IS_IOS && !E.browser.IS_ANDROID && !!(E.use && E.middleware && E.middleware.TERMINATOR) }, L.playMiddleware = function (t) { return { setSource: function (e, t) { t(null, e) }, callPlay: function () { if (t.ads && !0 === t.ads._shouldBlockPlay) return t.ads.debug("Using playMiddleware to block content playback"), t.ads._playBlocked = !0, E.middleware.TERMINATOR }, play: function (n, a) { t.ads && t.ads._playBlocked && n ? (t.ads.debug("Play call to Tech was terminated."), t.trigger("play"), t.addClass("vjs-has-started"), t.ads._playBlocked = !1) : a && a.catch && a.catch(function (n) { "NotAllowedError" !== n.name || e.browser.IS_SAFARI || t.trigger("pause") }) } } }, L.testHook = function (e) { E = e }; var I = L.playMiddleware, j = L.isMiddlewareMediatorSupported, N = function () { if (e.getPlugin) return Boolean(e.getPlugin("ads")); var t = e.getComponent("Player"); return Boolean(t && t.prototype.ads) }; var O = { src: "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAxJtZGF03ABMYXZjNjEuMy4xMDAAQiAIwRg4AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2NCByMzEwOCAzMWUxOWY5IC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMyAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTcgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAAn//71sXwKaunqigzoMi7hlyTJrrYi4m0AwABFxzcqWKGahTaoBcQAAMWK4AlcFlIICBeldSEQBGCMHAAABVNtb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAAIgABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAACQXRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAIgAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAABQAAAAPAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAACIAAAAAAAEAAAAAAbltZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAADwAAAACAFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAFkbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAABJHN0YmwAAADAc3RzZAAAAAAAAAABAAAAsGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAABQADwAEgAAABIAAAAAAAAAAEUTGF2YzYxLjMuMTAwIGxpYngyNjQAAAAAAAAAAAAAAAAY//8AAAA2YXZjQwFkAA3/4QAZZ2QADazZQUH7ARAAAAMAEAAAAwPA8UKZYAEABmjr48siwP34+AAAAAAQcGFzcAAAAAEAAAABAAAAFGJ0cnQAAAAAAALAEAACwBAAAAAYc3R0cwAAAAAAAAABAAAAAQAAAgAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAC7wAAAAEAAAAUc3RjbwAAAAAAAAABAAAARQAAAj10cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAAABgAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAAXAAAEAAABAAAAAAG1bWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAACsRAAACABVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAABYG1pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAABJHN0YmwAAAB+c3RzZAAAAAAAAAABAAAAbm1wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAACsRAAAAAAANmVzZHMAAAAAA4CAgCUAAgAEgICAF0AVAAAAAAH0AAAAEisFgICABRIQVuUABoCAgAECAAAAFGJ0cnQAAAAAAAH0AAAAEisAAAAYc3R0cwAAAAAAAAABAAAAAgAABAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAHHN0c3oAAAAAAAAAAAAAAAIAAAAVAAAABgAAABhzdGNvAAAAAAAAAAIAAAAwAAADNAAAABpzZ3BkAQAAAHJvbGwAAAACAAAAAf//AAAAHHNiZ3AAAAAAcm9sbAAAAAEAAAACAAAAAQAAAGF1ZHRhAAAAWW1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALGlsc3QAAAAkqXRvbwAAABxkYXRhAAAAAQAAAABMYXZmNjEuMS4xMDA=", type: "video/mp4" }, D = function () { function e() { } return e.getState = function (t) { if (t) return e.states_ && e.states_[t] ? e.states_[t] : void 0 }, e.registerState = function (t, n) { if ("string" != typeof t || !t) throw new Error('Illegal state name, "' + t + '"; must be a non-empty string.'); return e.states_ || (e.states_ = {}), e.states_[t] = n, n }, e }(), Z = function () { function t(e) { this.player = e } t._getName = function () { return "Anonymous State" }; var n = t.prototype; return n.transitionTo = function (e) { var t = this.player; this.cleanup(t); var n = new e(t); t.ads._state = n, t.ads.debug(this.constructor._getName() + " -> " + n.constructor._getName()); for (var a = arguments.length, r = new Array(a > 1 ? a - 1 : 0), o = 1; o < a; o++)r[o - 1] = arguments[o]; n.init.apply(n, [t].concat(r)) }, n.init = function () { }, n.cleanup = function () { }, n.onPlay = function () { }, n.onPlaying = function () { }, n.onEnded = function () { }, n.onAdEnded = function () { }, n.onAdsReady = function () { e.log.warn("Unexpected adsready event") }, n.onAdsError = function () { }, n.onAdsCanceled = function () { }, n.onAdTimeout = function () { }, n.onAdStarted = function () { }, n.onAdSkipped = function () { }, n.onContentChanged = function () { }, n.onContentResumed = function () { }, n.onReadyForPostroll = function () { e.log.warn("Unexpected readyforpostroll event") }, n.onNoPreroll = function () { }, n.onNoPostroll = function () { }, n.startLinearAdMode = function () { e.log.warn("Unexpected startLinearAdMode invocation (State via " + this.constructor._getName() + ")") }, n.endLinearAdMode = function () { e.log.warn("Unexpected endLinearAdMode invocation (State via " + this.constructor._getName() + ")") }, n.skipLinearAdMode = function () { e.log.warn("Unexpected skipLinearAdMode invocation (State via " + this.constructor._getName() + ")") }, n.isAdState = function () { throw new Error("isAdState unimplemented for " + this.constructor._getName()) }, n.isWaitingForAdBreak = function () { return !1 }, n.isContentResuming = function () { return !1 }, n.inAdBreak = function () { return !1 }, n.handleEvent = function (e) { var t = this.player; "play" === e ? this.onPlay(t) : "adsready" === e ? this.onAdsReady(t) : "adserror" === e ? this.onAdsError(t) : "adscanceled" === e ? this.onAdsCanceled(t) : "adtimeout" === e ? this.onAdTimeout(t) : "ads-ad-started" === e ? this.onAdStarted(t) : "ads-ad-skipped" === e ? this.onAdSkipped(t) : "contentchanged" === e ? this.onContentChanged(t) : "contentresumed" === e ? this.onContentResumed(t) : "readyforpostroll" === e ? this.onReadyForPostroll(t) : "playing" === e ? this.onPlaying(t) : "ended" === e ? this.onEnded(t) : "nopreroll" === e ? this.onNoPreroll(t) : "nopostroll" === e ? this.onNoPostroll(t) : "adended" === e && this.onAdEnded(t) }, t }(); D.registerState("State", Z); var x = function (e) { function t(t) { var n; return (n = e.call(this, t) || this).contentResuming = !1, n.waitingForAdBreak = !1, n } c(t, e); var n = t.prototype; return n.isAdState = function () { return !0 }, n.onPlaying = function () { var e = D.getState("ContentPlayback"); this.contentResuming && this.transitionTo(e) }, n.onContentResumed = function () { var e = D.getState("ContentPlayback"); this.contentResuming && this.transitionTo(e) }, n.isWaitingForAdBreak = function () { return this.waitingForAdBreak }, n.isContentResuming = function () { return this.contentResuming }, n.inAdBreak = function () { return !0 === this.player.ads._inLinearAdMode }, t }(Z); D.registerState("AdState", x); var F = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e); var n = t.prototype; return n.isAdState = function () { return !1 }, n.onContentChanged = function (e) { var t = D.getState("BeforePreroll"), n = D.getState("Preroll"); e.ads.debug("Received contentchanged event (ContentState)"), e.paused() ? this.transitionTo(t) : (this.transitionTo(n, !1), e.pause(), e.ads._pausedOnContentupdate = !0) }, t }(Z); D.registerState("ContentState", F); var G, W = function (t) { function n() { return t.apply(this, arguments) || this } c(n, t), n._getName = function () { return "AdsDone" }; var a = n.prototype; return a.init = function (e) { e.ads._contentHasEnded = !0, e.trigger("ended") }, a.startLinearAdMode = function () { e.log.warn("Unexpected startLinearAdMode invocation (AdsDone)") }, n }(D.getState("ContentState")); D.registerState("AdsDone", W); var H = { start: function (t) { t.ads.debug("Starting ad break"), t.ads._inLinearAdMode = !0, t.trigger("adstart"), t.ads.shouldTakeSnapshots() && (t.ads.snapshot = function (t) { var n; n = e.browser.IS_IOS && t.ads.isLive(t) && t.seekable().length > 0 ? t.currentTime() - t.seekable().end(0) : t.currentTime(); var a = t.$(".vjs-tech"), r = t.textTracks ? t.textTracks() : [], o = [], i = { ended: t.ended(), currentSrc: t.currentSrc(), sources: t.currentSources(), src: t.tech_.src(), currentTime: n, type: t.currentType() }; a && (i.style = a.getAttribute("style")); for (var s = 0; s < r.length; s++) { var A = r[s]; o.push({ track: A, mode: A.mode }), A.mode = "disabled" } return i.suppressedTracks = o, i }(t)), t.ads.shouldPlayContentBehindAd(t) && !t.ads.settings.stitchedAds && (t.ads.preAdVolume_ = t.volume(), t.volume(0)), t.addClass("vjs-ad-playing"), t.hasClass("vjs-live") && t.removeClass("vjs-live"), t.ads.removeNativePoster(), t.ads.preAdPlaybackRate_ = t.playbackRate(), t.playbackRate(1), t.controlBar && t.controlBar.playbackRateMenuButton && t.controlBar.playbackRateMenuButton.playbackRateSupported && !t.controlBar.playbackRateMenuButton.hasClass("vjs-hidden") ? (t.controlBar.playbackRateMenuButton.hide(), t.ads.showPlaybackMenuOnAdEnd_ = !0) : t.ads.showPlaybackMenuOnAdEnd_ = !1 }, end: function (t, n) { t.ads.debug("Ending ad break"), void 0 === n && (n = function () { }), t.ads.adType = null, t.ads._inLinearAdMode = !1, t.trigger("adend"), t.removeClass("vjs-ad-playing"), t.ads.isLive(t) && t.addClass("vjs-live"), t.ads.shouldTakeSnapshots() ? function (t, n) { var a = t.ads.snapshot; if (void 0 === n && (n = function () { }), !0 === t.ads.disableNextSnapshotRestore) return t.ads.disableNextSnapshotRestore = !1, delete t.ads.snapshot, void n(); var r, o = t.$(".vjs-tech"), i = 20, s = a.suppressedTracks, A = function () { for (var e = 0; e < s.length; e++)(r = s[e]).track.mode = r.mode }, d = function () { var n; if (e.browser.IS_IOS && t.ads.isLive(t)) { if (a.currentTime < 0 && (n = t.seekable().length > 0 ? t.seekable().end(0) + a.currentTime : t.currentTime(), t.currentTime(n)), t.paused()) { var r = t.play(); r && r.catch && r.catch(function (t) { e.log.warn("Play promise rejected in IOS snapshot resume", t) }) } } else if (a.ended) t.currentTime(t.duration()); else { t.currentTime(a.currentTime); var o = t.play(); o && o.catch && o.catch(function (t) { e.log.warn("Play promise rejected in snapshot resume", t) }) } t.ads.shouldRemoveAutoplay_ && (t.autoplay(!1), t.ads.shouldRemoveAutoplay_ = !1) }, l = function n() { if (t.off("contentcanplay", n), G && t.clearTimeout(G), (o = t.el().querySelector(".vjs-tech")).readyState > 1) return d(); if (void 0 === o.seekable) return d(); if (o.seekable.length > 0) return d(); if (i--) t.setTimeout(n, 50); else try { d() } catch (n) { t.ads.error({ errorType: m.AdsResumeContentFailed, error: n }), e.log.warn("Failed to resume the content after an advertisement", n) } }; if ("style" in a && o.setAttribute("style", a.style || ""), t.ads.videoElementRecycled()) t.one("resumeended", function () { delete t.ads.snapshot, n() }), t.one("contentloadedmetadata", A), e.browser.IS_IOS && !t.autoplay() && "function" == typeof t.techCall_ && (t.techCall_("setAutoplay", !0), t.ads.shouldRemoveAutoplay_ = !0), t.src(a.sources), t.one("contentcanplay", l), G = t.setTimeout(l, 2e3); else { if (A(), !t.ended()) { var u = t.play(); u && u.catch && u.catch(function (t) { e.log.warn("Play promise rejected in snapshot restore", t) }) } delete t.ads.snapshot, n() } }(t, n) : (t.ads.preAdVolume_ && t.volume(t.ads.preAdVolume_), n()), t.playbackRate(t.ads.preAdPlaybackRate_), t.ads.showPlaybackMenuOnAdEnd_ && t.controlBar.playbackRateMenuButton.show() } }, Y = function (t) { function n() { return t.apply(this, arguments) || this } c(n, t), n._getName = function () { return "Preroll" }; var a = n.prototype; return a.init = function (e, t, n) { if (this.waitingForAdBreak = !0, e.addClass("vjs-ad-loading"), n || e.ads.nopreroll_) return this.resumeAfterNoPreroll(e); var a = e.ads.settings.timeout; "number" == typeof e.ads.settings.prerollTimeout && (a = e.ads.settings.prerollTimeout), this._timeout = e.setTimeout(function () { e.trigger("adtimeout") }, a), t ? this.handleAdsReady() : this.adsReady = !1 }, a.onAdsReady = function (t) { t.ads.inAdBreak() ? e.log.warn("Unexpected adsready event (Preroll)") : (t.ads.debug("Received adsready event (Preroll)"), this.handleAdsReady()) }, a.handleAdsReady = function () { this.adsReady = !0, this.readyForPreroll() }, a.afterLoadStart = function (e) { var t = this.player; t.ads._hasThereBeenALoadStartDuringPlayerLife ? e() : (t.ads.debug("Waiting for loadstart..."), t.one("loadstart", function () { t.ads.debug("Received loadstart event"), e() })) }, a.noPreroll = function () { var e = this; this.afterLoadStart(function () { e.player.ads.debug("Skipping prerolls due to nopreroll event (Preroll)"), e.resumeAfterNoPreroll(e.player) }) }, a.readyForPreroll = function () { var e = this.player; this.afterLoadStart(function () { e.ads.debug("Triggered readyforpreroll event (Preroll)"), e.trigger("readyforpreroll") }) }, a.onAdsCanceled = function (e) { var t = this; e.ads.debug("adscanceled (Preroll)"), this.afterLoadStart(function () { t.resumeAfterNoPreroll(e) }) }, a.onAdsError = function (t) { var n = this; e.log("adserror (Preroll)"), t.ads.error({ errorType: m.AdsPrerollError }), this.inAdBreak() ? t.ads.endLinearAdMode() : this.afterLoadStart(function () { n.resumeAfterNoPreroll(t) }) }, a.startLinearAdMode = function () { var t = this.player; !this.adsReady || t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected startLinearAdMode invocation (Preroll)") : (this.clearTimeout(t), t.ads.adType = "preroll", this.waitingForAdBreak = !1, H.start(t), t.ads._shouldBlockPlay = !1) }, a.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, a.endLinearAdMode = function () { var e = this.player; this.inAdBreak() && (e.removeClass("vjs-ad-loading"), e.addClass("vjs-ad-content-resuming"), this.contentResuming = !0, H.end(e)) }, a.skipLinearAdMode = function () { var t = this, n = this.player; n.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected skipLinearAdMode invocation") : this.afterLoadStart(function () { n.trigger("adskip"), n.ads.debug("skipLinearAdMode (Preroll)"), t.resumeAfterNoPreroll(n) }) }, a.onAdTimeout = function (e) { var t = this; this.afterLoadStart(function () { e.ads.debug("adtimeout (Preroll)"), t.resumeAfterNoPreroll(e) }) }, a.onNoPreroll = function (t) { t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected nopreroll event (Preroll)") : this.noPreroll() }, a.resumeAfterNoPreroll = function (e) { if (this.contentResuming = !0, e.ads._shouldBlockPlay = !1, this.cleanupPartial(e), e.ads._playRequested || e.ads._pausedOnContentupdate) if (e.paused()) { e.ads.debug("resumeAfterNoPreroll: attempting to resume playback (Preroll)"); var t = e.play(); t && t.then && t.then(null, function (e) { }) } else e.ads.debug("resumeAfterNoPreroll: already playing (Preroll)"), e.trigger("play"), e.trigger("playing") }, a.cleanup = function (t) { t.ads._hasThereBeenALoadStartDuringPlayerLife || e.log.warn("Leaving Preroll state before loadstart event can cause issues."), this.cleanupPartial(t) }, a.cleanupPartial = function (e) { e.removeClass("vjs-ad-loading"), e.removeClass("vjs-ad-content-resuming"), this.clearTimeout(e) }, a.clearTimeout = function (e) { e.clearTimeout(this._timeout), this._timeout = null }, n }(D.getState("AdState")); D.registerState("Preroll", Y); var Q = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e), t._getName = function () { return "BeforePreroll" }; var n = t.prototype; return n.init = function (e) { this.adsReady = !1, this.shouldResumeToContent = !1, e.ads._shouldBlockPlay = !e.ads.settings.allowVjsAutoplay || !e.autoplay() }, n.onAdsReady = function (e) { e.ads.debug("Received adsready event (BeforePreroll)"), this.adsReady = !0 }, n.onPlay = function (e) { var t = D.getState("Preroll"); e.ads.debug("Received play event (BeforePreroll)"), this.transitionTo(t, this.adsReady, this.shouldResumeToContent) }, n.onAdsCanceled = function (e) { e.ads.debug("adscanceled (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.onAdsError = function () { this.player.ads.debug("adserror (BeforePreroll)"), this.player.ads.error({ errorType: m.AdsBeforePrerollError }), this.shouldResumeToContent = !0 }, n.onNoPreroll = function () { this.player.ads.debug("Skipping prerolls due to nopreroll event (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.skipLinearAdMode = function () { var e = this.player; e.trigger("adskip"), e.ads.debug("skipLinearAdMode (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.onContentChanged = function () { this.init(this.player) }, t }(D.getState("ContentState")); D.registerState("BeforePreroll", Q); var V = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e), t._getName = function () { return "Midroll" }; var n = t.prototype; return n.init = function (e) { e.ads.adType = "midroll", H.start(e), e.addClass("vjs-ad-loading") }, n.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, n.endLinearAdMode = function () { var e = this.player; this.inAdBreak() && (this.contentResuming = !0, e.addClass("vjs-ad-content-resuming"), e.removeClass("vjs-ad-loading"), H.end(e)) }, n.onAdsError = function (e) { e.ads.error({ errorType: m.AdsMidrollError }), this.inAdBreak() && e.ads.endLinearAdMode() }, n.cleanup = function (e) { e.removeClass("vjs-ad-loading"), e.removeClass("vjs-ad-content-resuming") }, t }(D.getState("AdState")); D.registerState("Midroll", V); var X = function (t) { function n() { return t.apply(this, arguments) || this } c(n, t), n._getName = function () { return "Postroll" }; var a = n.prototype; return a.init = function (e) { if (this.waitingForAdBreak = !0, e.ads._contentEnding = !0, e.ads.nopostroll_) { this.resumeContent(e); var t = D.getState("AdsDone"); this.transitionTo(t) } else { e.addClass("vjs-ad-loading"); var n = e.ads.settings.timeout; "number" == typeof e.ads.settings.postrollTimeout && (n = e.ads.settings.postrollTimeout), this._postrollTimeout = e.setTimeout(function () { e.trigger("adtimeout") }, n) } }, a.startLinearAdMode = function () { var t = this.player; t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected startLinearAdMode invocation (Postroll)") : (t.ads.adType = "postroll", t.clearTimeout(this._postrollTimeout), this.waitingForAdBreak = !1, H.start(t)) }, a.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, a.endLinearAdMode = function () { var e = this, t = this.player, n = D.getState("AdsDone"); this.inAdBreak() && (t.removeClass("vjs-ad-loading"), this.resumeContent(t), H.end(t, function () { e.transitionTo(n) })) }, a.skipLinearAdMode = function () { var t = this.player; t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected skipLinearAdMode invocation") : (t.ads.debug("Postroll abort (skipLinearAdMode)"), t.trigger("adskip"), this.abort(t)) }, a.onAdTimeout = function (e) { e.ads.debug("Postroll abort (adtimeout)"), this.abort(e) }, a.onAdsError = function (e) { e.ads.debug("Postroll abort (adserror)"), e.ads.error({ errorType: m.AdsPostrollError }), e.ads.inAdBreak() ? e.ads.endLinearAdMode() : this.abort(e) }, a.onContentChanged = function (e) { if (this.isContentResuming()) { var t = D.getState("BeforePreroll"); this.transitionTo(t) } else if (!this.inAdBreak()) { var n = D.getState("Preroll"); this.transitionTo(n) } }, a.onNoPostroll = function (t) { this.isContentResuming() || this.inAdBreak() ? e.log.warn("Unexpected nopostroll event (Postroll)") : this.abort(t) }, a.resumeContent = function (e) { this.contentResuming = !0, e.addClass("vjs-ad-content-resuming") }, a.abort = function (e) { var t = D.getState("AdsDone"); this.resumeContent(e), e.removeClass("vjs-ad-loading"), this.transitionTo(t) }, a.cleanup = function (e) { e.removeClass("vjs-ad-content-resuming"), e.clearTimeout(this._postrollTimeout), e.ads._contentEnding = !1 }, n }(D.getState("AdState")); D.registerState("Postroll", X); var U = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e), t._getName = function () { return "ContentPlayback" }; var n = t.prototype; return n.init = function (e) { e.ads._shouldBlockPlay = !1 }, n.onAdsReady = function (e) { e.ads.debug("Received adsready event (ContentPlayback)"), e.ads.nopreroll_ || (e.ads.debug("Triggered readyforpreroll event (ContentPlayback)"), e.trigger("readyforpreroll")) }, n.onReadyForPostroll = function (e) { var t = D.getState("Postroll"); e.ads.debug("Received readyforpostroll event"), this.transitionTo(t) }, n.startLinearAdMode = function () { var e = D.getState("Midroll"); this.transitionTo(e) }, t }(D.getState("ContentState")); D.registerState("ContentPlayback", U); var z = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e), t._getName = function () { return "StitchedContentPlayback" }; var n = t.prototype; return n.init = function () { this.player.ads._shouldBlockPlay = !1 }, n.onContentChanged = function () { this.player.ads.debug("Received contentchanged event (" + this.constructor._getName() + ")") }, n.startLinearAdMode = function () { var e = D.getState("StitchedAdRoll"); this.transitionTo(e) }, t }(D.getState("ContentState")); D.registerState("StitchedContentPlayback", z); var J = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e), t._getName = function () { return "StitchedAdRoll" }; var n = t.prototype; return n.init = function () { this.waitingForAdBreak = !1, this.contentResuming = !1, this.player.ads.adType = "stitched", H.start(this.player) }, n.onPlaying = function () { }, n.onContentResumed = function () { }, n.onAdEnded = function () { this.endLinearAdMode(), this.player.trigger("ended") }, n.endLinearAdMode = function () { var e = D.getState("StitchedContentPlayback"); H.end(this.player), this.transitionTo(e) }, t }(D.getState("AdState")); D.registerState("StitchedAdRoll", J); var q = function (e) { function t() { return e.apply(this, arguments) || this } c(t, e), t._getName = function () { return "OutstreamPending" }; var n = t.prototype; return n.init = function (e) { this.adsReady = !1 }, n.onPlay = function (e) { var t = D.getState("OutstreamPlayback"); e.ads.debug("Received play event (OutstreamPending)"), this.transitionTo(t, this.adsReady) }, n.onAdsReady = function (e) { e.ads.debug("Received adsready event (OutstreamPending)"), this.adsReady = !0 }, n.onAdsError = function () { this.player.ads.debug("adserror (OutstreamPending)"), this.adsReady = !1 }, t }(D.getState("AdState")); D.registerState("OutstreamPending", q); var K = function (t) { function n() { return t.apply(this, arguments) || this } c(n, t), n._getName = function () { return "OutstreamPlayback" }; var a = n.prototype; return a.init = function (e, t) { e.addClass("vjs-ad-loading"), t ? this.handleAdsReady() : this.abort(e) }, a.onAdsReady = function (t) { t.ads.inAdBreak() ? e.log.warn("Unexpected adsready event (Preroll)") : (t.ads.debug("Received adsready event (Preroll)"), this.handleAdsReady()) }, a.abort = function (e) { var t = D.getState("OutstreamDone"); e.removeClass("vjs-ad-loading"), this.transitionTo(t) }, a.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, a.handleAdsReady = function () { this.adsReady = !0, this.readyForOutstreamPlayback() }, a.readyForOutstreamPlayback = function () { var e = this.player; this.afterLoadStart(function () { e.trigger("readyforoutstream") }) }, a.startLinearAdMode = function () { var e = this.player; this.adsReady && !e.ads.inAdBreak() && H.start(e) }, a.cleanup = function (t) { t.ads._hasThereBeenALoadStartDuringPlayerLife || e.log.warn("Leaving OutstreamPlayback state before loadstart event can cause issues."), this.cleanupPartial(t) }, a.cleanupPartial = function (e) { e.removeClass("vjs-ad-loading"), e.removeClass("vjs-ad-content-resuming"), this.clearTimeout(e) }, a.clearTimeout = function (e) { e.clearTimeout(this._timeout), this._timeout = null }, a.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, a.onAdsError = function (t) { var n = this; e.log("adserror (OutstreamPlayback)"), this.inAdBreak() ? t.ads.endLinearAdMode() : this.afterLoadStart(function () { n.abort(t) }) }, a.onAdTimeout = function (e) { var t = this; this.afterLoadStart(function () { e.ads.debug("adtimeout (OutstreamPlayback)"), t.abort(e) }) }, a.onAdsCanceled = function (e) { var t = this; e.ads.debug("adscanceled (OutstreamPlaybac)"), this.afterLoadStart(function () { t.abort(e) }) }, a.endLinearAdMode = function () { var e = this; if (this.inAdBreak()) { this.player.removeClass("vjs-ad-loading"); var t = D.getState("OutstreamDone"); H.end(this.player, function () { e.transitionTo(t) }) } }, a.afterLoadStart = function (e) { var t = this.player; t.ads._hasThereBeenALoadStartDuringPlayerLife ? e() : (t.ads.debug("Waiting for loadstart..."), t.one("loadstart", function () { t.ads.debug("Received loadstart event"), e() })) }, a.skipLinearAdMode = function () { var t = this, n = this.player, a = D.getState("OutstreamDone"); this.inAdBreak() ? e.log.warn("Unexpected skipLinearAdMode invocation") : this.afterLoadStart(function () { n.trigger("adskip"), n.ads.debug("skipLinearAdMode (OutstreamPlayback)"), t.transitionTo(a) }) }, n }(D.getState("AdState")); D.registerState("OutstreamPlayback", K); var $ = function (t) { function n() { return t.apply(this, arguments) || this } c(n, t), n._getName = function () { return "OutstreamDone" }; var a = n.prototype; return a.init = function (e) { e.trigger("ended") }, a.startLinearAdMode = function () { e.log.warn("Unexpected startLinearAdMode invocation (OutstreamDone)") }, n }(D.getState("AdState")); D.registerState("OutstreamDone", $); var ee = L.isMiddlewareMediatorSupported, te = e.getTech("Html5").Events, ne = { timeout: 5e3, prerollTimeout: void 0, postrollTimeout: void 0, debug: !1, stitchedAds: !1, contentIsLive: void 0, liveCuePoints: !0, allowVjsAutoplay: e.options.normalizeAutoplay || !1 }, ae = function (t) { var n = this, r = e.obj.merge(ne, t), o = []; te.concat(["firstplay", "loadedalldata"]).forEach(function (e) { -1 === o.indexOf(e) && o.push(e) }), n.on(o, l), ee() || function (t, n) { n && e.log("Using cancelContentPlay to block content playback"), t.on("play", M) }(n, r.debug), n.setTimeout(function () { n.ads._hasThereBeenALoadStartDuringPlayerLife || "" === n.src() || e.log.error("tm_videojs-contrib-ads has not seen a loadstart event 5 seconds after being initialized, but a source is present. This indicates that tm_videojs-contrib-ads was initialized too late. It must be initialized immediately after video.js in the same tick. As a result, some ads will not play and some media events will be incorrect. For more information, see http://tm_videojs.github.io/tm_videojs-contrib-ads/integrator/getting-started.html") }, 5e3), n.on("ended", function () { n.hasClass("vjs-has-started") || n.addClass("vjs-has-started") }), n.on("contenttimeupdate", function () { n.removeClass("vjs-waiting") }), n.on(["addurationchange", "adcanplay"], function () { if (!n.ads.settings.stitchedAds && !n.hasStarted() && (!n.ads.snapshot || n.currentSrc() !== n.ads.snapshot.currentSrc) && n.ads.inAdBreak()) { var t = n.play(); t && t.catch && t.catch(function (t) { e.log.warn("Play promise rejected when playing ad", t) }) } }), n.on("nopreroll", function () { n.ads.debug("Received nopreroll event"), n.ads.nopreroll_ = !0 }), n.on("nopostroll", function () { n.ads.debug("Received nopostroll event"), n.ads.nopostroll_ = !0 }), n.on("playing", function () { n.ads._cancelledPlay = !1, n.ads._pausedOnContentupdate = !1 }), n.on("play", function () { n.ads._playRequested = !0 }), n.one("loadstart", function () { n.ads._hasThereBeenALoadStartDuringPlayerLife = !0 }), n.on("loadeddata", function () { n.ads._hasThereBeenALoadedData = !0 }), n.on("loadedmetadata", function () { n.ads._hasThereBeenALoadedMetaData = !0 }), n.ads = function (t) { return { disableNextSnapshotRestore: !1, _contentEnding: !1, _contentHasEnded: !1, _hasThereBeenALoadStartDuringPlayerLife: !1, _hasThereBeenALoadedData: !1, _hasThereBeenALoadedMetaData: !1, _inLinearAdMode: !1, _shouldBlockPlay: !1, _playBlocked: !1, _playRequested: !1, _error: null, adType: null, VERSION: a, reset: function () { t.ads.disableNextSnapshotRestore = !1, t.ads._contentEnding = !1, t.ads._contentHasEnded = !1, t.ads.snapshot = null, t.ads.adType = null, t.ads._hasThereBeenALoadedData = !1, t.ads._hasThereBeenALoadedMetaData = !1, t.ads._cancelledPlay = !1, t.ads._shouldBlockPlay = !1, t.ads._playBlocked = !1, t.ads.nopreroll_ = !1, t.ads.nopostroll_ = !1, t.ads._playRequested = !1, t.ads._error = null }, startLinearAdMode: function () { t.ads._state.startLinearAdMode() }, endLinearAdMode: function () { t.ads._state.endLinearAdMode() }, skipLinearAdMode: function () { t.ads._state.skipLinearAdMode() }, stitchedAds: function (t) { return void 0 !== t && (e.log.warn("Using player.ads.stitchedAds() as a setter is deprecated, it should be set as an option upon initialization of contrib-ads."), this.settings.stitchedAds = !!t), this.settings.stitchedAds }, videoElementRecycled: function () { if (t.ads.shouldPlayContentBehindAd(t)) return !1; if (!this.snapshot) throw new Error("You cannot use videoElementRecycled while there is no snapshot."); var e = t.tech_.src() !== this.snapshot.src, n = t.currentSrc() !== this.snapshot.currentSrc; return e || n }, isLive: function (n) { return void 0 === n && (n = t), "boolean" == typeof n.ads.settings.contentIsLive ? n.ads.settings.contentIsLive : n.duration() === 1 / 0 || "8" === e.browser.IOS_VERSION && 0 === n.duration() }, shouldPlayContentBehindAd: function (n) { if (void 0 === n && (n = t), n) return !!n.ads.settings.liveCuePoints && !e.browser.IS_IOS && !e.browser.IS_ANDROID && n.duration() === 1 / 0; throw new Error("shouldPlayContentBehindAd requires a player as a param") }, shouldTakeSnapshots: function (e) { return void 0 === e && (e = t), !this.shouldPlayContentBehindAd(e) && !this.stitchedAds() }, isInAdMode: function () { return this._state.isAdState() }, isWaitingForAdBreak: function () { return this._state.isWaitingForAdBreak() }, isContentResuming: function () { return this._state.isContentResuming() }, isAdPlaying: function () { return this._state.inAdBreak() }, inAdBreak: function () { return this._state.inAdBreak() }, removeNativePoster: function () { var e = t.$(".vjs-tech"); e && e.removeAttribute("poster") }, debug: function () { if (this.settings.debug) { for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)n[a] = arguments[a]; 1 === n.length && "string" == typeof n[0] ? e.log("ADS: " + n[0]) : e.log.apply(e, ["ADS:"].concat(n)) } }, error: function (n) { if (void 0 === n) return this._error || null; null !== n && n.errorType ? (this._error = n, e.log.error("An error with Ads occured. Type: " + n.errorType + "."), t.trigger({ type: "vjsadserror", error: this._error })) : this._error = null } } }(n), n.ads.settings = r, r.stitchedAds = !!r.stitchedAds, "outstream" === r.playerMode ? (n.src(O), n.ads._state = new (D.getState("OutstreamPending"))(n)) : r.stitchedAds ? n.ads._state = new (D.getState("StitchedContentPlayback"))(n) : n.ads._state = new (D.getState("BeforePreroll"))(n), n.ads._state.init(n), n.ads.cueTextTracks = R, n.ads.adMacroReplacement = function (e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = {}); var a = n.disableDefaultMacros || !1, r = n.macroNameOverrides || {}; delete n.disableDefaultMacros, delete n.macroNameOverrides; var o = n; if (a) return C(e, o, t, r); var i = S(e), s = i.defaults, A = i.modifiedString; for (var d in e = A, u(o, P(this), b(this.mediainfo, s), k(f), B(), _(e, s, r)), e = C(e, o, t, r, this), s) e = e.replace(d, s[d]); return e }.bind(n), function (e) { e.ads.contentSrc = e.currentSrc(), e.ads._seenInitialLoadstart = !1, e.on("loadstart", function () { if (!e.ads.inAdBreak()) { var t = e.currentSrc(); t !== e.ads.contentSrc && (e.ads._seenInitialLoadstart && e.trigger({ type: "contentchanged" }), e.trigger({ type: "contentupdate", oldValue: e.ads.contentSrc, newValue: t }), e.ads.contentSrc = t), e.ads._seenInitialLoadstart = !0 } }) }(n), n.on("contentchanged", n.ads.reset); var i = function () { var t = n.textTracks(); if (!n.ads.shouldPlayContentBehindAd(n) && n.ads.inAdBreak() && n.tech_.featuresNativeTextTracks && e.browser.IS_IOS && !Array.isArray(n.textTracks())) for (var a = 0; a < t.length; a++) { var r = t[a]; "showing" === r.mode && (r.mode = "disabled") } }; n.ready(function () { n.textTracks().addEventListener("change", i) }), n.on(["play", "playing", "ended", "adsready", "adscanceled", "adskip", "adserror", "adtimeout", "adended", "ads-ad-started", "ads-ad-skipped", "contentchanged", "dispose", "contentresumed", "readyforpostroll", "nopreroll", "nopostroll"], function (e) { n.ads._state.handleEvent(e.type) }), n.on("dispose", function () { n.ads.reset(), n.textTracks().removeEventListener("change", i) }), h(), y(function () { }), n.ads.listenToTcf = h, n.ads.updateUsPrivacyString = function (e) { return y(e) } }; return ae.Error = m, ae.VERSION = a, function (t) { !N(e) && ((e.registerPlugin || e.plugin)("ads", t), j() && !e.usingContribAdsMiddleware_ && (e.use("*", I), e.usingContribAdsMiddleware_ = !0, e.log.debug("Play middleware has been registered with tm_videojs"))) }(ae), ae });




/*! @name tm_videojs-contrib-ads @version 7.3.2 @license Apache-2.0 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require("video.js"), require("global/window"), require("global/document")) : "function" == typeof define && define.amd ? define(["video.js", "global/window", "global/document"], t) : (e = e || self).tm_videojsContribAds = t(e.tm_videojs, e.window, e.document) }(this, function (e, t, n) { "use strict"; e = e && e.hasOwnProperty("default") ? e.default : e, t = t && t.hasOwnProperty("default") ? t.default : t, n = n && n.hasOwnProperty("default") ? n.default : n; var a = "7.3.2"; var r = function (e, t) { t.isImmediatePropagationStopped = function () { return !0 }, t.cancelBubble = !0, t.isPropagationStopped = function () { return !0 } }, o = function (e, t, n) { r(0, n), e.trigger({ type: t + n.type, originalEvent: n }) }, i = function (e, t) { e.ads.isInAdMode() && (e.ads.isContentResuming() ? e.ads._contentEnding && o(e, "content", t) : o(e, "ad", t)) }, s = function (e, t) { e.ads.isInAdMode() ? e.ads.isContentResuming() ? (r(0, t), e.trigger("resumeended")) : o(e, "ad", t) : e.ads._contentHasEnded || e.ads.stitchedAds() || (o(e, "content", t), e.trigger("readyforpostroll")) }, d = function (e, t) { if (!("loadstart" === t.type && !e.ads._hasThereBeenALoadStartDuringPlayerLife || "loadeddata" === t.type && !e.ads._hasThereBeenALoadedData || "loadedmetadata" === t.type && !e.ads._hasThereBeenALoadedMetaData)) if (e.ads.inAdBreak()) o(e, "ad", t); else { if (e.currentSrc() !== e.ads.contentSrc) return; o(e, "content", t) } }, l = function (e, t) { e.ads.inAdBreak() ? o(e, "ad", t) : e.ads.isContentResuming() && o(e, "content", t) }; function u(e) { "playing" === e.type ? i(this, e) : "ended" === e.type ? s(this, e) : "loadstart" === e.type || "loadeddata" === e.type || "loadedmetadata" === e.type ? d(this, e) : "play" === e.type ? l(this, e) : this.ads.isInAdMode() && (this.ads.isContentResuming() ? o(this, "content", e) : o(this, "ad", e)) } function c() { return (c = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]) } return e }).apply(this, arguments) } function p(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, f(e, t) } function f(e, t) { return (f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e })(e, t) } var h = {}, g = function () { !function (n) { if (e.dom.isInFrame() && "function" != typeof t.__tcfapi) { for (var a, r = t, o = {}; r;) { try { if (r.frames.__tcfapiLocator) { a = r; break } } catch (e) { } if (r === t.top) break; r = r.parent } if (!a) return; t.__tcfapi = function (e, t, n, r) { var i = Math.random() + "", s = { __tcfapiCall: { command: e, parameter: r, version: t, callId: i } }; o[i] = n, a.postMessage(s, "*") }, t.addEventListener("message", function (e) { var t = {}; try { t = "string" == typeof e.data ? JSON.parse(e.data) : e.data } catch (e) { } var n = t.__tcfapiReturn; n && "function" == typeof o[n.callId] && (o[n.callId](n.returnValue, n.success), o[n.callId] = null) }, !1) } }(), "function" == typeof t.__tcfapi && t.__tcfapi("addEventListener", 2, function (e, t) { t && (h = e) }) }, y = "", v = function (e, n) { if (void 0 === n && (n = t), n.__uspapi) n.__uspapi("getUSPData", 1, function (t, n) { var a = n ? t.uspString : null; y = a, e(a) }); else { var a = function (e) { for (var t = e.parent; t !== e.top;) { try { if (t.frames && t.frames.__uspapiLocator) return t } catch (e) { } t = t.parent } try { if (e.top.frames && e.top.frames.__uspapiLocator) return e.top } catch (e) { } return null }(n); if (!a) return void e(null); var r = Math.random().toString(36).substring(2), o = { __uspapiCall: { command: "getUSPData", version: 1, callId: r } }; n.addEventListener("message", function t(a) { if (a && a.data && a.data.__uspapiReturn && a.data.__uspapiReturn.callId === r) { n.removeEventListener("message", t, !1); var o = a.data.__uspapiReturn, i = o.returnValue, s = o.success ? i.uspString : null; y = s, e(s) } }, !1), a.postMessage(o, "*") } }, m = function (e, t) { return t ? encodeURIComponent(e) : e }, A = function (e, t) { var n = {}; return ["description", "tags", "reference_id", "ad_keys"].forEach(function (a) { e && e[a] ? n["{mediainfo." + a + "}"] = e[a] : t["{mediainfo." + a + "}"] ? n["{mediainfo." + a + "}"] = t["{mediainfo." + a + "}"] : n["{mediainfo." + a + "}"] = "" }), ["custom_fields", "customFields"].forEach(function (t) { !function (e, t, n) { if (e && e[n]) for (var a = e[n], r = Object.keys(a), o = 0; o < r.length; o++)t["{mediainfo." + n + "." + r[o] + "}"] = a[r[o]] }(e, n, t) }), n }, _ = function (e) { var t = {}, n = e.replace(/{([^}=]+)=([^}]*)}/g, function (e, n, a) { return t["{" + n + "}"] = a, "{" + n + "}" }); return { defaults: t, modifiedString: n } }, S = function (a) { return { "{player.id}": a.options_["data-player"] || a.id_, "{player.height}": a.currentHeight(), "{player.width}": a.currentWidth(), "{player.heightInt}": Math.round(a.currentHeight()), "{player.widthInt}": Math.round(a.currentWidth()), "{player.autoplay}": a.autoplay() ? 1 : 0, "{player.muted}": a.muted() ? 1 : 0, "{player.language}": a.language() || "", "{mediainfo.id}": a.mediainfo ? a.mediainfo.id : "", "{mediainfo.name}": a.mediainfo ? a.mediainfo.name : "", "{mediainfo.duration}": a.mediainfo ? a.mediainfo.duration : "", "{player.duration}": a.duration(), "{player.durationInt}": Math.round(a.duration()), "{player.live}": a.duration() === 1 / 0 ? 1 : 0, "{player.pageUrl}": e.dom.isInFrame() ? n.referrer : t.location.href, "{playlistinfo.id}": a.playlistinfo ? a.playlistinfo.id : "", "{playlistinfo.name}": a.playlistinfo ? a.playlistinfo.name : "", "{timestamp}": (new Date).getTime(), "{document.referrer}": n.referrer, "{window.location.href}": t.location.href, "{random}": Math.floor(1e12 * Math.random()) } }, b = function (e) { var t = {}; return Object.keys(e).forEach(function (n) { t["{tcf." + n + "}"] = e[n] }), t["{tcf.gdprAppliesInt}"] = e.gdprApplies ? 1 : 0, t }, k = function () { return { "{usp.uspString}": y } }, P = function (n, a, r) { var o = new RegExp("{pageVariable\\.([^}]+)}", "g"), i = {}, s = (n.match(o) || []).concat(Object.keys(r).filter(function (e) { return o.test(e) && n.includes(r[e]) })); if (s) return s.forEach(function (n) { for (var r, o = n, s = n.slice(14, -1), d = s.split("."), l = t, u = 0; u < d.length; u++)if (u === d.length - 1) r = l[d[u]]; else if (void 0 === (l = l[d[u]])) break; var c = typeof r; null === r ? i[o] = "null" : void 0 === r ? a[o] ? i[o] = a[o] : (e.log.warn('Page variable "' + s + '" not found'), i[o] = "") : "string" !== c && "number" !== c && "boolean" !== c ? (e.log.warn('Page variable "' + s + '" is not a supported type'), i[o] = "") : i[o] = r }), i }, C = function (t, n, a, r) { for (var o in void 0 === r && (r = {}), n) { var i = r.hasOwnProperty(o) ? r[o] : o; if (i.startsWith("r:")) try { var s = new RegExp(i.slice(2), "g"); t = t.replace(s, m(n[o], a)) } catch (t) { e.log.warn('Unable to replace macro with regex "' + i + '". The provided regex may be invalid.') } else t = t.split(i).join(m(n[o], a)) } return t }; var T = { processMetadataTracks: function (e, t) { for (var n = e.textTracks(), a = function (n) { "metadata" === n.kind && (e.ads.cueTextTracks.setMetadataTrackMode(n), t(e, n)) }, r = 0; r < n.length; r++)a(n[r]); n.addEventListener("addtrack", function (e) { a(e.track) }) }, setMetadataTrackMode: function (e) { }, getSupportedAdCue: function (e, t) { return t }, isSupportedAdCue: function (e, t) { return !0 }, getCueId: function (e, t) { return t.id } }, R = function (e, t) { return void 0 !== t && e.ads.includedCues[t] }, w = function (e, t) { void 0 !== t && "" !== t && (e.ads.includedCues[t] = !0) }; function B() { !1 !== this.ads._shouldBlockPlay && (this.paused() || (this.ads.debug("Playback was canceled by cancelContentPlay"), this.pause()), this.ads._cancelledPlay = !0) } T.processAdTrack = function (t, n, a, r) { t.ads.includedCues = {}; for (var o = 0; o < n.length; o++) { var i = n[o], s = this.getSupportedAdCue(t, i); if (!this.isSupportedAdCue(t, i)) return void e.log.warn("Skipping as this is not a supported ad cue.", i); var d = this.getCueId(t, i), l = i.startTime; if (R(t, d)) return void e.log("Skipping ad already seen with ID " + d); r && r(t, s, d, l), a(t, s, d, l), w(t, d) } }; var M = {}, L = e; M.isMiddlewareMediatorSupported = function () { return !L.browser.IS_IOS && !L.browser.IS_ANDROID && !!(L.use && L.middleware && L.middleware.TERMINATOR) }, M.playMiddleware = function (t) { return { setSource: function (e, t) { t(null, e) }, callPlay: function () { if (t.ads && !0 === t.ads._shouldBlockPlay) return t.ads.debug("Using playMiddleware to block content playback"), t.ads._playBlocked = !0, L.middleware.TERMINATOR }, play: function (n, a) { t.ads && t.ads._playBlocked && n ? (t.ads.debug("Play call to Tech was terminated."), t.trigger("play"), t.addClass("vjs-has-started"), t.ads._playBlocked = !1) : a && a.catch && a.catch(function (n) { "NotAllowedError" !== n.name || e.browser.IS_SAFARI || t.trigger("pause") }) } } }, M.testHook = function (e) { L = e }; var j = M.playMiddleware, E = M.isMiddlewareMediatorSupported, I = function () { if (e.getPlugin) return Boolean(e.getPlugin("ads")); var t = e.getComponent("Player"); return Boolean(t && t.prototype.ads) }; var N = function () { function e() { } return e.getState = function (t) { if (t) return e.states_ && e.states_[t] ? e.states_[t] : void 0 }, e.registerState = function (t, n) { if ("string" != typeof t || !t) throw new Error('Illegal state name, "' + t + '"; must be a non-empty string.'); return e.states_ || (e.states_ = {}), e.states_[t] = n, n }, e }(), O = function () { function t(e) { this.player = e } t._getName = function () { return "Anonymous State" }; var n = t.prototype; return n.transitionTo = function (e) { var t = this.player; this.cleanup(t); var n = new e(t); t.ads._state = n, t.ads.debug(this.constructor._getName() + " -> " + n.constructor._getName()); for (var a = arguments.length, r = new Array(a > 1 ? a - 1 : 0), o = 1; o < a; o++)r[o - 1] = arguments[o]; n.init.apply(n, [t].concat(r)) }, n.init = function () { }, n.cleanup = function () { }, n.onPlay = function () { }, n.onPlaying = function () { }, n.onEnded = function () { }, n.onAdEnded = function () { }, n.onAdsReady = function () { e.log.warn("Unexpected adsready event") }, n.onAdsError = function () { }, n.onAdsCanceled = function () { }, n.onAdTimeout = function () { }, n.onAdStarted = function () { }, n.onAdSkipped = function () { }, n.onContentChanged = function () { }, n.onContentResumed = function () { }, n.onReadyForPostroll = function () { e.log.warn("Unexpected readyforpostroll event") }, n.onNoPreroll = function () { }, n.onNoPostroll = function () { }, n.startLinearAdMode = function () { e.log.warn("Unexpected startLinearAdMode invocation (State via " + this.constructor._getName() + ")") }, n.endLinearAdMode = function () { e.log.warn("Unexpected endLinearAdMode invocation (State via " + this.constructor._getName() + ")") }, n.skipLinearAdMode = function () { e.log.warn("Unexpected skipLinearAdMode invocation (State via " + this.constructor._getName() + ")") }, n.isAdState = function () { throw new Error("isAdState unimplemented for " + this.constructor._getName()) }, n.isWaitingForAdBreak = function () { return !1 }, n.isContentResuming = function () { return !1 }, n.inAdBreak = function () { return !1 }, n.handleEvent = function (e) { var t = this.player; "play" === e ? this.onPlay(t) : "adsready" === e ? this.onAdsReady(t) : "adserror" === e ? this.onAdsError(t) : "adscanceled" === e ? this.onAdsCanceled(t) : "adtimeout" === e ? this.onAdTimeout(t) : "ads-ad-started" === e ? this.onAdStarted(t) : "ads-ad-skipped" === e ? this.onAdSkipped(t) : "contentchanged" === e ? this.onContentChanged(t) : "contentresumed" === e ? this.onContentResumed(t) : "readyforpostroll" === e ? this.onReadyForPostroll(t) : "playing" === e ? this.onPlaying(t) : "ended" === e ? this.onEnded(t) : "nopreroll" === e ? this.onNoPreroll(t) : "nopostroll" === e ? this.onNoPostroll(t) : "adended" === e && this.onAdEnded(t) }, t }(); N.registerState("State", O); var x = function (e) { function t(t) { var n; return (n = e.call(this, t) || this).contentResuming = !1, n.waitingForAdBreak = !1, n } p(t, e); var n = t.prototype; return n.isAdState = function () { return !0 }, n.onPlaying = function () { var e = N.getState("ContentPlayback"); this.contentResuming && this.transitionTo(e) }, n.onContentResumed = function () { var e = N.getState("ContentPlayback"); this.contentResuming && this.transitionTo(e) }, n.isWaitingForAdBreak = function () { return this.waitingForAdBreak }, n.isContentResuming = function () { return this.contentResuming }, n.inAdBreak = function () { return !0 === this.player.ads._inLinearAdMode }, t }(O); N.registerState("AdState", x); var D = function (e) { function t() { return e.apply(this, arguments) || this } p(t, e); var n = t.prototype; return n.isAdState = function () { return !1 }, n.onContentChanged = function (e) { var t = N.getState("BeforePreroll"), n = N.getState("Preroll"); e.ads.debug("Received contentchanged event (ContentState)"), e.paused() ? this.transitionTo(t) : (this.transitionTo(n, !1), e.pause(), e.ads._pausedOnContentupdate = !0) }, t }(O); N.registerState("ContentState", D); var F, U = function (t) { function n() { return t.apply(this, arguments) || this } p(n, t), n._getName = function () { return "AdsDone" }; var a = n.prototype; return a.init = function (e) { e.ads._contentHasEnded = !0, e.trigger("ended") }, a.startLinearAdMode = function () { e.log.warn("Unexpected startLinearAdMode invocation (AdsDone)") }, n }(N.getState("ContentState")); N.registerState("AdsDone", U); var V = { start: function (t) { t.ads.debug("Starting ad break"), t.ads._inLinearAdMode = !0, t.trigger("adstart"), t.ads.shouldTakeSnapshots() && (t.ads.snapshot = function (t) { var n; n = e.browser.IS_IOS && t.ads.isLive(t) && t.seekable().length > 0 ? t.currentTime() - t.seekable().end(0) : t.currentTime(); var a = t.$(".vjs-tech"), r = t.textTracks ? t.textTracks() : [], o = [], i = { ended: t.ended(), currentSrc: t.currentSrc(), sources: t.currentSources(), src: t.tech_.src(), currentTime: n, type: t.currentType() }; a && (i.style = a.getAttribute("style")); for (var s = 0; s < r.length; s++) { var d = r[s]; o.push({ track: d, mode: d.mode }), d.mode = "disabled" } return i.suppressedTracks = o, i }(t)), t.ads.shouldPlayContentBehindAd(t) && (t.ads.preAdVolume_ = t.volume(), t.volume(0)), t.addClass("vjs-ad-playing"), t.hasClass("vjs-live") && t.removeClass("vjs-live"), t.ads.removeNativePoster(), t.ads.preAdPlaybackRate_ = t.playbackRate(), t.playbackRate(1), t.controlBar && t.controlBar.playbackRateMenuButton && t.controlBar.playbackRateMenuButton.playbackRateSupported && !t.controlBar.playbackRateMenuButton.hasClass("vjs-hidden") ? (t.controlBar.playbackRateMenuButton.hide(), t.ads.showPlaybackMenuOnAdEnd_ = !0) : t.ads.showPlaybackMenuOnAdEnd_ = !1 }, end: function (t, n) { t.ads.debug("Ending ad break"), void 0 === n && (n = function () { }), t.ads.adType = null, t.ads._inLinearAdMode = !1, t.trigger("adend"), t.removeClass("vjs-ad-playing"), t.ads.isLive(t) && t.addClass("vjs-live"), t.ads.shouldTakeSnapshots() ? function (t, n) { var a = t.ads.snapshot; if (void 0 === n && (n = function () { }), !0 === t.ads.disableNextSnapshotRestore) return t.ads.disableNextSnapshotRestore = !1, delete t.ads.snapshot, void n(); var r, o = t.$(".vjs-tech"), i = 20, s = a.suppressedTracks, d = function () { for (var e = 0; e < s.length; e++)(r = s[e]).track.mode = r.mode }, l = function () { var n; if (e.browser.IS_IOS && t.ads.isLive(t)) { if (a.currentTime < 0 && (n = t.seekable().length > 0 ? t.seekable().end(0) + a.currentTime : t.currentTime(), t.currentTime(n)), t.paused()) { var r = t.play(); r && r.catch && r.catch(function (t) { e.log.warn("Play promise rejected in IOS snapshot resume", t) }) } } else if (a.ended) t.currentTime(t.duration()); else { t.currentTime(a.currentTime); var o = t.play(); o && o.catch && o.catch(function (t) { e.log.warn("Play promise rejected in snapshot resume", t) }) } t.ads.shouldRemoveAutoplay_ && (t.autoplay(!1), t.ads.shouldRemoveAutoplay_ = !1) }, u = function n() { if (t.off("contentcanplay", n), F && t.clearTimeout(F), (o = t.el().querySelector(".vjs-tech")).readyState > 1) return l(); if (void 0 === o.seekable) return l(); if (o.seekable.length > 0) return l(); if (i--) t.setTimeout(n, 50); else try { l() } catch (t) { e.log.warn("Failed to resume the content after an advertisement", t) } }; if ("style" in a && o.setAttribute("style", a.style || ""), t.ads.videoElementRecycled()) t.one("resumeended", function () { delete t.ads.snapshot, n() }), t.one("contentloadedmetadata", d), e.browser.IS_IOS && !t.autoplay() && (t.autoplay(!0), t.ads.shouldRemoveAutoplay_ = !0), t.src(a.sources), t.one("contentcanplay", u), F = t.setTimeout(u, 2e3); else { if (d(), !t.ended()) { var c = t.play(); c && c.catch && c.catch(function (t) { e.log.warn("Play promise rejected in snapshot restore", t) }) } delete t.ads.snapshot, n() } }(t, n) : (t.volume(t.ads.preAdVolume_), n()), t.playbackRate(t.ads.preAdPlaybackRate_), t.ads.showPlaybackMenuOnAdEnd_ && t.controlBar.playbackRateMenuButton.show() } }, q = function (t) { function n() { return t.apply(this, arguments) || this } p(n, t), n._getName = function () { return "Preroll" }; var a = n.prototype; return a.init = function (e, t, n) { if (this.waitingForAdBreak = !0, e.addClass("vjs-ad-loading"), n || e.ads.nopreroll_) return this.resumeAfterNoPreroll(e); var a = e.ads.settings.timeout; "number" == typeof e.ads.settings.prerollTimeout && (a = e.ads.settings.prerollTimeout), this._timeout = e.setTimeout(function () { e.trigger("adtimeout") }, a), t ? this.handleAdsReady() : this.adsReady = !1 }, a.onAdsReady = function (t) { t.ads.inAdBreak() ? e.log.warn("Unexpected adsready event (Preroll)") : (t.ads.debug("Received adsready event (Preroll)"), this.handleAdsReady()) }, a.handleAdsReady = function () { this.adsReady = !0, this.readyForPreroll() }, a.afterLoadStart = function (e) { var t = this.player; t.ads._hasThereBeenALoadStartDuringPlayerLife ? e() : (t.ads.debug("Waiting for loadstart..."), t.one("loadstart", function () { t.ads.debug("Received loadstart event"), e() })) }, a.noPreroll = function () { var e = this; this.afterLoadStart(function () { e.player.ads.debug("Skipping prerolls due to nopreroll event (Preroll)"), e.resumeAfterNoPreroll(e.player) }) }, a.readyForPreroll = function () { var e = this.player; this.afterLoadStart(function () { e.ads.debug("Triggered readyforpreroll event (Preroll)"), e.trigger("readyforpreroll") }) }, a.onAdsCanceled = function (e) { var t = this; e.ads.debug("adscanceled (Preroll)"), this.afterLoadStart(function () { t.resumeAfterNoPreroll(e) }) }, a.onAdsError = function (t) { var n = this; e.log("adserror (Preroll)"), this.inAdBreak() ? t.ads.endLinearAdMode() : this.afterLoadStart(function () { n.resumeAfterNoPreroll(t) }) }, a.startLinearAdMode = function () { var t = this.player; !this.adsReady || t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected startLinearAdMode invocation (Preroll)") : (this.clearTimeout(t), t.ads.adType = "preroll", this.waitingForAdBreak = !1, V.start(t), t.ads._shouldBlockPlay = !1) }, a.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, a.endLinearAdMode = function () { var e = this.player; this.inAdBreak() && (e.removeClass("vjs-ad-loading"), e.addClass("vjs-ad-content-resuming"), this.contentResuming = !0, V.end(e)) }, a.skipLinearAdMode = function () { var t = this, n = this.player; n.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected skipLinearAdMode invocation") : this.afterLoadStart(function () { n.trigger("adskip"), n.ads.debug("skipLinearAdMode (Preroll)"), t.resumeAfterNoPreroll(n) }) }, a.onAdTimeout = function (e) { var t = this; this.afterLoadStart(function () { e.ads.debug("adtimeout (Preroll)"), t.resumeAfterNoPreroll(e) }) }, a.onNoPreroll = function (t) { t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected nopreroll event (Preroll)") : this.noPreroll() }, a.resumeAfterNoPreroll = function (e) { if (this.contentResuming = !0, e.ads._shouldBlockPlay = !1, this.cleanupPartial(e), e.ads._playRequested || e.ads._pausedOnContentupdate) if (e.paused()) { e.ads.debug("resumeAfterNoPreroll: attempting to resume playback (Preroll)"); var t = e.play(); t && t.then && t.then(null, function (e) { }) } else e.ads.debug("resumeAfterNoPreroll: already playing (Preroll)"), e.trigger("play"), e.trigger("playing") }, a.cleanup = function (t) { t.ads._hasThereBeenALoadStartDuringPlayerLife || e.log.warn("Leaving Preroll state before loadstart event can cause issues."), this.cleanupPartial(t) }, a.cleanupPartial = function (e) { e.removeClass("vjs-ad-loading"), e.removeClass("vjs-ad-content-resuming"), this.clearTimeout(e) }, a.clearTimeout = function (e) { e.clearTimeout(this._timeout), this._timeout = null }, n }(N.getState("AdState")); N.registerState("Preroll", q); var H = function (e) { function t() { return e.apply(this, arguments) || this } p(t, e), t._getName = function () { return "BeforePreroll" }; var n = t.prototype; return n.init = function (e) { this.adsReady = !1, this.shouldResumeToContent = !1, e.ads._shouldBlockPlay = !e.ads.settings.allowVjsAutoplay || !e.autoplay() }, n.onAdsReady = function (e) { e.ads.debug("Received adsready event (BeforePreroll)"), this.adsReady = !0 }, n.onPlay = function (e) { var t = N.getState("Preroll"); e.ads.debug("Received play event (BeforePreroll)"), this.transitionTo(t, this.adsReady, this.shouldResumeToContent) }, n.onAdsCanceled = function (e) { e.ads.debug("adscanceled (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.onAdsError = function () { this.player.ads.debug("adserror (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.onNoPreroll = function () { this.player.ads.debug("Skipping prerolls due to nopreroll event (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.skipLinearAdMode = function () { var e = this.player; e.trigger("adskip"), e.ads.debug("skipLinearAdMode (BeforePreroll)"), this.shouldResumeToContent = !0 }, n.onContentChanged = function () { this.init(this.player) }, t }(N.getState("ContentState")); N.registerState("BeforePreroll", H); var W = function (e) { function t() { return e.apply(this, arguments) || this } p(t, e), t._getName = function () { return "Midroll" }; var n = t.prototype; return n.init = function (e) { e.ads.adType = "midroll", V.start(e), e.addClass("vjs-ad-loading") }, n.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, n.endLinearAdMode = function () { var e = this.player; this.inAdBreak() && (this.contentResuming = !0, e.addClass("vjs-ad-content-resuming"), e.removeClass("vjs-ad-loading"), V.end(e)) }, n.onAdsError = function (e) { this.inAdBreak() && e.ads.endLinearAdMode() }, n.cleanup = function (e) { e.removeClass("vjs-ad-loading"), e.removeClass("vjs-ad-content-resuming") }, t }(N.getState("AdState")); N.registerState("Midroll", W); var z = function (t) { function n() { return t.apply(this, arguments) || this } p(n, t), n._getName = function () { return "Postroll" }; var a = n.prototype; return a.init = function (e) { if (this.waitingForAdBreak = !0, e.ads._contentEnding = !0, e.ads.nopostroll_) { this.resumeContent(e); var t = N.getState("AdsDone"); this.transitionTo(t) } else { e.addClass("vjs-ad-loading"); var n = e.ads.settings.timeout; "number" == typeof e.ads.settings.postrollTimeout && (n = e.ads.settings.postrollTimeout), this._postrollTimeout = e.setTimeout(function () { e.trigger("adtimeout") }, n) } }, a.startLinearAdMode = function () { var t = this.player; t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected startLinearAdMode invocation (Postroll)") : (t.ads.adType = "postroll", t.clearTimeout(this._postrollTimeout), this.waitingForAdBreak = !1, V.start(t)) }, a.onAdStarted = function (e) { e.removeClass("vjs-ad-loading") }, a.endLinearAdMode = function () { var e = this, t = this.player, n = N.getState("AdsDone"); this.inAdBreak() && (t.removeClass("vjs-ad-loading"), this.resumeContent(t), V.end(t, function () { e.transitionTo(n) })) }, a.skipLinearAdMode = function () { var t = this.player; t.ads.inAdBreak() || this.isContentResuming() ? e.log.warn("Unexpected skipLinearAdMode invocation") : (t.ads.debug("Postroll abort (skipLinearAdMode)"), t.trigger("adskip"), this.abort(t)) }, a.onAdTimeout = function (e) { e.ads.debug("Postroll abort (adtimeout)"), this.abort(e) }, a.onAdsError = function (e) { e.ads.debug("Postroll abort (adserror)"), e.ads.inAdBreak() ? e.ads.endLinearAdMode() : this.abort(e) }, a.onContentChanged = function (e) { if (this.isContentResuming()) { var t = N.getState("BeforePreroll"); this.transitionTo(t) } else if (!this.inAdBreak()) { var n = N.getState("Preroll"); this.transitionTo(n) } }, a.onNoPostroll = function (t) { this.isContentResuming() || this.inAdBreak() ? e.log.warn("Unexpected nopostroll event (Postroll)") : this.abort(t) }, a.resumeContent = function (e) { this.contentResuming = !0, e.addClass("vjs-ad-content-resuming") }, a.abort = function (e) { var t = N.getState("AdsDone"); this.resumeContent(e), e.removeClass("vjs-ad-loading"), this.transitionTo(t) }, a.cleanup = function (e) { e.removeClass("vjs-ad-content-resuming"), e.clearTimeout(this._postrollTimeout), e.ads._contentEnding = !1 }, n }(N.getState("AdState")); N.registerState("Postroll", z); var $ = function (e) { function t() { return e.apply(this, arguments) || this } p(t, e), t._getName = function () { return "ContentPlayback" }; var n = t.prototype; return n.init = function (e) { e.ads._shouldBlockPlay = !1 }, n.onAdsReady = function (e) { e.ads.debug("Received adsready event (ContentPlayback)"), e.ads.nopreroll_ || (e.ads.debug("Triggered readyforpreroll event (ContentPlayback)"), e.trigger("readyforpreroll")) }, n.onReadyForPostroll = function (e) { var t = N.getState("Postroll"); e.ads.debug("Received readyforpostroll event"), this.transitionTo(t) }, n.startLinearAdMode = function () { var e = N.getState("Midroll"); this.transitionTo(e) }, t }(N.getState("ContentState")); N.registerState("ContentPlayback", $); var J = function (e) { function t() { return e.apply(this, arguments) || this } p(t, e), t._getName = function () { return "StitchedContentPlayback" }; var n = t.prototype; return n.init = function () { this.player.ads._shouldBlockPlay = !1 }, n.onContentChanged = function () { this.player.ads.debug("Received contentchanged event (" + this.constructor._getName() + ")") }, n.startLinearAdMode = function () { var e = N.getState("StitchedAdRoll"); this.transitionTo(e) }, t }(N.getState("ContentState")); N.registerState("StitchedContentPlayback", J); var Y = function (e) { function t() { return e.apply(this, arguments) || this } p(t, e), t._getName = function () { return "StitchedAdRoll" }; var n = t.prototype; return n.init = function () { this.waitingForAdBreak = !1, this.contentResuming = !1, this.player.ads.adType = "stitched", V.start(this.player) }, n.onPlaying = function () { }, n.onContentResumed = function () { }, n.onAdEnded = function () { this.endLinearAdMode(), this.player.trigger("ended") }, n.endLinearAdMode = function () { var e = N.getState("StitchedContentPlayback"); V.end(this.player), this.transitionTo(e) }, t }(N.getState("AdState")); N.registerState("StitchedAdRoll", Y); var G = M.isMiddlewareMediatorSupported, K = e.getTech("Html5").Events, Q = { timeout: 5e3, prerollTimeout: void 0, postrollTimeout: void 0, debug: !1, stitchedAds: !1, contentIsLive: void 0, liveCuePoints: !0, allowVjsAutoplay: e.options.normalizeAutoplay || !1 }, X = function (t) { var n = this, r = e.obj.merge(Q, t), o = []; K.concat(["firstplay", "loadedalldata"]).forEach(function (e) { -1 === o.indexOf(e) && o.push(e) }), n.on(o, u), G() || function (t, n) { n && e.log("Using cancelContentPlay to block content playback"), t.on("play", B) }(n, r.debug), n.setTimeout(function () { n.ads._hasThereBeenALoadStartDuringPlayerLife || "" === n.src() || e.log.error("tm_videojs-contrib-ads has not seen a loadstart event 5 seconds after being initialized, but a source is present. This indicates that tm_videojs-contrib-ads was initialized too late. It must be initialized immediately after video.js in the same tick. As a result, some ads will not play and some media events will be incorrect. For more information, see http://tm_videojs.github.io/tm_videojs-contrib-ads/integrator/getting-started.html") }, 5e3), n.on("ended", function () { n.hasClass("vjs-has-started") || n.addClass("vjs-has-started") }), n.on("contenttimeupdate", function () { n.removeClass("vjs-waiting") }), n.on(["addurationchange", "adcanplay"], function () { if (!n.ads.settings.stitchedAds && !n.hasStarted() && (!n.ads.snapshot || n.currentSrc() !== n.ads.snapshot.currentSrc) && n.ads.inAdBreak()) { var t = n.play(); t && t.catch && t.catch(function (t) { e.log.warn("Play promise rejected when playing ad", t) }) } }), n.on("nopreroll", function () { n.ads.debug("Received nopreroll event"), n.ads.nopreroll_ = !0 }), n.on("nopostroll", function () { n.ads.debug("Received nopostroll event"), n.ads.nopostroll_ = !0 }), n.on("playing", function () { n.ads._cancelledPlay = !1, n.ads._pausedOnContentupdate = !1 }), n.on("play", function () { n.ads._playRequested = !0 }), n.one("loadstart", function () { n.ads._hasThereBeenALoadStartDuringPlayerLife = !0 }), n.on("loadeddata", function () { n.ads._hasThereBeenALoadedData = !0 }), n.on("loadedmetadata", function () { n.ads._hasThereBeenALoadedMetaData = !0 }), n.ads = function (t) { return { disableNextSnapshotRestore: !1, _contentEnding: !1, _contentHasEnded: !1, _hasThereBeenALoadStartDuringPlayerLife: !1, _hasThereBeenALoadedData: !1, _hasThereBeenALoadedMetaData: !1, _inLinearAdMode: !1, _shouldBlockPlay: !1, _playBlocked: !1, _playRequested: !1, adType: null, VERSION: a, reset: function () { t.ads.disableNextSnapshotRestore = !1, t.ads._contentEnding = !1, t.ads._contentHasEnded = !1, t.ads.snapshot = null, t.ads.adType = null, t.ads._hasThereBeenALoadedData = !1, t.ads._hasThereBeenALoadedMetaData = !1, t.ads._cancelledPlay = !1, t.ads._shouldBlockPlay = !1, t.ads._playBlocked = !1, t.ads.nopreroll_ = !1, t.ads.nopostroll_ = !1, t.ads._playRequested = !1 }, startLinearAdMode: function () { t.ads._state.startLinearAdMode() }, endLinearAdMode: function () { t.ads._state.endLinearAdMode() }, skipLinearAdMode: function () { t.ads._state.skipLinearAdMode() }, stitchedAds: function (t) { return void 0 !== t && (e.log.warn("Using player.ads.stitchedAds() as a setter is deprecated, it should be set as an option upon initialization of contrib-ads."), this.settings.stitchedAds = !!t), this.settings.stitchedAds }, videoElementRecycled: function () { if (t.ads.shouldPlayContentBehindAd(t)) return !1; if (!this.snapshot) throw new Error("You cannot use videoElementRecycled while there is no snapshot."); var e = t.tech_.src() !== this.snapshot.src, n = t.currentSrc() !== this.snapshot.currentSrc; return e || n }, isLive: function (n) { return void 0 === n && (n = t), "boolean" == typeof n.ads.settings.contentIsLive ? n.ads.settings.contentIsLive : n.duration() === 1 / 0 || "8" === e.browser.IOS_VERSION && 0 === n.duration() }, shouldPlayContentBehindAd: function (n) { if (void 0 === n && (n = t), n) return !!n.ads.settings.liveCuePoints && !e.browser.IS_IOS && !e.browser.IS_ANDROID && n.duration() === 1 / 0; throw new Error("shouldPlayContentBehindAd requires a player as a param") }, shouldTakeSnapshots: function (e) { return void 0 === e && (e = t), !this.shouldPlayContentBehindAd(e) && !this.stitchedAds() }, isInAdMode: function () { return this._state.isAdState() }, isWaitingForAdBreak: function () { return this._state.isWaitingForAdBreak() }, isContentResuming: function () { return this._state.isContentResuming() }, isAdPlaying: function () { return this._state.inAdBreak() }, inAdBreak: function () { return this._state.inAdBreak() }, removeNativePoster: function () { var e = t.$(".vjs-tech"); e && e.removeAttribute("poster") }, debug: function () { if (this.settings.debug) { for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)n[a] = arguments[a]; 1 === n.length && "string" == typeof n[0] ? e.log("ADS: " + n[0]) : e.log.apply(e, ["ADS:"].concat(n)) } } } }(n), n.ads.settings = r, r.stitchedAds = !!r.stitchedAds, r.stitchedAds ? n.ads._state = new (N.getState("StitchedContentPlayback"))(n) : n.ads._state = new (N.getState("BeforePreroll"))(n), n.ads._state.init(n), n.ads.cueTextTracks = T, n.ads.adMacroReplacement = function (e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = {}); var a = n.disableDefaultMacros || !1, r = n.macroNameOverrides || {}; delete n.disableDefaultMacros, delete n.macroNameOverrides; var o = n; if (a) return C(e, o, t, r); var i = _(e), s = i.defaults, d = i.modifiedString; for (var l in e = d, c(o, S(this), A(this.mediainfo, s), b(h), k(), P(e, s, r)), e = C(e, o, t, r), s) e = e.replace(l, s[l]); return e }.bind(n), function (e) { e.ads.contentSrc = e.currentSrc(), e.ads._seenInitialLoadstart = !1, e.on("loadstart", function () { if (!e.ads.inAdBreak()) { var t = e.currentSrc(); t !== e.ads.contentSrc && (e.ads._seenInitialLoadstart && e.trigger({ type: "contentchanged" }), e.trigger({ type: "contentupdate", oldValue: e.ads.contentSrc, newValue: t }), e.ads.contentSrc = t), e.ads._seenInitialLoadstart = !0 } }) }(n), n.on("contentchanged", n.ads.reset); var i = function () { var t = n.textTracks(); if (!n.ads.shouldPlayContentBehindAd(n) && n.ads.inAdBreak() && n.tech_.featuresNativeTextTracks && e.browser.IS_IOS && !Array.isArray(n.textTracks())) for (var a = 0; a < t.length; a++) { var r = t[a]; "showing" === r.mode && (r.mode = "disabled") } }; n.ready(function () { n.textTracks().addEventListener("change", i) }), n.on(["play", "playing", "ended", "adsready", "adscanceled", "adskip", "adserror", "adtimeout", "adended", "ads-ad-started", "ads-ad-skipped", "contentchanged", "dispose", "contentresumed", "readyforpostroll", "nopreroll", "nopostroll"], function (e) { n.ads._state.handleEvent(e.type) }), n.on("dispose", function () { n.ads.reset(), n.textTracks().removeEventListener("change", i) }), g(), v(function () { }), n.ads.listenToTcf = g, n.ads.updateUsPrivacyString = function (e) { return v(e) } }; return X.VERSION = a, function (t) { !I(e) && ((e.registerPlugin || e.plugin)("ads", t), E() && !e.usingContribAdsMiddleware_ && (e.use("*", j), e.usingContribAdsMiddleware_ = !0, e.log.debug("Play middleware has been registered with tm_videojs"))) }(X), X });


(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('video.js')) :
    typeof define === 'function' && define.amd ? define(['exports', 'video.js'], factory) :
      (factory((global.tm_videojsIma = {}), global.tm_videojs));
}(this, (function (exports, tm_videojs) {
  'use strict';

  tm_videojs = tm_videojs && tm_videojs.hasOwnProperty('default') ? tm_videojs['default'] : tm_videojs;




  /**
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */

  /**
   * Wraps the video.js player for the plugin.
   *
   * @param {Object} player Video.js player instance.
   * @param {Object} adsPluginSettings Settings for the contrib-ads plugin.
   * @param {Controller} controller Reference to the parent controller.
   */
  var PlayerWrapper = function PlayerWrapper(player, adsPluginSettings, controller) {
    /**
     * Instance of the video.js player.
     */
    this.vjsPlayer = player;

    /**
     * Plugin controller.
     */
    this.controller = controller;

    /**
     * Timer used to track content progress.
     */
    this.contentTrackingTimer = null;

    /**
     * True if our content video has completed, false otherwise.
     */
    this.contentComplete = false;

    /**
     * Handle to interval that repeatedly updates current time.
     */
    this.updateTimeIntervalHandle = null;

    /**
     * Interval (ms) to check for player resize for fluid support.
     */
    this.updateTimeInterval = 1000;

    /**
     * Handle to interval that repeatedly checks for seeking.
     */
    this.seekCheckIntervalHandle = null;

    /**
     * Interval (ms) on which to check if the user is seeking through the
     * content.
     */
    this.seekCheckInterval = 1000;

    /**
     * Handle to interval that repeatedly checks for player resize.
     */
    this.resizeCheckIntervalHandle = null;

    /**
     * Interval (ms) to check for player resize for fluid support.
     */
    this.resizeCheckInterval = 250;

    /**
     * Threshold by which to judge user seeking. We check every 1000 ms to see
     * if the user is seeking. In order for us to decide that they are *not*
     * seeking, the content video playhead must only change by 900-1100 ms
     * between checks. Any greater change and we assume the user is seeking
     * through the video.
     */
    this.seekThreshold = 100;

    /**
     * Content ended listeners passed by the publisher to the plugin. Publishers
     * should allow the plugin to handle content ended to ensure proper support
     * of custom ad playback.
     */
    this.contentEndedListeners = [];

    /**
     * Stores the content source so we can re-populate it manually after a
     * post-roll on iOS.
     */
    this.contentSource = '';

    /**
     * Stores the content source type so we can re-populate it manually after a
     * post-roll.
     */
    this.contentSourceType = '';

    /**
     * Stores data for the content playhead tracker.
     */
    this.contentPlayheadTracker = {
      currentTime: 0,
      previousTime: 0,
      seeking: false,
      duration: 0
    };

    /**
     * Player dimensions. Used in our resize check.
     */
    this.vjsPlayerDimensions = {
      width: this.getPlayerWidth(),
      height: this.getPlayerHeight()
    };

    /**
     * Video.js control bar.
     */
    this.vjsControls = this.vjsPlayer.getChild('controlBar');

    /**
     * Vanilla HTML5 video player underneath the video.js player.
     */
    this.h5Player = null;

    this.vjsPlayer.one('play', this.setUpPlayerIntervals.bind(this));
    this.boundContentEndedListener = this.localContentEndedListener.bind(this);
    this.vjsPlayer.on('contentended', this.boundContentEndedListener);
    this.vjsPlayer.on('dispose', this.playerDisposedListener.bind(this));
    this.vjsPlayer.on('readyforpreroll', this.onReadyForPreroll.bind(this));
    this.vjsPlayer.on('adtimeout', this.onAdTimeout.bind(this));
    this.vjsPlayer.ready(this.onPlayerReady.bind(this));

    if (this.controller.getSettings().requestMode === 'onPlay') {
      this.vjsPlayer.one('play', this.controller.requestAds.bind(this.controller));
    }

    if (!this.vjsPlayer.ads) {
      window.console.warn('You may be using a version of tm_videojs-contrib-ads ' + 'that is not compatible with your version of video.js.');
    }
    this.vjsPlayer.ads(adsPluginSettings);
  };

  /**
   * Set up the intervals we use on the player.
   */
  PlayerWrapper.prototype.setUpPlayerIntervals = function () {
    this.updateTimeIntervalHandle = setInterval(this.updateCurrentTime.bind(this), this.updateTimeInterval);
    this.seekCheckIntervalHandle = setInterval(this.checkForSeeking.bind(this), this.seekCheckInterval);
    this.resizeCheckIntervalHandle = setInterval(this.checkForResize.bind(this), this.resizeCheckInterval);
  };

  /**
   * Updates the current time of the video
   */
  PlayerWrapper.prototype.updateCurrentTime = function () {
    if (!this.contentPlayheadTracker.seeking) {
      this.contentPlayheadTracker.currentTime = this.vjsPlayer.currentTime();
    }
  };

  /**
   * Detects when the user is seeking through a video.
   * This is used to prevent mid-rolls from playing while a user is seeking.
   *
   * There *is* a seeking property of the HTML5 video element, but it's not
   * properly implemented on all platforms (e.g. mobile safari), so we have to
   * check ourselves to be sure.
   */
  PlayerWrapper.prototype.checkForSeeking = function () {
    var tempCurrentTime = this.vjsPlayer.currentTime();
    var diff = (tempCurrentTime - this.contentPlayheadTracker.previousTime) * 1000;
    if (Math.abs(diff) > this.seekCheckInterval + this.seekThreshold) {
      this.contentPlayheadTracker.seeking = true;
    } else {
      this.contentPlayheadTracker.seeking = false;
    }
    this.contentPlayheadTracker.previousTime = this.vjsPlayer.currentTime();
  };

  /**
   * Detects when the player is resized (for fluid support) and resizes the
   * ads manager to match.
   */
  PlayerWrapper.prototype.checkForResize = function () {
    var currentWidth = this.getPlayerWidth();
    var currentHeight = this.getPlayerHeight();

    if (currentWidth != this.vjsPlayerDimensions.width || currentHeight != this.vjsPlayerDimensions.height) {
      this.vjsPlayerDimensions.width = currentWidth;
      this.vjsPlayerDimensions.height = currentHeight;
      this.controller.onPlayerResize(currentWidth, currentHeight);
    }
  };

  /**
   * Local content ended listener for contentComplete.
   */
  PlayerWrapper.prototype.localContentEndedListener = function () {
    if (!this.contentComplete) {
      this.contentComplete = true;
      this.controller.onContentComplete();
    }

    for (var index in this.contentEndedListeners) {
      if (typeof this.contentEndedListeners[index] === 'function') {
        this.contentEndedListeners[index]();
      }
    }

    clearInterval(this.updateTimeIntervalHandle);
    clearInterval(this.seekCheckIntervalHandle);
    clearInterval(this.resizeCheckIntervalHandle);
    if (this.vjsPlayer.el()) {
      this.vjsPlayer.one('play', this.setUpPlayerIntervals.bind(this));
    }
  };

  /**
   * Called when it's time to play a post-roll but we don't have one to play.
   */
  PlayerWrapper.prototype.onNoPostroll = function () {
    this.vjsPlayer.trigger('nopostroll');
  };

  /**
   * Detects when the video.js player has been disposed.
   */
  PlayerWrapper.prototype.playerDisposedListener = function () {
    this.contentEndedListeners = [];
    this.controller.onPlayerDisposed();

    this.contentComplete = true;
    this.vjsPlayer.off('contentended', this.boundContentEndedListener);

    // Bug fix: https://github.com/googleads/tm_videojs-ima/issues/306
    if (this.vjsPlayer.ads.adTimeoutTimeout) {
      clearTimeout(this.vjsPlayer.ads.adTimeoutTimeout);
    }

    var intervalsToClear = [this.updateTimeIntervalHandle, this.seekCheckIntervalHandle, this.resizeCheckIntervalHandle];
    for (var index in intervalsToClear) {
      if (intervalsToClear[index]) {
        clearInterval(intervalsToClear[index]);
      }
    }
  };

  /**
   * Start ad playback, or content video playback in the absence of a
   * pre-roll.
   */
  PlayerWrapper.prototype.onReadyForPreroll = function () {
    this.controller.onPlayerReadyForPreroll();
  };

  /**
   * Detects if the ad has timed out.
   */
  PlayerWrapper.prototype.onAdTimeout = function () {
    this.controller.onAdTimeout();
  };

  /**
   * Called when the player fires its 'ready' event.
   */
  PlayerWrapper.prototype.onPlayerReady = function () {
    this.h5Player = document.getElementById(this.getPlayerId()).getElementsByClassName('vjs-tech')[0];

    // Detect inline options
    if (this.h5Player.hasAttribute('autoplay')) {
      this.controller.setSetting('adWillAutoPlay', true);
    }

    // Sync ad volume with player volume.
    this.onVolumeChange();
    this.vjsPlayer.on('fullscreenchange', this.onFullscreenChange.bind(this));
    this.vjsPlayer.on('volumechange', this.onVolumeChange.bind(this));

    this.controller.onPlayerReady();
  };

  /**
   * Listens for the video.js player to change its fullscreen status. This
   * keeps the fullscreen-ness of the AdContainer in sync with the player.
   */
  PlayerWrapper.prototype.onFullscreenChange = function () {
    if (this.vjsPlayer.isFullscreen()) {
      this.controller.onPlayerEnterFullscreen();
    } else {
      this.controller.onPlayerExitFullscreen();
    }
  };

  /**
   * Listens for the video.js player to change its volume. This keeps the ad
   * volume in sync with the content volume if the volume of the player is
   * changed while content is playing.
   */
  PlayerWrapper.prototype.onVolumeChange = function () {
    var newVolume = this.vjsPlayer.muted() ? 0 : this.vjsPlayer.volume();
    this.controller.onPlayerVolumeChanged(newVolume);
  };

  /**
   * Inject the ad container div into the DOM.
   *
   * @param{HTMLElement} adContainerDiv The ad container div.
   */
  PlayerWrapper.prototype.injectAdContainerDiv = function (adContainerDiv) {
    this.vjsControls.el().parentNode.appendChild(adContainerDiv);
  };

  /**
   * @return {Object} The content player.
   */
  PlayerWrapper.prototype.getContentPlayer = function () {
    return this.h5Player;
  };

  /**
   * @return {number} The volume, 0-1.
   */
  PlayerWrapper.prototype.getVolume = function () {
    return this.vjsPlayer.muted() ? 0 : this.vjsPlayer.volume();
  };

  /**
   * Set the volume of the player. 0-1.
   *
   * @param {number} volume The new volume.
   */
  PlayerWrapper.prototype.setVolume = function (volume) {
    this.vjsPlayer.volume(volume);
    if (volume == 0) {
      this.vjsPlayer.muted(true);
    } else {
      this.vjsPlayer.muted(false);
    }
  };

  /**
   * Ummute the player.
   */
  PlayerWrapper.prototype.unmute = function () {
    this.vjsPlayer.muted(false);
  };

  /**
   * Mute the player.
   */
  PlayerWrapper.prototype.mute = function () {
    this.vjsPlayer.muted(true);
  };

  /**
   * Play the video.
   */
  PlayerWrapper.prototype.play = function () {
    this.vjsPlayer.play();
  };

  /**
   * Toggles playback of the video.
   */
  PlayerWrapper.prototype.togglePlayback = function () {
    if (this.vjsPlayer.paused()) {
      this.vjsPlayer.play();
    } else {
      this.vjsPlayer.pause();
    }
  };

  /**
   * Get the player width.
   *
   * @return {number} The player's width.
   */
  PlayerWrapper.prototype.getPlayerWidth = function () {
    var width = (getComputedStyle(this.vjsPlayer.el()) || {}).width;

    if (!width || parseFloat(width) === 0) {
      width = (this.vjsPlayer.el().getBoundingClientRect() || {}).width;
    }

    return parseFloat(width) || this.vjsPlayer.width();
  };

  /**
   * Get the player height.
   *
   * @return {number} The player's height.
   */
  PlayerWrapper.prototype.getPlayerHeight = function () {
    var height = (getComputedStyle(this.vjsPlayer.el()) || {}).height;

    if (!height || parseFloat(height) === 0) {
      height = (this.vjsPlayer.el().getBoundingClientRect() || {}).height;
    }

    return parseFloat(height) || this.vjsPlayer.height();
  };

  /**
   * @return {Object} The vjs player's options object.
   */
  PlayerWrapper.prototype.getPlayerOptions = function () {
    return this.vjsPlayer.options_;
  };

  /**
   * Returns the instance of the player id.
   * @return {string} The player id.
   */
  PlayerWrapper.prototype.getPlayerId = function () {
    return this.vjsPlayer.id();
  };

  /**
   * Toggle fullscreen state.
   */
  PlayerWrapper.prototype.toggleFullscreen = function () {
    if (this.vjsPlayer.isFullscreen()) {
      this.vjsPlayer.exitFullscreen();
    } else {
      this.vjsPlayer.requestFullscreen();
    }
  };

  /**
   * Returns the content playhead tracker.
   *
   * @return {Object} The content playhead tracker.
   */
  PlayerWrapper.prototype.getContentPlayheadTracker = function () {
    return this.contentPlayheadTracker;
  };

  /**
   * Handles ad errors.
   *
   * @param {Object} adErrorEvent The ad error event thrown by the IMA SDK.
   */
  PlayerWrapper.prototype.onAdError = function (adErrorEvent) {
    this.vjsControls.show();
    var errorMessage = adErrorEvent.getError !== undefined ? adErrorEvent.getError() : adErrorEvent.stack;
    this.vjsPlayer.trigger({
      type: 'adserror', data: {
        AdError: errorMessage,
        AdErrorEvent: adErrorEvent
      }
    });
  };

  /**
   * Handles ad log messages.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the IMA SDK.
   */
  PlayerWrapper.prototype.onAdLog = function (adEvent) {
    var adData = adEvent.getAdData();
    var errorMessage = adData['adError'] !== undefined ? adData['adError'].getMessage() : undefined;
    this.vjsPlayer.trigger({
      type: 'adslog', data: {
        AdError: errorMessage,
        AdEvent: adEvent
      }
    });
  };

  /**
   * Handles ad break starting.
   */
  PlayerWrapper.prototype.onAdBreakStart = function () {
    this.contentSource = this.vjsPlayer.currentSrc();
    this.contentSourceType = this.vjsPlayer.currentType();
    this.vjsPlayer.off('contentended', this.boundContentEndedListener);
    this.vjsPlayer.ads.startLinearAdMode();
    this.vjsControls.hide();
    this.vjsPlayer.pause();
  };

  /**
   * Handles ad break ending.
   */
  PlayerWrapper.prototype.onAdBreakEnd = function () {
    this.vjsPlayer.on('contentended', this.boundContentEndedListener);
    if (this.vjsPlayer.ads.inAdBreak()) {
      this.vjsPlayer.ads.endLinearAdMode();
    }
    this.vjsControls.show();
  };

  /**
   * Handles an individual ad start.
   */
  PlayerWrapper.prototype.onAdStart = function () {
    this.vjsPlayer.trigger('ads-ad-started');
  };

  /**
   * Handles when all ads have finished playing.
   */
  PlayerWrapper.prototype.onAllAdsCompleted = function () {
    if (this.contentComplete == true) {
      // The null check on this.contentSource was added to fix
      // an error when the post-roll was an empty VAST tag.
      if (this.contentSource && this.vjsPlayer.currentSrc() != this.contentSource) {
        this.vjsPlayer.src({
          src: this.contentSource,
          type: this.contentSourceType
        });
      }
      this.controller.onContentAndAdsCompleted();
    }
  };

  /**
   * Triggers adsready for contrib-ads.
   */
  PlayerWrapper.prototype.onAdsReady = function () {
    this.vjsPlayer.trigger('adsready');
  };

  /**
   * Changes the player source.
   * @param {?string} contentSrc The URI for the content to be played. Leave
   *     blank to use the existing content.
   */
  PlayerWrapper.prototype.changeSource = function (contentSrc) {
    // Only try to pause the player when initialised with a source already
    if (this.vjsPlayer.currentSrc()) {
      this.vjsPlayer.currentTime(0);
      this.vjsPlayer.pause();
    }
    if (contentSrc) {
      this.vjsPlayer.src(contentSrc);
    }
    this.vjsPlayer.one('loadedmetadata', this.seekContentToZero.bind(this));
  };

  /**
   * Seeks content to 00:00:00. This is used as an event handler for the
   * loadedmetadata event, since seeking is not possible until that event has
   * fired.
   */
  PlayerWrapper.prototype.seekContentToZero = function () {
    this.vjsPlayer.currentTime(0);
  };

  /**
   * Triggers an event on the VJS player
   * @param  {string} name The event name.
   * @param  {Object} data The event data.
   */
  PlayerWrapper.prototype.triggerPlayerEvent = function (name, data) {
    this.vjsPlayer.trigger(name, data);
  };

  /**
   * Listener JSDoc for ESLint. This listener can be passed to
   * addContentEndedListener.
   * @callback listener
   */

  /**
   * Adds a listener for the 'contentended' event of the video player. This should
   * be used instead of setting an 'contentended' listener directly to ensure that
   * the ima can do proper cleanup of the SDK before other event listeners are
   * called.
   * @param {listener} listener The listener to be called when content
   *     completes.
   */
  PlayerWrapper.prototype.addContentEndedListener = function (listener) {
    this.contentEndedListeners.push(listener);
  };

  /**
   * Reset the player.
   */
  PlayerWrapper.prototype.reset = function () {
    // Attempts to remove the contentEndedListener before adding it.
    // This is to prevent an error where an erroring video caused multiple
    // contentEndedListeners to be added.
    this.vjsPlayer.off('contentended', this.boundContentEndedListener);

    this.vjsPlayer.on('contentended', this.boundContentEndedListener);
    this.vjsControls.show();
    if (this.vjsPlayer.ads.inAdBreak()) {
      this.vjsPlayer.ads.endLinearAdMode();
    }
    // Reset the content time we give the SDK. Fixes an issue where requesting
    // VMAP followed by VMAP would play the second mid-rolls as pre-rolls if
    // the first playthrough of the video passed the second response's
    // mid-roll time.
    this.contentPlayheadTracker.currentTime = 0;
    this.contentComplete = false;
  };

  /**
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */

  /**
   * Ad UI implementation.
   *
   * @param {Controller} controller Plugin controller.
   * @constructor
   * @struct
   * @final
   */
  var AdUi = function AdUi(controller) {
    /**
     * Plugin controller.
     */
    this.controller = controller;

    /**
     * Div used as an ad container.
     */
    this.adContainerDiv = document.createElement('div');

    /**
     * Div used to display ad controls.
     */
    this.controlsDiv = document.createElement('div');

    /**
     * Div used to display ad countdown timer.
     */
    this.countdownDiv = document.createElement('div');

    /**
     * Div used to display add seek bar.
     */
    this.seekBarDiv = document.createElement('div');

    /**
     * Div used to display ad progress (in seek bar).
     */
    this.progressDiv = document.createElement('div');

    /**
     * Div used to display ad play/pause button.
     */
    this.playPauseDiv = document.createElement('div');

    /**
     * Div used to display ad mute button.
     */
    this.muteDiv = document.createElement('div');

    /**
     * Div used by the volume slider.
     */
    this.sliderDiv = document.createElement('div');

    /**
     * Volume slider level visuals
     */
    this.sliderLevelDiv = document.createElement('div');

    /**
     * Div used to display ad fullscreen button.
     */
    this.fullscreenDiv = document.createElement('div');

    /**
     * Bound event handler for onMouseUp.
     */
    this.boundOnMouseUp = this.onMouseUp.bind(this);

    /**
     * Bound event handler for onMouseMove.
     */
    this.boundOnMouseMove = this.onMouseMove.bind(this);

    /**
     * Stores data for the ad playhead tracker.
     */
    this.adPlayheadTracker = {
      'currentTime': 0,
      'duration': 0,
      'isPod': false,
      'adPosition': 0,
      'totalAds': 0
    };

    /**
     * Used to prefix tm_videojs ima controls.
     */
    this.controlPrefix = this.controller.getPlayerId() + '_';

    /**
     * Boolean flag to show or hide the ad countdown timer.
     */
    this.showCountdown = true;
    if (this.controller.getSettings().showCountdown === false) {
      this.showCountdown = false;
    }

    /**
     * Boolean flag if the current ad is nonlinear.
     */
    this.isAdNonlinear = false;

    this.createAdContainer();
  };

  /**
   * Creates the ad container.
   */
  AdUi.prototype.createAdContainer = function () {
    this.assignControlAttributes(this.adContainerDiv, 'ima-ad-container');
    this.adContainerDiv.style.position = 'absolute';
    this.adContainerDiv.style.zIndex = 1111;
    this.adContainerDiv.addEventListener('mouseenter', this.showAdControls.bind(this), false);
    this.adContainerDiv.addEventListener('mouseleave', this.hideAdControls.bind(this), false);
    this.adContainerDiv.addEventListener('click', this.onAdContainerClick.bind(this), false);
    this.createControls();
    this.controller.injectAdContainerDiv(this.adContainerDiv);
  };

  /**
   * Create the controls.
   */
  AdUi.prototype.createControls = function () {
    this.assignControlAttributes(this.controlsDiv, 'ima-controls-div');
    this.controlsDiv.style.width = '100%';

    if (!this.controller.getIsMobile()) {
      this.assignControlAttributes(this.countdownDiv, 'ima-countdown-div');
      this.countdownDiv.innerHTML = this.controller.getSettings().adLabel;
      this.countdownDiv.style.display = this.showCountdown ? 'block' : 'none';
    } else {
      this.countdownDiv.style.display = 'none';
    }

    this.assignControlAttributes(this.seekBarDiv, 'ima-seek-bar-div');
    this.seekBarDiv.style.width = '100%';

    this.assignControlAttributes(this.progressDiv, 'ima-progress-div');

    this.assignControlAttributes(this.playPauseDiv, 'ima-play-pause-div');
    this.addClass(this.playPauseDiv, 'ima-playing');
    this.playPauseDiv.addEventListener('click', this.onAdPlayPauseClick.bind(this), false);

    this.assignControlAttributes(this.muteDiv, 'ima-mute-div');
    this.addClass(this.muteDiv, 'ima-non-muted');
    this.muteDiv.addEventListener('click', this.onAdMuteClick.bind(this), false);

    this.assignControlAttributes(this.sliderDiv, 'ima-slider-div');
    this.sliderDiv.addEventListener('mousedown', this.onAdVolumeSliderMouseDown.bind(this), false);

    // Hide volume slider controls on iOS as they aren't supported.
    if (this.controller.getIsIos()) {
      this.sliderDiv.style.display = 'none';
    }

    this.assignControlAttributes(this.sliderLevelDiv, 'ima-slider-level-div');

    this.assignControlAttributes(this.fullscreenDiv, 'ima-fullscreen-div');
    this.addClass(this.fullscreenDiv, 'ima-non-fullscreen');
    this.fullscreenDiv.addEventListener('click', this.onAdFullscreenClick.bind(this), false);

    this.adContainerDiv.appendChild(this.controlsDiv);
    this.controlsDiv.appendChild(this.countdownDiv);
    this.controlsDiv.appendChild(this.seekBarDiv);
    this.controlsDiv.appendChild(this.playPauseDiv);
    this.controlsDiv.appendChild(this.muteDiv);
    this.controlsDiv.appendChild(this.sliderDiv);
    this.controlsDiv.appendChild(this.fullscreenDiv);
    this.seekBarDiv.appendChild(this.progressDiv);
    this.sliderDiv.appendChild(this.sliderLevelDiv);
  };

  /**
   * Listener for clicks on the play/pause button during ad playback.
   */
  AdUi.prototype.onAdPlayPauseClick = function () {
    this.controller.onAdPlayPauseClick();
  };

  /**
   * Listener for clicks on the play/pause button during ad playback.
   */
  AdUi.prototype.onAdMuteClick = function () {
    this.controller.onAdMuteClick();
  };

  /**
   * Listener for clicks on the fullscreen button during ad playback.
   */
  AdUi.prototype.onAdFullscreenClick = function () {
    this.controller.toggleFullscreen();
  };

  /**
   * Show pause and hide play button
   */
  AdUi.prototype.onAdsPaused = function () {
    this.controller.sdkImpl.adPlaying = false;
    this.addClass(this.playPauseDiv, 'ima-paused');
    this.removeClass(this.playPauseDiv, 'ima-playing');
    this.showAdControls();
  };

  /**
   * Show pause and hide play button
   */
  AdUi.prototype.onAdsResumed = function () {
    this.onAdsPlaying();
    this.showAdControls();
  };

  /**
   * Show play and hide pause button
   */
  AdUi.prototype.onAdsPlaying = function () {
    this.controller.sdkImpl.adPlaying = true;
    this.addClass(this.playPauseDiv, 'ima-playing');
    this.removeClass(this.playPauseDiv, 'ima-paused');
  };

  /**
   * Takes data from the controller to update the UI.
   *
   * @param {number} currentTime Current time of the ad.
   * @param {number} remainingTime Remaining time of the ad.
   * @param {number} duration Duration of the ad.
   * @param {number} adPosition Index of the ad in the pod.
   * @param {number} totalAds Total number of ads in the pod.
   */
  AdUi.prototype.updateAdUi = function (currentTime, remainingTime, duration, adPosition, totalAds) {
    // Update countdown timer data
    var remainingMinutes = Math.floor(remainingTime / 60);
    var remainingSeconds = Math.floor(remainingTime % 60);
    if (remainingSeconds.toString().length < 2) {
      remainingSeconds = '0' + remainingSeconds;
    }
    var podCount = ': ';
    if (totalAds > 1) {
      podCount = ' (' + adPosition + ' ' + this.controller.getSettings().adLabelNofN + ' ' + totalAds + '): ';
    }
    this.countdownDiv.innerHTML = this.controller.getSettings().adLabel + podCount + remainingMinutes + ':' + remainingSeconds;

    // Update UI
    var playProgressRatio = currentTime / duration;
    var playProgressPercent = playProgressRatio * 100;
    this.progressDiv.style.width = playProgressPercent + '%';
  };

  /**
   * Handles UI changes when the ad is unmuted.
   */
  AdUi.prototype.unmute = function () {
    this.addClass(this.muteDiv, 'ima-non-muted');
    this.removeClass(this.muteDiv, 'ima-muted');
    this.sliderLevelDiv.style.width = this.controller.getPlayerVolume() * 100 + '%';
  };

  /**
   * Handles UI changes when the ad is muted.
   */
  AdUi.prototype.mute = function () {
    this.addClass(this.muteDiv, 'ima-muted');
    this.removeClass(this.muteDiv, 'ima-non-muted');
    this.sliderLevelDiv.style.width = '0%';
  };

  /*
   * Listener for mouse down events during ad playback. Used for volume.
   */
  AdUi.prototype.onAdVolumeSliderMouseDown = function () {
    document.addEventListener('mouseup', this.boundOnMouseUp, false);
    document.addEventListener('mousemove', this.boundOnMouseMove, false);
  };

  /*
   * Mouse movement listener used for volume slider.
   */
  AdUi.prototype.onMouseMove = function (event) {
    this.changeVolume(event);
  };

  /*
   * Mouse release listener used for volume slider.
   */
  AdUi.prototype.onMouseUp = function (event) {
    this.changeVolume(event);
    document.removeEventListener('mouseup', this.boundOnMouseUp);
    document.removeEventListener('mousemove', this.boundOnMouseMove);
  };

  /*
   * Utility function to set volume and associated UI
   */
  AdUi.prototype.changeVolume = function (event) {
    var percent = (event.clientX - this.sliderDiv.getBoundingClientRect().left) / this.sliderDiv.offsetWidth;
    percent *= 100;
    // Bounds value 0-100 if mouse is outside slider region.
    percent = Math.min(Math.max(percent, 0), 100);
    this.sliderLevelDiv.style.width = percent + '%';
    if (this.percent == 0) {
      this.addClass(this.muteDiv, 'ima-muted');
      this.removeClass(this.muteDiv, 'ima-non-muted');
    } else {
      this.addClass(this.muteDiv, 'ima-non-muted');
      this.removeClass(this.muteDiv, 'ima-muted');
    }
    this.controller.setVolume(percent / 100); // 0-1
  };

  /**
   * Show the ad container.
   */
  AdUi.prototype.showAdContainer = function () {
    this.adContainerDiv.style.display = 'block';
  };

  /**
   * Hide the ad container
   */
  AdUi.prototype.hideAdContainer = function () {
    this.adContainerDiv.style.display = 'none';
  };

  /**
   * Handles clicks on the ad container
   */
  AdUi.prototype.onAdContainerClick = function () {
    if (this.isAdNonlinear) {
      this.controller.togglePlayback();
    }
  };

  /**
   * Resets the state of the ad ui.
   */
  AdUi.prototype.reset = function () {
    this.hideAdContainer();
  };

  /**
   * Handles ad errors.
   */
  AdUi.prototype.onAdError = function () {
    this.hideAdContainer();
  };

  /**
   * Handles ad break starting.
   *
   * @param {Object} adEvent The event fired by the IMA SDK.
   */
  AdUi.prototype.onAdBreakStart = function (adEvent) {
    this.showAdContainer();

    var contentType = adEvent.getAd().getContentType();
    if (contentType === 'application/javascript' && !this.controller.getSettings().showControlsForJSAds) {
      this.controlsDiv.style.display = 'none';
    } else {
      this.controlsDiv.style.display = 'block';
    }
    this.onAdsPlaying();
    // Start with the ad controls minimized.
    this.hideAdControls();
  };

  /**
   * Handles ad break ending.
   */
  AdUi.prototype.onAdBreakEnd = function () {
    var currentAd = this.controller.getCurrentAd();
    if (currentAd == null || // hide for post-roll only playlist
      currentAd.isLinear()) {
      // don't hide for non-linear ads
      this.hideAdContainer();
    }
    this.controlsDiv.style.display = 'none';
    this.countdownDiv.innerHTML = '';
  };

  /**
   * Handles when all ads have finished playing.
   */
  AdUi.prototype.onAllAdsCompleted = function () {
    this.hideAdContainer();
  };

  /**
   * Handles when a linear ad starts.
   */
  AdUi.prototype.onLinearAdStart = function () {
    // Don't bump container when controls are shown
    this.removeClass(this.adContainerDiv, 'bumpable-ima-ad-container');
    this.isAdNonlinear = false;
  };

  /**
   * Handles when a non-linear ad starts.
   */
  AdUi.prototype.onNonLinearAdLoad = function () {
    // For non-linear ads that show after a linear ad. For linear ads, we show the
    // ad container in onAdBreakStart to prevent blinking in pods.
    this.adContainerDiv.style.display = 'block';
    // Bump container when controls are shown
    this.addClass(this.adContainerDiv, 'bumpable-ima-ad-container');
    this.isAdNonlinear = true;
  };

  AdUi.prototype.onPlayerEnterFullscreen = function () {
    this.addClass(this.fullscreenDiv, 'ima-fullscreen');
    this.removeClass(this.fullscreenDiv, 'ima-non-fullscreen');
  };

  AdUi.prototype.onPlayerExitFullscreen = function () {
    this.addClass(this.fullscreenDiv, 'ima-non-fullscreen');
    this.removeClass(this.fullscreenDiv, 'ima-fullscreen');
  };

  /**
   * Called when the player volume changes.
   *
   * @param {number} volume The new player volume.
   */
  AdUi.prototype.onPlayerVolumeChanged = function (volume) {
    if (volume == 0) {
      this.addClass(this.muteDiv, 'ima-muted');
      this.removeClass(this.muteDiv, 'ima-non-muted');
      this.sliderLevelDiv.style.width = '0%';
    } else {
      this.addClass(this.muteDiv, 'ima-non-muted');
      this.removeClass(this.muteDiv, 'ima-muted');
      this.sliderLevelDiv.style.width = volume * 100 + '%';
    }
  };

  /**
   * Shows ad controls on mouseover.
   */
  AdUi.prototype.showAdControls = function () {
    var _controller$getSettin = this.controller.getSettings(),
      disableAdControls = _controller$getSettin.disableAdControls;

    if (!disableAdControls) {
      this.addClass(this.controlsDiv, 'ima-controls-div-showing');
    }
  };

  /**
   * Hide the ad controls.
   */
  AdUi.prototype.hideAdControls = function () {
    this.removeClass(this.controlsDiv, 'ima-controls-div-showing');
  };

  /**
   * Assigns the unique id and class names to the given element as well as the
   * style class.
   * @param {HTMLElement} element Element that needs the controlName assigned.
   * @param {string} controlName Control name to assign.
   */
  AdUi.prototype.assignControlAttributes = function (element, controlName) {
    element.id = this.controlPrefix + controlName;
    element.className = this.controlPrefix + controlName + ' ' + controlName;
  };

  /**
   * Returns a regular expression to test a string for the given className.
   *
   * @param {string} className The name of the class.
   * @return {RegExp} The regular expression used to test for that class.
   */
  AdUi.prototype.getClassRegexp = function (className) {
    // Matches on
    // (beginning of string OR NOT word char)
    // classname
    // (negative lookahead word char OR end of string)
    return new RegExp('(^|[^A-Za-z-])' + className + '((?![A-Za-z-])|$)', 'gi');
  };

  /**
   * Returns whether or not the provided element has the provied class in its
   * className.
   * @param {HTMLElement} element Element to tes.t
   * @param {string} className Class to look for.
   * @return {boolean} True if element has className in class list. False
   *     otherwise.
   */
  AdUi.prototype.elementHasClass = function (element, className) {
    var classRegexp = this.getClassRegexp(className);
    return classRegexp.test(element.className);
  };

  /**
   * Adds a class to the given element if it doesn't already have the class
   * @param {HTMLElement} element Element to which the class will be added.
   * @param {string} classToAdd Class to add.
   */
  AdUi.prototype.addClass = function (element, classToAdd) {
    element.className = element.className.trim() + ' ' + classToAdd;
  };

  /**
   * Removes a class from the given element if it has the given class
   *
   * @param {HTMLElement} element Element from which the class will be removed.
   * @param {string} classToRemove Class to remove.
   */
  AdUi.prototype.removeClass = function (element, classToRemove) {
    var classRegexp = this.getClassRegexp(classToRemove);
    element.className = element.className.trim().replace(classRegexp, '');
  };

  /**
   * @return {HTMLElement} The div for the ad container.
   */
  AdUi.prototype.getAdContainerDiv = function () {
    return this.adContainerDiv;
  };

  /**
   * Changes the flag to show or hide the ad countdown timer.
   *
   * @param {boolean} showCountdownIn Show or hide the countdown timer.
   */
  AdUi.prototype.setShowCountdown = function (showCountdownIn) {
    this.showCountdown = showCountdownIn;
    this.countdownDiv.style.display = this.showCountdown ? 'block' : 'none';
  };

  var name = "tm_videojs-ima";
  var version = "2.2.0";
  var license = "Apache-2.0";
  var main = "./dist/tm_videojs.ima.js";
  var module$1 = "./dist/tm_videojs.ima.es.js";
  var author = { "name": "Google Inc." };
  var engines = { "node": ">=0.8.0" };
  var scripts = { "contBuild": "watch 'npm run rollup:max' src", "predevServer": "echo \"Starting up server on localhost:8000.\"", "devServer": "npm-run-all -p testServer contBuild", "lint": "eslint \"src/**/*.js\"", "rollup": "npm-run-all rollup:*", "rollup:max": "rollup -c configs/rollup.config.js", "rollup:es": "rollup -c configs/rollup.config.es.js", "rollup:min": "rollup -c configs/rollup.config.min.js", "pretest": "npm run rollup", "start": "npm run devServer", "test": "npm-run-all test:*", "test:vjs6": "npm install video.js@6 --no-save && npm-run-all -p -r testServer webdriver", "test:vjs7": "npm install video.js@7 --no-save && npm-run-all -p -r testServer webdriver", "testServer": "http-server --cors -p 8000 --silent", "preversion": "node scripts/preversion.js && npm run lint && npm test", "version": "node scripts/version.js", "postversion": "node scripts/postversion.js", "webdriver": "mocha test/webdriver/*.js --no-timeouts" };
  var repository = { "type": "git", "url": "https://github.com/googleads/tm_videojs-ima" };
  var files = ["CHANGELOG.md", "LICENSE", "README.md", "dist/", "src/"];
  var peerDependencies = { "video.js": "^5.19.2 || ^6 || ^7 || ^8" };
  var dependencies = { "@hapi/cryptiles": "^5.1.0", "can-autoplay": "^3.0.2", "extend": ">=3.0.2", "tm_videojs-contrib-ads": "^6.9.0 || ^7" };
  var devDependencies = { "axios": "^0.25.0", "babel-core": "^6.26.3", "babel-preset-env": "^1.7.0", "child_process": "^1.0.2", "chromedriver": "^114.0.2", "conventional-changelog-cli": "^2.2.2", "conventional-changelog-tm_videojs": "^3.0.2", "ecstatic": "^4.1.4", "eslint": "^8.8.0", "eslint-config-google": "^0.9.1", "eslint-plugin-jsdoc": "^3.15.1", "geckodriver": "^2.0.4", "http-server": "^14.1.0", "ini": ">=1.3.7", "mocha": "^9.2.0", "npm-run-all": "^4.1.5", "path": "^0.12.7", "protractor": "^7.0.0", "rimraf": "^2.7.1", "rollup": "^0.51.8", "rollup-plugin-babel": "^3.0.7", "rollup-plugin-copy": "^0.2.3", "rollup-plugin-json": "^2.3.1", "rollup-plugin-uglify": "^2.0.1", "selenium-webdriver": "^3.6.0", "uglify-es": "^3.3.9", "video.js": "^7.17.0", "watch": "^0.13.0", "webdriver-manager": "^12.1.7", "xmldom": "^0.6.0" };
  var keywords = ["tm_videojs", "tm_videojs-plugin"];
  var pkg = {
    name: name,
    version: version,
    license: license,
    main: main,
    module: module$1,
    author: author,
    engines: engines,
    scripts: scripts,
    repository: repository,
    files: files,
    peerDependencies: peerDependencies,
    dependencies: dependencies,
    devDependencies: devDependencies,
    keywords: keywords
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /**
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */

  /**
   * Implementation of the IMA SDK for the plugin.
   *
   * @param {Object} controller Reference to the parent controller.
   *
   * @constructor
   * @struct
   * @final
   */
  var SdkImpl = function SdkImpl(controller) {
    /**
     * Plugin controller.
     */
    this.controller = controller;

    /**
     * IMA SDK AdDisplayContainer.
     */
    this.adDisplayContainer = null;

    /**
     * True if the AdDisplayContainer has been initialized. False otherwise.
     */
    this.adDisplayContainerInitialized = false;

    /**
     * IMA SDK AdsLoader
     */
    this.adsLoader = null;

    /**
     * IMA SDK AdsManager
     */
    this.adsManager = null;

    /**
     * IMA SDK AdsRenderingSettings.
     */
    this.adsRenderingSettings = null;

    /**
     * VAST, VMAP, or ad rules response. Used in lieu of fetching a response
     * from an ad tag URL.
     */
    this.adsResponse = null;

    /**
     * Current IMA SDK Ad.
     */
    this.currentAd = null;

    /**
     * Timer used to track ad progress.
     */
    this.adTrackingTimer = null;

    /**
     * True if ALL_ADS_COMPLETED has fired, false until then.
     */
    this.allAdsCompleted = false;

    /**
     * True if ads are currently displayed, false otherwise.
     * True regardless of ad pause state if an ad is currently being displayed.
     */
    this.adsActive = false;

    /**
     * True if ad is currently playing, false if ad is paused or ads are not
     * currently displayed.
     */
    this.adPlaying = false;

    /**
     * True if the ad is muted, false otherwise.
     */
    this.adMuted = false;

    /**
     * Listener to be called to trigger manual ad break playback.
     */
    this.adBreakReadyListener = undefined;

    /**
     * Tracks whether or not we have already called adsLoader.contentComplete().
     */
    this.contentCompleteCalled = false;

    /**
     * True if the ad has timed out.
     */
    this.isAdTimedOut = false;

    /**
     * Stores the dimensions for the ads manager.
     */
    this.adsManagerDimensions = {
      width: 0,
      height: 0
    };

    /**
     * Boolean flag to enable manual ad break playback.
     */
    this.autoPlayAdBreaks = true;
    if (this.controller.getSettings().autoPlayAdBreaks === false) {
      this.autoPlayAdBreaks = false;
    }

    // Set SDK settings from plugin settings.
    if (this.controller.getSettings().locale) {
      /* eslint no-undef: 'error' */
      /* global google */
      google.ima.settings.setLocale(this.controller.getSettings().locale);
    }
    if (this.controller.getSettings().disableFlashAds) {
      google.ima.settings.setDisableFlashAds(this.controller.getSettings().disableFlashAds);
    }
    if (this.controller.getSettings().disableCustomPlaybackForIOS10Plus) {
      google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.controller.getSettings().disableCustomPlaybackForIOS10Plus);
    }

    if (this.controller.getSettings().ppid) {
      google.ima.settings.setPpid(this.controller.getSettings().ppid);
    }

    if (this.controller.getSettings().featureFlags) {
      google.ima.settings.setFeatureFlags(this.controller.getSettings().featureFlags);
    }
  };

  /**
   * Creates and initializes the IMA SDK objects.
   */
  SdkImpl.prototype.initAdObjects = function () {
    this.adDisplayContainer = new google.ima.AdDisplayContainer(this.controller.getAdContainerDiv(), this.controller.getContentPlayer());

    this.adsLoader = new google.ima.AdsLoader(this.adDisplayContainer);

    this.adsLoader.getSettings().setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED);
    if (this.controller.getSettings().vpaidAllowed == false) {
      this.adsLoader.getSettings().setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.DISABLED);
    }
    if (this.controller.getSettings().vpaidMode !== undefined) {
      this.adsLoader.getSettings().setVpaidMode(this.controller.getSettings().vpaidMode);
    }

    if (this.controller.getSettings().locale) {
      this.adsLoader.getSettings().setLocale(this.controller.getSettings().locale);
    }

    if (this.controller.getSettings().numRedirects) {
      this.adsLoader.getSettings().setNumRedirects(this.controller.getSettings().numRedirects);
    }

    if (this.controller.getSettings().sessionId) {
      this.adsLoader.getSettings().setSessionId(this.controller.getSettings().sessionId);
    }

    this.adsLoader.getSettings().setPlayerType('tm_videojs-ima');
    this.adsLoader.getSettings().setPlayerVersion(pkg.version);
    this.adsLoader.getSettings().setAutoPlayAdBreaks(this.autoPlayAdBreaks);

    this.adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded.bind(this), false);
    this.adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdsLoaderError.bind(this), false);

    this.controller.playerWrapper.vjsPlayer.trigger({
      type: 'ads-loader',
      adsLoader: this.adsLoader
    });
  };

  /**
   * Creates the AdsRequest and request ads through the AdsLoader.
   */
  SdkImpl.prototype.requestAds = function (isItAutoPlay) {
    var adsRequest = new google.ima.AdsRequest();
    if (this.controller.getSettings().adTagUrl) {
      adsRequest.adTagUrl = this.controller.getSettings().adTagUrl;
    } else {
      adsRequest.adsResponse = this.controller.getSettings().adsResponse;
    }
    if (this.controller.getSettings().forceNonLinearFullSlot) {
      adsRequest.forceNonLinearFullSlot = true;
    }

    if (this.controller.getSettings().vastLoadTimeout) {
      adsRequest.vastLoadTimeout = this.controller.getSettings().vastLoadTimeout;
    }

    if (this.controller.getSettings().omidMode) {
      window.console.warn('The additional setting `omidMode` has been removed. ' + 'Use `omidVendorAccess` instead.');
    }

    if (this.controller.getSettings().omidVendorAccess) {
      adsRequest.omidAccessModeRules = {};
      var omidVendorValues = this.controller.getSettings().omidVendorAccess;

      Object.keys(omidVendorValues).forEach(function (vendorKey) {
        adsRequest.omidAccessModeRules[vendorKey] = omidVendorValues[vendorKey];
      });
    }

    adsRequest.linearAdSlotWidth = this.controller.getPlayerWidth();
    adsRequest.linearAdSlotHeight = this.controller.getPlayerHeight();
    adsRequest.nonLinearAdSlotWidth = this.controller.getSettings().nonLinearWidth || this.controller.getPlayerWidth();
    adsRequest.nonLinearAdSlotHeight = this.controller.getSettings().nonLinearHeight || this.controller.getPlayerHeight();
    adsRequest.setAdWillAutoPlay(this.controller.adsWillAutoplay());
    adsRequest.setAdWillPlayMuted(this.controller.adsWillPlayMuted());

    // Populate the adsRequestproperties with those provided in the AdsRequest
    // object in the settings.
    var providedAdsRequest = this.controller.getSettings().adsRequest;
    if (providedAdsRequest && (typeof providedAdsRequest === 'undefined' ? 'undefined' : _typeof(providedAdsRequest)) === 'object') {
      Object.keys(providedAdsRequest).forEach(function (key) {
        adsRequest[key] = providedAdsRequest[key];
      });
    }
    //manipulating vpa value
    if (isItAutoPlay) {
      adsRequest.j = "auto";
    }

    this.adsLoader.requestAds(adsRequest);
    this.controller.playerWrapper.vjsPlayer.trigger({
      type: 'ads-request',
      AdsRequest: adsRequest
    });
  };

  /**
   * Listener for the ADS_MANAGER_LOADED event. Creates the AdsManager,
   * sets up event listeners, and triggers the 'adsready' event for
   * tm_videojs-ads-contrib.
   *
   * @param {google.ima.AdsManagerLoadedEvent} adsManagerLoadedEvent Fired when
   *     the AdsManager loads.
   */
  SdkImpl.prototype.onAdsManagerLoaded = function (adsManagerLoadedEvent) {
    this.createAdsRenderingSettings();

    this.adsManager = adsManagerLoadedEvent.getAdsManager(this.controller.getContentPlayheadTracker(), this.adsRenderingSettings);

    this.adsManager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.AD_BREAK_READY, this.onAdBreakReady.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.ALL_ADS_COMPLETED, this.onAllAdsCompleted.bind(this));

    this.adsManager.addEventListener(google.ima.AdEvent.Type.LOADED, this.onAdLoaded.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.STARTED, this.onAdStarted.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.COMPLETE, this.onAdComplete.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.SKIPPED, this.onAdComplete.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.LOG, this.onAdLog.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.PAUSED, this.onAdPaused.bind(this));
    this.adsManager.addEventListener(google.ima.AdEvent.Type.RESUMED, this.onAdResumed.bind(this));

    this.controller.playerWrapper.vjsPlayer.trigger({
      type: 'ads-manager',
      adsManager: this.adsManager
    });

    if (!this.autoPlayAdBreaks) {
      this.initAdsManager();
    }

    var _controller$getSettin = this.controller.getSettings(),
      preventLateAdStart = _controller$getSettin.preventLateAdStart;

    if (!preventLateAdStart) {
      this.controller.onAdsReady();
    } else if (preventLateAdStart && !this.isAdTimedOut) {
      this.controller.onAdsReady();
    }

    if (this.controller.getSettings().adsManagerLoadedCallback) {
      this.controller.getSettings().adsManagerLoadedCallback();
    }
  };

  /**
   * Listener for errors fired by the AdsLoader.
   * @param {google.ima.AdErrorEvent} event The error event thrown by the
   *     AdsLoader. See
   *     https://developers.google.com/interactive-media-ads/docs/sdks/html5/client-side/reference/js/google.ima.AdError#.Type
   */
  SdkImpl.prototype.onAdsLoaderError = function (event) {
    //vasu
    // window.console.warn('AdsLoader error: ' + event.getError());
    this.controller.onErrorLoadingAds(event);
    if (this.adsManager) {
      this.adsManager.destroy();
    }
  };

  /**
   * Initialize the ads manager.
   */
  SdkImpl.prototype.initAdsManager = function () {
    try {
      var initWidth = this.controller.getPlayerWidth();
      var initHeight = this.controller.getPlayerHeight();
      this.adsManagerDimensions.width = initWidth;
      this.adsManagerDimensions.height = initHeight;
      this.adsManager.init(initWidth, initHeight, google.ima.ViewMode.NORMAL);
      this.adsManager.setVolume(this.controller.getPlayerVolume());
      this.initializeAdDisplayContainer();
    } catch (adError) {
      this.onAdError(adError);
    }
  };

  /**
   * Create AdsRenderingSettings for the IMA SDK.
   */
  SdkImpl.prototype.createAdsRenderingSettings = function () {
    this.adsRenderingSettings = new google.ima.AdsRenderingSettings();
    this.adsRenderingSettings.restoreCustomPlaybackStateOnAdBreakComplete = true;
    if (this.controller.getSettings().adsRenderingSettings) {
      for (var setting in this.controller.getSettings().adsRenderingSettings) {
        if (setting !== '') {
          this.adsRenderingSettings[setting] = this.controller.getSettings().adsRenderingSettings[setting];
        }
      }
    }
  };

  /**
   * Listener for errors thrown by the AdsManager.
   * @param {google.ima.AdErrorEvent} adErrorEvent The error event thrown by
   *     the AdsManager.
   */
  SdkImpl.prototype.onAdError = function (adErrorEvent) {
    var errorMessage = adErrorEvent.getError !== undefined ? adErrorEvent.getError() : adErrorEvent.stack;
    // window.console.warn('Ad error: ' + errorMessage);

    this.adsManager.destroy();
    this.controller.onAdError(adErrorEvent);

    // reset these so consumers don't think we are still in an ad break,
    // but reset them after any prior cleanup happens
    this.adsActive = false;
    this.adPlaying = false;
  };

  /**
   * Listener for AD_BREAK_READY. Passes event on to publisher's listener.
   * @param {google.ima.AdEvent} adEvent AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onAdBreakReady = function (adEvent) {
    this.adBreakReadyListener(adEvent);
  };

  /**
   * Pauses the content video and displays the ad container so ads can play.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onContentPauseRequested = function (adEvent) {
    this.adsActive = true;
    this.adPlaying = true;
    this.controller.onAdBreakStart(adEvent);
  };

  /**
   * Resumes content video and hides the ad container.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onContentResumeRequested = function (adEvent) {
    this.adsActive = false;
    this.adPlaying = false;
    this.controller.onAdBreakEnd();
    // Hide controls in case of future non-linear ads. They'll be unhidden in
    // content_pause_requested.
  };

  /**
   * Records that ads have completed and calls contentAndAdsEndedListeners
   * if content is also complete.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onAllAdsCompleted = function (adEvent) {
    this.allAdsCompleted = true;
    this.controller.onAllAdsCompleted();
  };

  /**
   * Starts the content video when a non-linear ad is loaded.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onAdLoaded = function (adEvent) {
    if (!adEvent.getAd().isLinear()) {
      this.controller.onNonLinearAdLoad();
      this.controller.playContent();
    }
  };

  /**
   * Starts the interval timer to check the current ad time when an ad starts
   * playing.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onAdStarted = function (adEvent) {
    this.currentAd = adEvent.getAd();
    if (this.currentAd.isLinear()) {
      this.adTrackingTimer = setInterval(this.onAdPlayheadTrackerInterval.bind(this), 250);
      this.controller.onLinearAdStart();
    } else {
      this.controller.onNonLinearAdStart();
    }
  };

  /**
   * Handles an ad click. Puts the player UI in a paused state.
   */
  SdkImpl.prototype.onAdPaused = function () {
    this.controller.onAdsPaused();
  };

  /**
   * Syncs controls when an ad resumes.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onAdResumed = function (adEvent) {
    this.controller.onAdsResumed();
  };

  /**
   * Clears the interval timer for current ad time when an ad completes.
   */
  SdkImpl.prototype.onAdComplete = function () {
    if (this.currentAd.isLinear()) {
      clearInterval(this.adTrackingTimer);
    }
  };

  /**
   * Handles ad log messages.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the AdsManager.
   */
  SdkImpl.prototype.onAdLog = function (adEvent) {
    this.controller.onAdLog(adEvent);
  };

  /**
   * Gets the current time and duration of the ad and calls the method to
   * update the ad UI.
   */
  SdkImpl.prototype.onAdPlayheadTrackerInterval = function () {
    if (this.adsManager === null) return;
    var remainingTime = this.adsManager.getRemainingTime();
    var duration = this.currentAd.getDuration();
    var currentTime = duration - remainingTime;
    currentTime = currentTime > 0 ? currentTime : 0;
    var totalAds = 0;
    var adPosition = void 0;
    if (this.currentAd.getAdPodInfo()) {
      adPosition = this.currentAd.getAdPodInfo().getAdPosition();
      totalAds = this.currentAd.getAdPodInfo().getTotalAds();
    }

    this.controller.onAdPlayheadUpdated(currentTime, remainingTime, duration, adPosition, totalAds);
  };

  /**
   * Called by the player wrapper when content completes.
   */
  SdkImpl.prototype.onContentComplete = function () {
    if (this.adsLoader) {
      this.adsLoader.contentComplete();
      this.contentCompleteCalled = true;
    }

    if (this.adsManager && this.adsManager.getCuePoints() && !this.adsManager.getCuePoints().includes(-1) || !this.adsManager) {
      this.controller.onNoPostroll();
    }

    if (this.allAdsCompleted) {
      this.controller.onContentAndAdsCompleted();
    }
  };

  /**
   * Called when the player is disposed.
   */
  SdkImpl.prototype.onPlayerDisposed = function () {
    if (this.adTrackingTimer) {
      clearInterval(this.adTrackingTimer);
    }
    if (this.adsManager) {
      this.adsManager.destroy();
      this.adsManager = null;
    }
  };

  SdkImpl.prototype.onPlayerReadyForPreroll = function () {
    if (this.autoPlayAdBreaks) {
      this.initAdsManager();
      try {
        this.controller.showAdContainer();
        // Sync ad volume with content volume.
        this.adsManager.setVolume(this.controller.getPlayerVolume());
        this.adsManager.start();
      } catch (adError) {
        this.onAdError(adError);
      }
    }
  };

  SdkImpl.prototype.onAdTimeout = function () {
    this.isAdTimedOut = true;
  };

  SdkImpl.prototype.onPlayerReady = function (isItAutoPlay) {
    this.initAdObjects();

    if ((this.controller.getSettings().adTagUrl || this.controller.getSettings().adsResponse) && this.controller.getSettings().requestMode === 'onLoad') {
      this.requestAds(isItAutoPlay);
    }
  };

  SdkImpl.prototype.onPlayerEnterFullscreen = function () {
    if (this.adsManager) {
      this.adsManager.resize(window.screen.width, window.screen.height, google.ima.ViewMode.FULLSCREEN);
    }
  };

  SdkImpl.prototype.onPlayerExitFullscreen = function () {
    if (this.adsManager) {
      this.adsManager.resize(this.controller.getPlayerWidth(), this.controller.getPlayerHeight(), google.ima.ViewMode.NORMAL);
    }
  };

  /**
   * Called when the player volume changes.
   *
   * @param {number} volume The new player volume.
   */
  SdkImpl.prototype.onPlayerVolumeChanged = function (volume) {
    if (this.adsManager) {
      this.adsManager.setVolume(volume);
    }

    if (volume == 0) {
      this.adMuted = true;
    } else {
      this.adMuted = false;
    }
  };

  /**
   * Called when the player wrapper detects that the player has been resized.
   *
   * @param {number} width The post-resize width of the player.
   * @param {number} height The post-resize height of the player.
   */
  SdkImpl.prototype.onPlayerResize = function (width, height) {
    if (this.adsManager) {
      this.adsManagerDimensions.width = width;
      this.adsManagerDimensions.height = height;
      /* eslint no-undef: 'error' */
      this.adsManager.resize(width, height, google.ima.ViewMode.NORMAL);
    }
  };

  /**
   * @return {Object} The current ad.
   */
  SdkImpl.prototype.getCurrentAd = function () {
    return this.currentAd;
  };

  /**
   * Listener JSDoc for ESLint. This listener can be passed to
   * setAdBreakReadyListener.
   * @callback listener
   */

  /**
   * Sets the listener to be called to trigger manual ad break playback.
   * @param {listener} listener The listener to be called to trigger manual ad
   *     break playback.
   */
  SdkImpl.prototype.setAdBreakReadyListener = function (listener) {
    this.adBreakReadyListener = listener;
  };

  /**
   * @return {boolean} True if an ad is currently playing. False otherwise.
   */
  SdkImpl.prototype.isAdPlaying = function () {
    return this.adPlaying;
  };

  /**
   * @return {boolean} True if an ad is currently playing. False otherwise.
   */
  SdkImpl.prototype.isAdMuted = function () {
    return this.adMuted;
  };

  /**
   * Pause ads.
   */
  SdkImpl.prototype.pauseAds = function () {
    this.adsManager.pause();
    this.adPlaying = false;
  };

  /**
   * Resume ads.
   */
  SdkImpl.prototype.resumeAds = function () {
    this.adsManager.resume();
    this.adPlaying = true;
  };

  /**
   * Unmute ads.
   */
  SdkImpl.prototype.unmute = function () {
    this.adsManager.setVolume(1);
    this.adMuted = false;
  };

  /**
   * Mute ads.
   */
  SdkImpl.prototype.mute = function () {
    this.adsManager.setVolume(0);
    this.adMuted = true;
  };

  /**
   * Set the volume of the ads. 0-1.
   *
   * @param {number} volume The new volume.
   */
  SdkImpl.prototype.setVolume = function (volume) {
    this.adsManager.setVolume(volume);
    if (volume == 0) {
      this.adMuted = true;
    } else {
      this.adMuted = false;
    }
  };

  /**
   * Initializes the AdDisplayContainer. On mobile, this must be done as a
   * result of user action.
   */
  SdkImpl.prototype.initializeAdDisplayContainer = function () {
    if (this.adDisplayContainer) {
      if (!this.adDisplayContainerInitialized) {
        this.adDisplayContainer.initialize();
        this.adDisplayContainerInitialized = true;
      }
    }
  };

  /**
   * Called by publishers in manual ad break playback mode to start an ad
   * break.
   */
  SdkImpl.prototype.playAdBreak = function () {
    if (!this.autoPlayAdBreaks) {
      this.controller.showAdContainer();
      // Sync ad volume with content volume.
      this.adsManager.setVolume(this.controller.getPlayerVolume());
      this.adsManager.start();
    }
  };

  /**
   * Callback JSDoc for ESLint. This callback can be passed to addEventListener.
   * @callback callback
   */

  /**
   * Ads an EventListener to the AdsManager. For a list of available events,
   * see
   * https://developers.google.com/interactive-media-ads/docs/sdks/html5/client-side/reference/js/google.ima.AdEvent#.Type
   * @param {google.ima.AdEvent.Type} event The AdEvent.Type for which to
   *     listen.
   * @param {callback} callback The method to call when the event is fired.
   */
  SdkImpl.prototype.addEventListener = function (event, callback) {
    if (this.adsManager) {
      this.adsManager.addEventListener(event, callback);
    }
  };

  /**
   * Returns the instance of the AdsManager.
   * @return {google.ima.AdsManager} The AdsManager being used by the plugin.
   */
  SdkImpl.prototype.getAdsManager = function () {
    return this.adsManager;
  };

  /**
   * Reset the SDK implementation.
   */
  SdkImpl.prototype.reset = function () {
    this.adsActive = false;
    this.adPlaying = false;
    if (this.adTrackingTimer) {
      // If this is called while an ad is playing, stop trying to get that
      // ad's current time.
      clearInterval(this.adTrackingTimer);
    }
    if (this.adsManager) {
      this.adsManager.destroy();
      this.adsManager = null;
    }
    if (this.adsLoader && !this.contentCompleteCalled) {
      this.adsLoader.contentComplete();
    }
    this.contentCompleteCalled = false;
    this.allAdsCompleted = false;
  };

  /**
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */
  /**
   * The grand coordinator of the plugin. Facilitates communication between all
   * other plugin classes.
   *
   * @param {Object} player Instance of the video.js player.
   * @param {Object} options Options provided by the implementation.
   * @constructor
   * @struct
   * @final
   */
  var Controller = function Controller(player, options) {
    /**
     * Stores user-provided settings.
     * @type {Object}
     */
    this.settings = {};

    /**
     * Content and ads ended listeners passed by the publisher to the plugin.
     * These will be called when the plugin detects that content *and all
     * ads* have completed. This differs from the contentEndedListeners in that
     * contentEndedListeners will fire between content ending and a post-roll
     * playing, whereas the contentAndAdsEndedListeners will fire after the
     * post-roll completes.
     */
    this.contentAndAdsEndedListeners = [];

    /**
     * Whether or not we are running on a mobile platform.
     */
    this.isMobile = navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/Android/i);

    /**
     * Whether or not we are running on an iOS platform.
     */
    this.isIos = navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i);

    this.initWithSettings(options);

    /**
     * Stores contrib-ads default settings.
     */
    var contribAdsDefaults = {
      debug: this.settings.debug,
      timeout: this.settings.timeout,
      prerollTimeout: this.settings.prerollTimeout
    };
    var adsPluginSettings = Object.assign({}, contribAdsDefaults, options.contribAdsSettings || {});

    this.playerWrapper = new PlayerWrapper(player, adsPluginSettings, this);
    this.adUi = new AdUi(this);
    this.sdkImpl = new SdkImpl(this);
  };

  Controller.IMA_DEFAULTS = {
    adLabel: 'Advertisement',
    adLabelNofN: 'of',
    debug: false,
    disableAdControls: false,
    prerollTimeout: 1000,
    preventLateAdStart: false,
    requestMode: 'onLoad',
    showControlsForJSAds: true,
    timeout: 5000
  };

  /**
   * Extends the settings to include user-provided settings.
   *
   * @param {Object} options Options to be used in initialization.
   */
  Controller.prototype.initWithSettings = function (options) {
    this.settings = Object.assign({}, Controller.IMA_DEFAULTS, options || {});

    this.warnAboutDeprecatedSettings();

    // Default showing countdown timer to true.
    this.showCountdown = true;
    if (this.settings.showCountdown === false) {
      this.showCountdown = false;
    }
  };

  /**
   * Logs console warnings when deprecated settings are used.
   */
  Controller.prototype.warnAboutDeprecatedSettings = function () {
    var _this = this;

    var deprecatedSettings = ['adWillAutoplay', 'adsWillAutoplay', 'adWillPlayMuted', 'adsWillPlayMuted'];
    deprecatedSettings.forEach(function (setting) {
      if (_this.settings[setting] !== undefined) {
        // console.warn('WARNING: tm_videojs.ima setting ' + setting + ' is deprecated');
      }
    });
  };

  /**
   * Return the settings object.
   *
   * @return {Object} The settings object.
   */
  Controller.prototype.getSettings = function () {
    return this.settings;
  };

  /**
   * Return whether or not we're in a mobile environment.
   *
   * @return {boolean} True if running on mobile, false otherwise.
   */
  Controller.prototype.getIsMobile = function () {
    return this.isMobile;
  };

  /**
   * Return whether or not we're in an iOS environment.
   *
   * @return {boolean} True if running on iOS, false otherwise.
   */
  Controller.prototype.getIsIos = function () {
    return this.isIos;
  };

  /**
   * Inject the ad container div into the DOM.
   *
   * @param{HTMLElement} adContainerDiv The ad container div.
   */
  Controller.prototype.injectAdContainerDiv = function (adContainerDiv) {
    this.playerWrapper.injectAdContainerDiv(adContainerDiv);
  };

  /**
   * @return {HTMLElement} The div for the ad container.
   */
  Controller.prototype.getAdContainerDiv = function () {
    return this.adUi.getAdContainerDiv();
  };

  /**
   * @return {Object} The content player.
   */
  Controller.prototype.getContentPlayer = function () {
    return this.playerWrapper.getContentPlayer();
  };

  /**
   * Returns the content playhead tracker.
   *
   * @return {Object} The content playhead tracker.
   */
  Controller.prototype.getContentPlayheadTracker = function () {
    return this.playerWrapper.getContentPlayheadTracker();
  };

  /**
   * Requests ads.
   */
  Controller.prototype.requestAds = function (isItAutoPlay) {
    this.sdkImpl.requestAds(isItAutoPlay);
  };

  /**
   * Add or modify a setting.
   *
   * @param {string} key Key to modify
   * @param {Object} value Value to set at key.
   */
  Controller.prototype.setSetting = function (key, value) {
    this.settings[key] = value;
  };

  /**
   * Called when there is an error loading ads.
   *
   * @param {Object} adErrorEvent The ad error event thrown by the IMA SDK.
   */
  Controller.prototype.onErrorLoadingAds = function (adErrorEvent) {
    this.adUi.onAdError();
    this.playerWrapper.onAdError(adErrorEvent);
  };

  /**
   * Called by the ad UI when the play/pause button is clicked.
   */
  Controller.prototype.onAdPlayPauseClick = function () {
    if (this.sdkImpl.isAdPlaying()) {
      this.adUi.onAdsPaused();
      this.sdkImpl.pauseAds();
    } else {
      this.adUi.onAdsPlaying();
      this.sdkImpl.resumeAds();
    }
  };

  /**
   * Called by the ad UI when the mute button is clicked.
   *
   */
  Controller.prototype.onAdMuteClick = function () {
    if (this.sdkImpl.isAdMuted()) {
      this.playerWrapper.unmute();
      this.adUi.unmute();
      this.sdkImpl.unmute();
    } else {
      this.playerWrapper.mute();
      this.adUi.mute();
      this.sdkImpl.mute();
    }
  };

  /**
   * Set the volume of the player and ads. 0-1.
   *
   * @param {number} volume The new volume.
   */
  Controller.prototype.setVolume = function (volume) {
    this.playerWrapper.setVolume(volume);
    this.sdkImpl.setVolume(volume);
  };

  /**
   * @return {number} The volume of the content player.
   */
  Controller.prototype.getPlayerVolume = function () {
    return this.playerWrapper.getVolume();
  };

  /**
   * Toggle fullscreen state.
   */
  Controller.prototype.toggleFullscreen = function () {
    this.playerWrapper.toggleFullscreen();
  };

  /**
   * Relays ad errors to the player wrapper.
   *
   * @param {Object} adErrorEvent The ad error event thrown by the IMA SDK.
   */
  Controller.prototype.onAdError = function (adErrorEvent) {
    this.adUi.onAdError();
    this.playerWrapper.onAdError(adErrorEvent);
  };

  /**
   * Handles ad break starting.
   *
   * @param {Object} adEvent The event fired by the IMA SDK.
   */
  Controller.prototype.onAdBreakStart = function (adEvent) {
    this.playerWrapper.onAdBreakStart();
    this.adUi.onAdBreakStart(adEvent);
  };

  /**
   * Show the ad container.
   */
  Controller.prototype.showAdContainer = function () {
    this.adUi.showAdContainer();
  };

  /**
   * Handles ad break ending.
   */
  Controller.prototype.onAdBreakEnd = function () {
    this.playerWrapper.onAdBreakEnd();
    this.adUi.onAdBreakEnd();
  };

  /**
   * Handles when all ads have finished playing.
   */
  Controller.prototype.onAllAdsCompleted = function () {
    this.adUi.onAllAdsCompleted();
    this.playerWrapper.onAllAdsCompleted();
  };

  /**
   * Handles the SDK firing an ad paused event.
   */
  Controller.prototype.onAdsPaused = function () {
    this.adUi.onAdsPaused();
  };

  /**
   * Handles the SDK firing an ad resumed event.
   */
  Controller.prototype.onAdsResumed = function () {
    this.adUi.onAdsResumed();
  };

  /**
   * Takes data from the sdk impl and passes it to the ad UI to update the UI.
   *
   * @param {number} currentTime Current time of the ad.
   * @param {number} remainingTime Remaining time of the ad.
   * @param {number} duration Duration of the ad.
   * @param {number} adPosition Index of the ad in the pod.
   * @param {number} totalAds Total number of ads in the pod.
   */
  Controller.prototype.onAdPlayheadUpdated = function (currentTime, remainingTime, duration, adPosition, totalAds) {
    this.adUi.updateAdUi(currentTime, remainingTime, duration, adPosition, totalAds);
  };

  /**
   * Handles ad log messages.
   * @param {google.ima.AdEvent} adEvent The AdEvent thrown by the IMA SDK.
   */
  Controller.prototype.onAdLog = function (adEvent) {
    this.playerWrapper.onAdLog(adEvent);
  };

  /**
   * @return {Object} The current ad.
   */
  Controller.prototype.getCurrentAd = function () {
    return this.sdkImpl.getCurrentAd();
  };

  /**
   * Play content.
   */
  Controller.prototype.playContent = function () {
    this.playerWrapper.play();
  };

  /**
   * Handles when a linear ad starts.
   */
  Controller.prototype.onLinearAdStart = function () {
    this.adUi.onLinearAdStart();
    this.playerWrapper.onAdStart();
  };

  /**
   * Handles when a non-linear ad loads.
   */
  Controller.prototype.onNonLinearAdLoad = function () {
    this.adUi.onNonLinearAdLoad();
  };

  /**
   * Handles when a non-linear ad starts.
   */
  Controller.prototype.onNonLinearAdStart = function () {
    this.adUi.onNonLinearAdLoad();
    this.playerWrapper.onAdStart();
  };

  /**
   * Get the player width.
   *
   * @return {number} The width of the player.
   */
  Controller.prototype.getPlayerWidth = function () {
    return this.playerWrapper.getPlayerWidth();
  };

  /**
   * Get the player height.
   *
   * @return {number} The height of the player.
   */
  Controller.prototype.getPlayerHeight = function () {
    return this.playerWrapper.getPlayerHeight();
  };

  /**
   * Tells the player wrapper that ads are ready.
   */
  Controller.prototype.onAdsReady = function () {
    this.playerWrapper.onAdsReady();
  };

  /**
   * Called when the player wrapper detects that the player has been resized.
   *
   * @param {number} width The post-resize width of the player.
   * @param {number} height The post-resize height of the player.
   */
  Controller.prototype.onPlayerResize = function (width, height) {
    this.sdkImpl.onPlayerResize(width, height);
  };

  /**
   * Called by the player wrapper when content completes.
   */
  Controller.prototype.onContentComplete = function () {
    this.sdkImpl.onContentComplete();
  };

  /**
   * Called by the player wrapper when it's time to play a post-roll but we don't
   * have one to play.
   */
  Controller.prototype.onNoPostroll = function () {
    this.playerWrapper.onNoPostroll();
  };

  /**
   * Called when content and all ads have completed.
   */
  Controller.prototype.onContentAndAdsCompleted = function () {
    for (var index in this.contentAndAdsEndedListeners) {
      if (typeof this.contentAndAdsEndedListeners[index] === 'function') {
        this.contentAndAdsEndedListeners[index]();
      }
    }
  };

  /**
   * Called when the player is disposed.
   */
  Controller.prototype.onPlayerDisposed = function () {
    this.contentAndAdsEndedListeners = [];
    this.sdkImpl.onPlayerDisposed();
  };

  /**
   * Called when the player is ready to play a pre-roll.
   */
  Controller.prototype.onPlayerReadyForPreroll = function () {
    this.sdkImpl.onPlayerReadyForPreroll();
  };

  /**
   * Called if the ad times out.
   */
  Controller.prototype.onAdTimeout = function () {
    this.sdkImpl.onAdTimeout();
  };

  /**
   * Called when the player is ready.
   */
  Controller.prototype.onPlayerReady = function () {
    this.sdkImpl.onPlayerReady();
  };

  /**
   * Called when the player enters fullscreen.
   */
  Controller.prototype.onPlayerEnterFullscreen = function () {
    this.adUi.onPlayerEnterFullscreen();
    this.sdkImpl.onPlayerEnterFullscreen();
  };

  /**
   * Called when the player exits fullscreen.
   */
  Controller.prototype.onPlayerExitFullscreen = function () {
    this.adUi.onPlayerExitFullscreen();
    this.sdkImpl.onPlayerExitFullscreen();
  };

  /**
   * Called when the player volume changes.
   *
   * @param {number} volume The new player volume.
   */
  Controller.prototype.onPlayerVolumeChanged = function (volume) {
    this.adUi.onPlayerVolumeChanged(volume);
    this.sdkImpl.onPlayerVolumeChanged(volume);
  };

  /**
   * Sets the content of the video player. You should use this method instead
   * of setting the content src directly to ensure the proper ad tag is
   * requested when the video content is loaded.
   * @param {?string} contentSrc The URI for the content to be played. Leave
   *     blank to use the existing content.
   * @param {?string} adTag The ad tag to be requested when the content loads.
   *     Leave blank to use the existing ad tag.
   */
  Controller.prototype.setContentWithAdTag = function (contentSrc, adTag) {
    this.reset();
    this.settings.adTagUrl = adTag ? adTag : this.settings.adTagUrl;
    this.playerWrapper.changeSource(contentSrc);
  };

  /**
   * Sets the content of the video player. You should use this method instead
   * of setting the content src directly to ensure the proper ads response is
   * used when the video content is loaded.
   * @param {?string} contentSrc The URI for the content to be played. Leave
   *     blank to use the existing content.
   * @param {?string} adsResponse The ads response to be requested when the
   *     content loads. Leave blank to use the existing ads response.
   */
  Controller.prototype.setContentWithAdsResponse = function (contentSrc, adsResponse) {
    this.reset();
    this.settings.adsResponse = adsResponse ? adsResponse : this.settings.adsResponse;
    this.playerWrapper.changeSource(contentSrc);
  };

  /**
   * Sets the content of the video player. You should use this method instead
   * of setting the content src directly to ensure the proper ads request is
   * used when the video content is loaded.
   * @param {?string} contentSrc The URI for the content to be played. Leave
   *     blank to use the existing content.
   * @param {?Object} adsRequest The ads request to be requested when the
   *     content loads. Leave blank to use the existing ads request.
   */
  Controller.prototype.setContentWithAdsRequest = function (contentSrc, adsRequest) {
    this.reset();
    this.settings.adsRequest = adsRequest ? adsRequest : this.settings.adsRequest;
    this.playerWrapper.changeSource(contentSrc);
  };

  /**
   * Resets the state of the plugin.
   */
  Controller.prototype.reset = function () {
    this.sdkImpl.reset();
    this.playerWrapper.reset();
    this.adUi.reset();
  };

  /**
   * Listener JSDoc for ESLint. This listener can be passed to
   * (add|remove)ContentEndedListener.
   * @callback listener
   */

  /**
   * Adds a listener for the 'contentended' event of the video player. This should
   * be used instead of setting an 'contentended' listener directly to ensure that
   * the ima can do proper cleanup of the SDK before other event listeners are
   * called.
   * @param {listener} listener The listener to be called when content
   *     completes.
   */
  Controller.prototype.addContentEndedListener = function (listener) {
    this.playerWrapper.addContentEndedListener(listener);
  };

  /**
   * Adds a listener that will be called when content and all ads have
   * finished playing.
   * @param {listener} listener The listener to be called when content and ads
   *     complete.
   */
  Controller.prototype.addContentAndAdsEndedListener = function (listener) {
    this.contentAndAdsEndedListeners.push(listener);
  };

  /**
   * Sets the listener to be called to trigger manual ad break playback.
   * @param {listener} listener The listener to be called to trigger manual ad
   *     break playback.
   */
  Controller.prototype.setAdBreakReadyListener = function (listener) {
    this.sdkImpl.setAdBreakReadyListener(listener);
  };

  /**
   * Changes the flag to show or hide the ad countdown timer.
   *
   * @param {boolean} showCountdownIn Show or hide the countdown timer.
   */
  Controller.prototype.setShowCountdown = function (showCountdownIn) {
    this.adUi.setShowCountdown(showCountdownIn);
    this.showCountdown = showCountdownIn;
    this.adUi.countdownDiv.style.display = this.showCountdown ? 'block' : 'none';
  };

  /**
   * Initializes the AdDisplayContainer. On mobile, this must be done as a
   * result of user action.
   */
  Controller.prototype.initializeAdDisplayContainer = function () {
    this.sdkImpl.initializeAdDisplayContainer();
  };

  /**
   * Called by publishers in manual ad break playback mode to start an ad
   * break.
   */
  Controller.prototype.playAdBreak = function () {
    this.sdkImpl.playAdBreak();
  };

  /**
   * Callback JSDoc for ESLint. This callback can be passed to addEventListener.
   * @callback callback
   */

  /**
   * Ads an EventListener to the AdsManager. For a list of available events,
   * see
   * https://developers.google.com/interactive-media-ads/docs/sdks/html5/client-side/reference/js/google.ima.AdEvent#.Type
   * @param {google.ima.AdEvent.Type} event The AdEvent.Type for which to
   *     listen.
   * @param {callback} callback The method to call when the event is fired.
   */
  Controller.prototype.addEventListener = function (event, callback) {
    this.sdkImpl.addEventListener(event, callback);
  };

  /**
   * Returns the instance of the AdsManager.
   * @return {google.ima.AdsManager} The AdsManager being used by the plugin.
   */
  Controller.prototype.getAdsManager = function () {
    return this.sdkImpl.getAdsManager();
  };

  /**
   * Returns the instance of the player id.
   * @return {string} The player id.
   */
  Controller.prototype.getPlayerId = function () {
    return this.playerWrapper.getPlayerId();
  };

  /**
   * Changes the ad tag. You will need to call requestAds after this method
   * for the new ads to be requested.
   * @param {?string} adTag The ad tag to be requested the next time
   *     requestAds is called.
   */
  Controller.prototype.changeAdTag = function (adTag) {
    this.reset();
    this.settings.adTagUrl = adTag;
  };

  /**
   * Pauses the ad.
   */
  Controller.prototype.pauseAd = function () {
    this.adUi.onAdsPaused();
    this.sdkImpl.pauseAds();
  };

  /**
   * Resumes the ad.
   */
  Controller.prototype.resumeAd = function () {
    this.adUi.onAdsPlaying();
    this.sdkImpl.resumeAds();
  };

  /**
   * Toggles video/ad playback.
   */
  Controller.prototype.togglePlayback = function () {
    this.playerWrapper.togglePlayback();
  };

  /**
   * @return {boolean} true if we expect that ads will autoplay. false otherwise.
   */
  Controller.prototype.adsWillAutoplay = function () {
    if (this.settings.adsWillAutoplay !== undefined) {
      return this.settings.adsWillAutoplay;
    } else if (this.settings.adWillAutoplay !== undefined) {
      return this.settings.adWillAutoplay;
    } else {
      return !!this.playerWrapper.getPlayerOptions().autoplay;
    }
  };

  /**
   * @return {boolean} true if we expect that ads will autoplay. false otherwise.
   */
  Controller.prototype.adsWillPlayMuted = function () {
    if (this.settings.adsWillPlayMuted !== undefined) {
      return this.settings.adsWillPlayMuted;
    } else if (this.settings.adWillPlayMuted !== undefined) {
      return this.settings.adWillPlayMuted;
    } else if (this.playerWrapper.getPlayerOptions().muted !== undefined) {
      return this.playerWrapper.getPlayerOptions().muted;
    } else {
      return this.playerWrapper.getVolume() == 0;
    }
  };

  /**
   * Triggers an event on the VJS player
   * @param  {string} name The event name.
   * @param  {Object} data The event data.
   */
  Controller.prototype.triggerPlayerEvent = function (name, data) {
    this.playerWrapper.triggerPlayerEvent(name, data);
  };

  /**
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */

  /**
   * Wraps the video.js stream player for the plugin.
   *
   * @param {!Object} player Video.js player instance.
   * @param {!Object} adsPluginSettings Settings for the contrib-ads plugin.
   * @param {!DaiController} daiController Reference to the parent controller.
   */
  var PlayerWrapper$2 = function PlayerWrapper(player, adsPluginSettings, daiController) {
    /**
     * Instance of the video.js player.
     */
    this.vjsPlayer = player;

    /**
     * Plugin DAI controller.
     */
    this.daiController = daiController;

    /**
     * Video.js control bar.
     */
    this.vjsControls = this.vjsPlayer.getChild('controlBar');

    /**
     * Vanilla HTML5 video player underneath the video.js player.
     */
    this.h5Player = null;

    this.vjsPlayer.on('dispose', this.playerDisposedListener.bind(this));
    this.vjsPlayer.on('pause', this.onPause.bind(this));
    this.vjsPlayer.on('play', this.onPlay.bind(this));
    this.vjsPlayer.on('seeked', this.onSeekEnd.bind(this));
    this.vjsPlayer.ready(this.onPlayerReady.bind(this));

    if (!this.vjsPlayer.ads) {
      // window.console.warn('You may be using a version of tm_videojs-contrib-ads ' + 'that is not compatible with your version of video.js.');
    }
    this.vjsPlayer.ads(adsPluginSettings);
  };

  /**
   * Called in response to the video.js player's 'disposed' event.
   */
  PlayerWrapper$2.prototype.playerDisposedListener = function () {
    this.contentEndedListeners = [];
    this.daiController.onPlayerDisposed();
  };

  /**
   * Called on the player 'pause' event. Handles displaying controls during
   * paused ad breaks.
   */
  PlayerWrapper$2.prototype.onPause = function () {
    // This code will run if the stream is paused during an ad break. Since
    // controls are usually hidden during ads, they will now show to allow
    // users to resume ad playback.
    if (this.daiController.isInAdBreak()) {
      this.vjsControls.show();
    }
  };

  /**
   * Called on the player 'play' event. Handles hiding controls during
   * ad breaks while playing.
   */
  PlayerWrapper$2.prototype.onPlay = function () {
    if (this.daiController.isInAdBreak()) {
      this.vjsControls.hide();
    }
  };

  /**
   * Called on the player's 'seeked' event. Sets up handling for ad break
   * snapback for VOD streams.
   */
  PlayerWrapper$2.prototype.onSeekEnd = function () {
    this.daiController.onSeekEnd(this.vjsPlayer.currentTime());
  };

  /**
   * Called on the player's 'ready' event to begin initiating IMA.
   */
  PlayerWrapper$2.prototype.onPlayerReady = function () {
    this.h5Player = document.getElementById(this.getPlayerId()).getElementsByClassName('vjs-tech')[0];
    this.daiController.onPlayerReady();
  };

  /**
   * @return {!Object} The stream player.
   */
  PlayerWrapper$2.prototype.getStreamPlayer = function () {
    return this.h5Player;
  };

  /**
   * @return {!Object} The video.js player.
   */
  PlayerWrapper$2.prototype.getVjsPlayer = function () {
    return this.vjsPlayer;
  };

  /**
   * @return {!Object} The vjs player's options object.
   */
  PlayerWrapper$2.prototype.getPlayerOptions = function () {
    return this.vjsPlayer.options_;
  };

  /**
   * Returns the instance of the player id.
   * @return {string} The player id.
   */
  PlayerWrapper$2.prototype.getPlayerId = function () {
    return this.vjsPlayer.id();
  };

  /**
   * Handles ad errors.
   *
   * @param {!Object} adErrorEvent The ad error event thrown by the IMA SDK.
   */
  PlayerWrapper$2.prototype.onAdError = function (adErrorEvent) {
    this.vjsControls.show();
    var errorMessage = adErrorEvent.getError !== undefined ? adErrorEvent.getError() : adErrorEvent.stack;
    this.vjsPlayer.trigger({
      type: 'adserror', data: {
        AdError: errorMessage,
        AdErrorEvent: adErrorEvent
      }
    });
  };

  /**
   * Handles ad break starting.
   */
  PlayerWrapper$2.prototype.onAdBreakStart = function () {
    this.vjsControls.hide();
  };

  /**
   * Handles ad break ending.
   */
  PlayerWrapper$2.prototype.onAdBreakEnd = function () {
    this.vjsControls.show();
  };

  /**
   * Reset the player.
   */
  PlayerWrapper$2.prototype.reset = function () {
    this.vjsControls.show();
  };

  /**
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */

  /**
   * Implementation of the IMA DAI SDK for the plugin.
   *
   * @param {DaiController!} daiController Reference to the parent DAI
   * controller.
   *
   * @constructor
   * @struct
   * @final
   */
  var SdkImpl$2 = function SdkImpl(daiController) {
    /**
     * Plugin DAI controller.
     */
    this.daiController = daiController;

    /**
     * The html5 stream player.
     */
    this.streamPlayer = null;

    /**
     * The tm_videojs stream player.
     */
    this.vjsPlayer = null;

    /**
     * IMA SDK StreamManager
     */
    this.streamManager = null;

    /**
     * IMA stream UI settings.
     */
    /* eslint no-undef: 'error' */
    /* global google */
    this.uiSettings = new google.ima.dai.api.UiSettings();

    /**
     * If the stream is currently in an ad break.
     */
    this.isAdBreak = false;

    /**
     * If the stream is currently seeking from a snapback.
     */
    this.isSnapback = false;

    /**
     * Originally seeked to time, to return stream to after ads.
     */
    this.snapForwardTime = 0;

    /**
     * Timed metadata for the stream.
     */
    this.timedMetadata;

    /**
     * Timed metadata record.
     */
    this.metadataLoaded = {};

    this.SOURCE_TYPES = {
      hls: 'application/x-mpegURL',
      dash: 'application/dash+xml'
    };
  };

  /**
   * Creates and initializes the IMA DAI SDK objects.
   */
  SdkImpl$2.prototype.initImaDai = function () {
    this.streamPlayer = this.daiController.getStreamPlayer();
    this.vjsPlayer = this.daiController.getVjsPlayer();

    this.createAdUiDiv();
    if (this.daiController.getSettings().locale) {
      this.uiSettings.setLocale(this.daiController.getSettings().locale);
    }

    this.streamManager = new google.ima.dai.api.StreamManager(this.streamPlayer, this.adUiDiv, this.uiSettings);

    this.streamPlayer.addEventListener('pause', this.onStreamPause);
    this.streamPlayer.addEventListener('play', this.onStreamPlay);

    this.streamManager.addEventListener([google.ima.dai.api.StreamEvent.Type.LOADED, google.ima.dai.api.StreamEvent.Type.ERROR, google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED, google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED], this.onStreamEvent.bind(this), false);

    this.vjsPlayer.textTracks().onaddtrack = this.onAddTrack.bind(this);

    this.vjsPlayer.trigger({
      type: 'stream-manager',
      StreamManager: this.streamManager
    });

    this.requestStream();
  };

  /**
   * Called when the video player has metadata to process.
   * @param {Event!} event The event that triggered this call.
   */
  SdkImpl$2.prototype.onAddTrack = function (event) {
    var _this = this;

    var track = event.track;
    if (track.kind === 'metadata') {
      track.mode = 'hidden';
      track.oncuechange = function (e) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = track.activeCues_[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var cue = _step.value;

            var metadata = {};
            metadata[cue.value.key] = cue.value.data;
            _this.streamManager.onTimedMetadata(metadata);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };
    }
  };

  /**
   * Creates the ad UI container.
   */
  SdkImpl$2.prototype.createAdUiDiv = function () {
    var uiDiv = document.createElement('div');
    uiDiv.id = 'ad-ui';
    // 3em is the height of the control bar.
    uiDiv.style.height = 'calc(100% - 3em)';
    this.streamPlayer.parentNode.appendChild(uiDiv);
    this.adUiDiv = uiDiv;
  };

  /**
   * Called on pause to update the ad UI.
   */
  SdkImpl$2.prototype.onStreamPause = function () {
    if (this.isAdBreak) {
      this.adUiDiv.style.display = 'none';
    }
  };

  /**
   * Called on play to update the ad UI.
   */
  SdkImpl$2.prototype.onStreamPlay = function () {
    if (this.isAdBreak) {
      this.adUiDiv.style.display = 'block';
    }
  };

  /**
   * Called on play to update the ad UI.
   * @param {number} currentTime the current time of the stream.
   */
  SdkImpl$2.prototype.onSeekEnd = function (currentTime) {
    var streamType = this.daiController.getSettings().streamType;
    if (streamType === 'live') {
      return;
    }
    if (this.isSnapback) {
      this.isSnapback = false;
      return;
    }
    var previousCuePoint = this.streamManager.previousCuePointForStreamTime(currentTime);
    if (previousCuePoint && !previousCuePoint.played) {
      this.isSnapback = true;
      this.snapForwardTime = currentTime;
      this.vjsPlayer.currentTime(previousCuePoint.start);
    }
  };

  /**
   * Handles IMA events.
   * @param {google.ima.StreamEvent!} event the IMA event
   */
  SdkImpl$2.prototype.onStreamEvent = function (event) {
    switch (event.type) {
      case google.ima.dai.api.StreamEvent.Type.LOADED:
        this.loadUrl(event.getStreamData().url);
        break;
      case google.ima.dai.api.StreamEvent.Type.ERROR:
        // window.console.warn('Error loading stream, attempting to play backup ' + 'stream. ' + event.getStreamData().errorMessage);
        this.daiController.onErrorLoadingAds(event);
        if (this.daiController.getSettings().fallbackStreamUrl) {
          this.loadurl(this.daiController.getSettings().fallbackStreamUrl);
        }
        break;
      case google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED:
        this.isAdBreak = true;
        this.adUiDiv.style.display = 'block';
        this.daiController.onAdBreakStart();
        break;
      case google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED:
        this.isAdBreak = false;
        this.adUiDiv.style.display = 'none';
        this.daiController.onAdBreakEnd();
        if (this.snapForwardTime && this.snapForwardTime > this.vjsPlayer.currentTime()) {
          this.vjsPlayer.currentTime(this.snapForwardTime);
          this.snapForwardTime = 0;
        }
        break;
      default:
        break;
    }
  };

  /**
   * Loads the stream URL .
   * @param {string} streamUrl the URL for the stream being loaded.
   */
  SdkImpl$2.prototype.loadUrl = function (streamUrl) {
    this.vjsPlayer.ready(function () {
      var streamFormat = this.daiController.getSettings().streamFormat;
      this.vjsPlayer.src({
        src: streamUrl,
        type: this.SOURCE_TYPES[streamFormat]
      });

      var bookmarkTime = this.daiController.getSettings().bookmarkTime;
      if (bookmarkTime) {
        var startTime = this.streamManager.streamTimeForContentTime(bookmarkTime);
        // Seeking on load triggers the onSeekEnd event, so treat this seek as
        // if it's snapback. Without this, resuming at a bookmark kicks you
        // back to the ad before the bookmark.
        this.isSnapback = true;
        this.vjsPlayer.currentTime(startTime);
      }
    }.bind(this));
  };

  /**
   * Creates the AdsRequest and request ads through the AdsLoader.
   */
  SdkImpl$2.prototype.requestStream = function () {
    var streamRequest = void 0;
    var streamType = this.daiController.getSettings().streamType;
    if (streamType === 'vod') {
      streamRequest = new google.ima.dai.api.VODStreamRequest();
      streamRequest.contentSourceId = this.daiController.getSettings().cmsId;
      streamRequest.videoId = this.daiController.getSettings().videoId;
    } else if (streamType === 'live') {
      streamRequest = new google.ima.dai.api.LiveStreamRequest();
      streamRequest.assetKey = this.daiController.getSettings().assetKey;
    } else {
      // window.console.warn('No valid stream type selected');
    }
    streamRequest.format = this.daiController.getSettings().streamFormat;

    if (this.daiController.getSettings().apiKey) {
      streamRequest.apiKey = this.daiController.getSettings().apiKey;
    }
    if (this.daiController.getSettings().authToken) {
      streamRequest.authToken = this.daiController.getSettings().authToken;
    }
    if (this.daiController.getSettings().adTagParameters) {
      streamRequest.adTagParameters = this.daiController.getSettings().adTagParameters;
    }
    if (this.daiController.getSettings().streamActivityMonitorId) {
      streamRequest.streamActivityMonitorId = this.daiController.getSettings().streamActivityMonitorId;
    }

    if (this.daiController.getSettings().omidMode) {
      streamRequest.omidAccessModeRules = {};
      var omidValues = this.daiController.getSettings().omidMode;

      if (omidValues.FULL) {
        streamRequest.omidAccessModeRules[google.ima.OmidAccessMode.FULL] = omidValues.FULL;
      }
      if (omidValues.DOMAIN) {
        streamRequest.omidAccessModeRules[google.ima.OmidAccessMode.DOMAIN] = omidValues.DOMAIN;
      }
      if (omidValues.LIMITED) {
        streamRequest.omidAccessModeRules[google.ima.OmidAccessMode.LIMITED] = omidValues.LIMITED;
      }
    }

    this.streamManager.requestStream(streamRequest);
    this.vjsPlayer.trigger({
      type: 'stream-request',
      StreamRequest: streamRequest
    });
  };

  /**
   * Initiates IMA when the player is ready.
   */
  SdkImpl$2.prototype.onPlayerReady = function () {
    this.initImaDai();
  };

  /**
   * Reset the StreamManager when the player is disposed.
   */
  SdkImpl$2.prototype.onPlayerDisposed = function () {
    if (this.streamManager) {
      this.streamManager.reset();
    }
  };

  /**
   * Returns the instance of the StreamManager.
   * @return {google.ima.StreamManager!} The StreamManager being used by the
   * plugin.
   */
  SdkImpl$2.prototype.getStreamManager = function () {
    return this.StreamManager;
  };

  /**
   * Reset the SDK implementation.
   */
  SdkImpl$2.prototype.reset = function () {
    if (this.StreamManager) {
      this.StreamManager.reset();
    }
  };

  /**
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */
  /**
   * The coordinator for the DAI portion of the plugin. Facilitates
   * communication between all other plugin classes.
   *
   * @param {Object!} player Instance of the video.js player.
   * @param {Object!} options Options provided by the implementation.
   * @constructor
   * @struct
   * @final
   */
  var DaiController = function DaiController(player, options) {
    /**
    * If the stream is currently in an ad break.
    * @type {boolean}
    */
    this.inAdBreak = false;

    /**
    * Stores user-provided settings.
    * @type {Object!}
    */
    this.settings = {};

    /**
    * Whether or not we are running on a mobile platform.
    */
    this.isMobile = navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/Android/i);

    /**
    * Whether or not we are running on an iOS platform.
    */
    this.isIos = navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i);

    this.initWithSettings(options);

    /**
    * Stores contrib-ads default settings.
    */
    var contribAdsDefaults = {
      debug: this.settings.debug,
      timeout: this.settings.timeout,
      prerollTimeout: this.settings.prerollTimeout
    };
    var adsPluginSettings = Object.assign({}, contribAdsDefaults, options.contribAdsSettings || {});

    this.playerWrapper = new PlayerWrapper$2(player, adsPluginSettings, this);
    this.sdkImpl = new SdkImpl$2(this);
  };

  DaiController.IMA_DEFAULTS = {
    adLabel: 'Advertisement',
    adLabelNofN: 'of',
    debug: false,
    disableAdControls: false,
    showControlsForJSAds: true
  };

  /**
   * Extends the settings to include user-provided settings.
   *
   * @param {Object!} options Options to be used in initialization.
   */
  DaiController.prototype.initWithSettings = function (options) {
    this.settings = Object.assign({}, DaiController.IMA_DEFAULTS, options || {});

    this.warnAboutDeprecatedSettings();

    // Default showing countdown timer to true.
    this.showCountdown = true;
    if (this.settings.showCountdown === false) {
      this.showCountdown = false;
    }
  };

  /**
   * Logs console warnings when deprecated settings are used.
   */
  DaiController.prototype.warnAboutDeprecatedSettings = function () {
    var _this = this;

    var deprecatedSettings = [
      // Currently no DAI plugin settings are deprecated.
    ];
    deprecatedSettings.forEach(function (setting) {
      if (_this.settings[setting] !== undefined) {
        // console.warn('WARNING: tm_videojs.imaDai setting ' + setting + ' is deprecated');
      }
    });
  };

  /**
   * Return the settings object.
   *
   * @return {Object!} The settings object.
   */
  DaiController.prototype.getSettings = function () {
    return this.settings;
  };

  /**
   * Return whether or not we're in a mobile environment.
   *
   * @return {boolean} True if running on mobile, false otherwise.
   */
  DaiController.prototype.getIsMobile = function () {
    return this.isMobile;
  };

  /**
   * Return whether or not we're in an iOS environment.
   *
   * @return {boolean} True if running on iOS, false otherwise.
   */
  DaiController.prototype.getIsIos = function () {
    return this.isIos;
  };

  /**
   * @return {Object!} The html5 player.
   */
  DaiController.prototype.getStreamPlayer = function () {
    return this.playerWrapper.getStreamPlayer();
  };

  /**
   * @return {Object!} The video.js player.
   */
  DaiController.prototype.getVjsPlayer = function () {
    return this.playerWrapper.getVjsPlayer();
  };

  /**
   * Requests the stream.
   */
  DaiController.prototype.requestStream = function () {
    this.sdkImpl.requestStream();
  };

  /**
   * Add or modify a setting.
   *
   * @param {string} key Key to modify
   * @param {Object!} value Value to set at key.
  */
  DaiController.prototype.setSetting = function (key, value) {
    this.settings[key] = value;
  };

  /**
   * Called when there is an error loading ads.
   *
   * @param {Object!} adErrorEvent The ad error event thrown by the IMA SDK.
   */
  DaiController.prototype.onErrorLoadingAds = function (adErrorEvent) {
    this.playerWrapper.onAdError(adErrorEvent);
  };

  /**
   * Relays ad errors to the player wrapper.
   *
   * @param {Object!} adErrorEvent The ad error event thrown by the IMA SDK.
   */
  DaiController.prototype.onAdError = function (adErrorEvent) {
    this.playerWrapper.onAdError(adErrorEvent);
  };

  /**
   * Signals player that an ad break has started.
   */
  DaiController.prototype.onAdBreakStart = function () {
    this.inAdBreak = true;
    this.playerWrapper.onAdBreakStart();
  };

  /**
   * Signals player that an ad break has ended.
   */
  DaiController.prototype.onAdBreakEnd = function () {
    this.inAdBreak = false;
    this.playerWrapper.onAdBreakEnd();
  };

  /**
   * Called when the player is disposed.
   */
  DaiController.prototype.onPlayerDisposed = function () {
    this.contentAndAdsEndedListeners = [];
    this.sdkImpl.onPlayerDisposed();
  };

  /**
   * Returns if the stream is currently in an ad break.
   * @return {boolean} If the stream is currently in an ad break.
   */
  DaiController.prototype.isInAdBreak = function () {
    return this.inAdBreak;
  };

  /**
   * Called on seek end to check for ad snapback.
   * @param {number} currentTime the current time of the stream.
   */
  DaiController.prototype.onSeekEnd = function (currentTime) {
    this.sdkImpl.onSeekEnd(currentTime);
  };

  /**
   * Called when the player is ready.
   */
  DaiController.prototype.onPlayerReady = function () {
    this.sdkImpl.onPlayerReady();
  };

  /**
   * Resets the state of the plugin.
   */
  DaiController.prototype.reset = function () {
    this.sdkImpl.reset();
    this.playerWrapper.reset();
  };

  /**
   * Adds an EventListener to the StreamManager. For a list of available events,
   * see
   * https://developers.google.com/interactive-media-ads/docs/sdks/html5/dai/reference/js/StreamEvent
   * @param {google.ima.StreamEvent.Type!} event The AdEvent.Type for which to
   *     listen.
   * @param {callback!} callback The method to call when the event is fired.
   */
  DaiController.prototype.addEventListener = function (event, callback) {
    this.sdkImpl.addEventListener(event, callback);
  };

  /**
   * Returns the instance of the StreamManager.
   * @return {google.ima.StreamManager!} The StreamManager being used by the
   * plugin.
   */
  DaiController.prototype.getStreamManager = function () {
    return this.sdkImpl.getStreamManager();
  };

  /**
   * Returns the instance of the player id.
   * @return {string} The player id.
   */
  DaiController.prototype.getPlayerId = function () {
    return this.playerWrapper.getPlayerId();
  };

  /**
   * @return {boolean} true if we expect that the stream will autoplay. false
   * otherwise.
   */
  DaiController.prototype.streamWillAutoplay = function () {
    if (this.settings.streamWillAutoplay !== undefined) {
      return this.settings.streamWillAutoplay;
    } else {
      return !!this.playerWrapper.getPlayerOptions().autoplay;
    }
  };

  /**
   * Triggers an event on the VJS player
   * @param  {string} name The event name.
   * @param  {Object!} data The event data.
   */
  DaiController.prototype.triggerPlayerEvent = function (name, data) {
    this.playerWrapper.triggerPlayerEvent(name, data);
  };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * IMA SDK integration plugin for Video.js. For more information see
   * https://www.github.com/googleads/tm_videojs-ima
   */

  /**
   * Exposes the ImaPlugin to a publisher implementation.
   *
   * @param {Object} player Instance of the video.js player to which this plugin
   *     will be added.
   * @param {Object} options Options provided by the implementation.
   * @constructor
   * @struct
   * @final
   */
  var ImaPlugin = function ImaPlugin(player, options) {
    this.controller = new Controller(player, options);

    /**
     * Listener JSDoc for ESLint. This listener can be passed to
     * addContent(AndAds)EndedListener.
     * @callback listener
     */

    /**
     * Adds a listener that will be called when content and all ads have
     * finished playing.
     * @param {listener} listener The listener to be called when content and ads
     *     complete.
     */
    this.addContentAndAdsEndedListener = function (listener) {
      this.controller.addContentAndAdsEndedListener(listener);
    }.bind(this);

    /**
     * Adds a listener for the 'contentended' event of the video player. This
     * should be used instead of setting an 'contentended' listener directly to
     * ensure that the ima can do proper cleanup of the SDK before other event
     * listeners are called.
     * @param {listener} listener The listener to be called when content
     *     completes.
     */
    this.addContentEndedListener = function (listener) {
      this.controller.addContentEndedListener(listener);
    }.bind(this);

    /**
     * Callback JSDoc for ESLint. This callback can be passed to addEventListener.
     * @callback callback
     */

    /**
     * Ads an EventListener to the AdsManager. For a list of available events,
     * see
     * https://developers.google.com/interactive-media-ads/docs/sdks/html5/client-side/reference/js/google.ima.AdEvent#.Type
     * @param {google.ima.AdEvent.Type} event The AdEvent.Type for which to
     *     listen.
     * @param {callback} callback The method to call when the event is fired.
     */
    this.addEventListener = function (event, callback) {
      this.controller.addEventListener(event, callback);
    }.bind(this);

    /**
     * Changes the ad tag. You will need to call requestAds after this method
     * for the new ads to be requested.
     * @param {?string} adTag The ad tag to be requested the next time requestAds
     *     is called.
     */
    this.changeAdTag = function (adTag) {
      this.controller.changeAdTag(adTag);
    }.bind(this);

    /**
     * Returns the instance of the AdsManager.
     * @return {google.ima.AdsManager} The AdsManager being used by the plugin.
     */
    this.getAdsManager = function () {
      return this.controller.getAdsManager();
    }.bind(this);

    /**
     * Initializes the AdDisplayContainer. On mobile, this must be done as a
     * result of user action.
     */
    this.initializeAdDisplayContainer = function () {
      this.controller.initializeAdDisplayContainer();
    }.bind(this);

    /**
     * Pauses the ad.
     */
    this.pauseAd = function () {
      this.controller.pauseAd();
    }.bind(this);

    /**
     * Called by publishers in manual ad break playback mode to start an ad
     * break.
     */
    this.playAdBreak = function () {
      this.controller.playAdBreak();
    }.bind(this);

    /**
     * Creates the AdsRequest and request ads through the AdsLoader.
     */
    this.requestAds = function (isItAutoPlay) {
      this.controller.requestAds(isItAutoPlay);
    }.bind(this);

    /**
     * Resumes the ad.
     */
    this.resumeAd = function () {
      this.controller.resumeAd();
    }.bind(this);

    /**
     * Sets the listener to be called to trigger manual ad break playback.
     * @param {listener} listener The listener to be called to trigger manual ad
     *     break playback.
     */
    this.setAdBreakReadyListener = function (listener) {
      this.controller.setAdBreakReadyListener(listener);
    }.bind(this);

    /**
     * Sets the content of the video player. You should use this method instead
     * of setting the content src directly to ensure the proper ad tag is
     * requested when the video content is loaded.
     * @param {?string} contentSrc The URI for the content to be played. Leave
     *     blank to use the existing content.
     * @param {?string} adTag The ad tag to be requested when the content loads.
     *     Leave blank to use the existing ad tag.
     */
    this.setContentWithAdTag = function (contentSrc, adTag) {
      this.controller.setContentWithAdTag(contentSrc, adTag);
    }.bind(this);

    /**
     * Sets the content of the video player. You should use this method instead
     * of setting the content src directly to ensure the proper ads response is
     * used when the video content is loaded.
     * @param {?string} contentSrc The URI for the content to be played. Leave
     *     blank to use the existing content.
     * @param {?string} adsResponse The ads response to be requested when the
     *     content loads. Leave blank to use the existing ads response.
     */
    this.setContentWithAdsResponse = function (contentSrc, adsResponse) {
      this.controller.setContentWithAdsResponse(contentSrc, adsResponse);
    }.bind(this);

    /**
     * Sets the content of the video player. You should use this method instead
     * of setting the content src directly to ensure the proper ads request is
     * used when the video content is loaded.
     * @param {?string} contentSrc The URI for the content to be played. Leave
     *     blank to use the existing content.
     * @param {?Object} adsRequest The ads request to be requested when the
     *     content loads. Leave blank to use the existing ads request.
     */
    this.setContentWithAdsRequest = function (contentSrc, adsRequest) {
      this.controller.setContentWithAdsRequest(contentSrc, adsRequest);
    }.bind(this);

    /**
     * Changes the flag to show or hide the ad countdown timer.
     *
     * @param {boolean} showCountdownIn Show or hide the countdown timer.
     */
    this.setShowCountdown = function (showCountdownIn) {
      this.controller.setShowCountdown(showCountdownIn);
    }.bind(this);
  };

  /**
   * Exposes the ImaDaiPlugin to a publisher implementation.
   *
   * @param {Object} player Instance of the video.js player to which this plugin
   *     will be added.
   * @param {Object} options Options provided by the implementation.
   * @constructor
   * @struct
   * @final
   */
  var ImaDaiPlugin = function ImaDaiPlugin(player, options) {
    this.controller = new DaiController(player, options);

    /**
     * Adds a listener that will be called when content and all ads in the
     * stream have finished playing. VOD stream only.
     * @param {listener} listener The listener to be called when content and ads
     *     complete.
     */
    this.streamEndedListener = function (listener) {
      this.controller.addStreamEndedListener(listener);
    }.bind(this);

    /**
     * Adds an EventListener to the StreamManager.
     * @param {google.ima.StreamEvent.Type} event The StreamEvent.Type for which
     * to listen.
     * @param {callback} callback The method to call when the event is fired.
     */
    this.addEventListener = function (event, callback) {
      this.controller.addEventListener(event, callback);
    }.bind(this);

    /**
     * Returns the instance of the StreamManager.
     * @return {google.ima.StreamManager} The StreamManager being used by the
     * plugin.
     */
    this.getStreamManager = function () {
      return this.controller.getStreamManager();
    }.bind(this);
  };

  /**
   * Initializes the plugin for client-side ads.
   * @param {Object} options Plugin option set on initiation.
   */
  var init = function init(options) {
    /* eslint no-invalid-this: 'off' */
    this.ima = new ImaPlugin(this, options);
  };

  /**
   * LiveStream class used for DAI live streams.
   */

  var LiveStream =
    /**
     * LiveStream class constructor used for DAI live streams.
     * @param {string} streamFormat stream format, plugin currently supports only
     * 'hls' streams.
     * @param {string} assetKey live stream's asset key.
     */
    function LiveStream(streamFormat, assetKey) {
      _classCallCheck(this, LiveStream);

      streamFormat = streamFormat.toLowerCase();
      if (streamFormat !== 'hls' && streamFormat !== 'dash') {
        // window.console.error('VodStream error: incorrect streamFormat.');
        return;
      } else if (streamFormat === 'dash') {
        // window.console.error('streamFormat error: DASH streams are not' + 'currently supported by this plugin.');
        return;
      } else if (typeof assetKey !== 'string') {
        // window.console.error('assetKey error: value must be string.');
        return;
      }
      this.streamFormat = streamFormat;
      this.assetKey = assetKey;
    };

  /**
   * VodStream class used for DAI VOD streams.
   */


  var VodStream =
    /**
     * VodStream class constructor used for DAI VOD streams.
     * @param {string} streamFormat stream format, plugin currently supports only
     * 'hls' streams.
     * @param {string} cmsId VOD stream's CMS ID.
     * @param {string} videoId VOD stream's video ID.
     */
    function VodStream(streamFormat, cmsId, videoId) {
      _classCallCheck(this, VodStream);

      streamFormat = streamFormat.toLowerCase();
      if (streamFormat !== 'hls' && streamFormat !== 'dash') {
        window.console.error('VodStream error: incorrect streamFormat.');
        return;
      } else if (streamFormat === 'dash') {
        window.console.error('streamFormat error: DASH streams are not' + 'currently supported by this plugin.');
        return;
      } else if (typeof cmsId !== 'string') {
        window.console.error('cmsId error: value must be string.');
        return;
      } else if (typeof videoId !== 'string') {
        window.console.error('videoId error: value must be string.');
        return;
      }

      this.streamFormat = streamFormat;
      this.cmsId = cmsId;
      this.videoId = videoId;
    };

  /**
   * Initializes the plugin for DAI ads.
   * @param {Object} stream Accepts either an instance of the LiveStream or
   * VodStream classes.
   * @param {Object} options Plugin option set on initiation.
   */


  var initDai = function initDai(stream, options) {
    if (stream instanceof LiveStream) {
      options.streamType = 'live';
      options.assetKey = stream.assetKey;
    } else if (stream instanceof VodStream) {
      options.streamType = 'vod';
      options.cmsId = stream.cmsId;
      options.videoId = stream.videoId;
    } else {
      window.console.error('initDai() first parameter must be an instance of LiveStream or ' + 'VodStream.');
      return;
    }

    options.streamFormat = stream.streamFormat;
    /* eslint no-invalid-this: 'off' */
    this.imaDai = new ImaDaiPlugin(this, options);
  };

  var registerPlugin = tm_videojs.registerPlugin || tm_videojs.plugin;
  registerPlugin('ima', init);
  registerPlugin('imaDai', initDai);

  exports['default'] = ImaPlugin;
  exports.VodStream = VodStream;
  exports.LiveStream = LiveStream;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.owns = function (a, c) {
  return Object.prototype.hasOwnProperty.call(a, c)
}
  ;
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, c, e) {
  a != Array.prototype && a != Object.prototype && (a[c] = e.value)
}
  ;
$jscomp.getGlobal = function (a) {
  return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a
}
  ;
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function (a, c, e, f) {
  if (c) {
    e = $jscomp.global;
    a = a.split(".");
    for (f = 0; f < a.length - 1; f++) {
      var b = a[f];
      b in e || (e[b] = {});
      e = e[b]
    }
    a = a[a.length - 1];
    f = e[a];
    c = c(f);
    c != f && null != c && $jscomp.defineProperty(e, a, {
      configurable: !0,
      writable: !0,
      value: c
    })
  }
}
  ;
$jscomp.polyfill("Object.assign", function (a) {
  return a ? a : function (a, e) {
    for (var c = 1; c < arguments.length; c++) {
      var b = arguments[c];
      if (b)
        for (var g in b)
          $jscomp.owns(b, g) && (a[g] = b[g])
    }
    return a
  }
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function () {
  $jscomp.initSymbol = function () { }
    ;
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol)
}
  ;
$jscomp.Symbol = function () {
  var a = 0;
  return function (c) {
    return $jscomp.SYMBOL_PREFIX + (c || "") + a++
  }
}();
$jscomp.initSymbolIterator = function () {
  $jscomp.initSymbol();
  var a = $jscomp.global.Symbol.iterator;
  a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {
    configurable: !0,
    writable: !0,
    value: function () {
      return $jscomp.arrayIterator(this)
    }
  });
  $jscomp.initSymbolIterator = function () { }
}
  ;
$jscomp.arrayIterator = function (a) {
  var c = 0;
  return $jscomp.iteratorPrototype(function () {
    return c < a.length ? {
      done: !1,
      value: a[c++]
    } : {
      done: !0
    }
  })
}
  ;
$jscomp.iteratorPrototype = function (a) {
  $jscomp.initSymbolIterator();
  a = {
    next: a
  };
  a[$jscomp.global.Symbol.iterator] = function () {
    return this
  }
    ;
  return a
}
  ;
$jscomp.makeIterator = function (a) {
  $jscomp.initSymbolIterator();
  var c = a[Symbol.iterator];
  return c ? c.call(a) : $jscomp.arrayIterator(a)
}
  ;
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function (a) {
  function c() {
    this.batch_ = null
  }
  function e(d) {
    return d instanceof b ? d : new b(function (a, b) {
      a(d)
    }
    )
  }
  if (a && !$jscomp.FORCE_POLYFILL_PROMISE)
    return a;
  c.prototype.asyncExecute = function (d) {
    null == this.batch_ && (this.batch_ = [],
      this.asyncExecuteBatch_());
    this.batch_.push(d);
    return this
  }
    ;
  c.prototype.asyncExecuteBatch_ = function () {
    var d = this;
    this.asyncExecuteFunction(function () {
      d.executeBatch_()
    })
  }
    ;
  var f = $jscomp.global.setTimeout;
  c.prototype.asyncExecuteFunction = function (d) {
    f(d, 0)
  }
    ;
  c.prototype.executeBatch_ = function () {
    for (; this.batch_ && this.batch_.length;) {
      var d = this.batch_;
      this.batch_ = [];
      for (var a = 0; a < d.length; ++a) {
        var b = d[a];
        delete d[a];
        try {
          b()
        } catch (h) {
          this.asyncThrow_(h)
        }
      }
    }
    this.batch_ = null
  }
    ;
  c.prototype.asyncThrow_ = function (d) {
    this.asyncExecuteFunction(function () {
      throw d;
    })
  }
    ;
  var b = function (d) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var a = this.createResolveAndReject_();
    try {
      d(a.resolve, a.reject)
    } catch (l) {
      a.reject(l)
    }
  };
  b.prototype.createResolveAndReject_ = function () {
    function a(a) {
      return function (d) {
        c || (c = !0,
          a.call(b, d))
      }
    }
    var b = this
      , c = !1;
    return {
      resolve: a(this.resolveTo_),
      reject: a(this.reject_)
    }
  }
    ;
  b.prototype.resolveTo_ = function (a) {
    if (a === this)
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    else if (a instanceof b)
      this.settleSameAsPromise_(a);
    else {
      a: switch (typeof a) {
        case "object":
          var d = null != a;
          break a;
        case "function":
          d = !0;
          break a;
        default:
          d = !1
      }
      d ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a)
    }
  }
    ;
  b.prototype.resolveToNonPromiseObj_ = function (a) {
    var b = void 0;
    try {
      b = a.then
    } catch (l) {
      this.reject_(l);
      return
    }
    "function" == typeof b ? this.settleSameAsThenable_(b, a) : this.fulfill_(a)
  }
    ;
  b.prototype.reject_ = function (a) {
    this.settle_(2, a)
  }
    ;
  b.prototype.fulfill_ = function (a) {
    this.settle_(1, a)
  }
    ;
  b.prototype.settle_ = function (a, b) {
    if (0 != this.state_)
      throw Error("Cannot settle(" + a + ", " + b | "): Promise already settled in state" + this.state_);
    this.state_ = a;
    this.result_ = b;
    this.executeOnSettledCallbacks_()
  }
    ;
  b.prototype.executeOnSettledCallbacks_ = function () {
    if (null != this.onSettledCallbacks_) {
      for (var a = this.onSettledCallbacks_, b = 0; b < a.length; ++b)
        a[b].call(),
          a[b] = null;
      this.onSettledCallbacks_ = null
    }
  }
    ;
  var g = new c;
  b.prototype.settleSameAsPromise_ = function (a) {
    var b = this.createResolveAndReject_();
    a.callWhenSettled_(b.resolve, b.reject)
  }
    ;
  b.prototype.settleSameAsThenable_ = function (a, b) {
    var c = this.createResolveAndReject_();
    try {
      a.call(b, c.resolve, c.reject)
    } catch (h) {
      c.reject(h)
    }
  }
    ;
  b.prototype.then = function (a, c) {
    function d(a, b) {
      return "function" == typeof a ? function (b) {
        try {
          h(a(b))
        } catch (m) {
          e(m)
        }
      }
        : b
    }
    var h, e, g = new b(function (a, b) {
      h = a;
      e = b
    }
    );
    this.callWhenSettled_(d(a, h), d(c, e));
    return g
  }
    ;
  b.prototype.catch = function (a) {
    return this.then(void 0, a)
  }
    ;
  b.prototype.callWhenSettled_ = function (a, b) {
    function c() {
      switch (d.state_) {
        case 1:
          a(d.result_);
          break;
        case 2:
          b(d.result_);
          break;
        default:
          throw Error("Unexpected state: " + d.state_);
      }
    }
    var d = this;
    null == this.onSettledCallbacks_ ? g.asyncExecute(c) : this.onSettledCallbacks_.push(function () {
      g.asyncExecute(c)
    })
  }
    ;
  b.resolve = e;
  b.reject = function (a) {
    return new b(function (b, c) {
      c(a)
    }
    )
  }
    ;
  b.race = function (a) {
    return new b(function (b, c) {
      for (var d = $jscomp.makeIterator(a), g = d.next(); !g.done; g = d.next())
        e(g.value).callWhenSettled_(b, c)
    }
    )
  }
    ;
  b.all = function (a) {
    var c = $jscomp.makeIterator(a)
      , d = c.next();
    return d.done ? e([]) : new b(function (a, b) {
      function g(b) {
        return function (c) {
          f[b] = c;
          h--;
          0 == h && a(f)
        }
      }
      var f = []
        , h = 0;
      do
        f.push(void 0),
          h++,
          e(d.value).callWhenSettled_(g(f.length - 1), b),
          d = c.next();
      while (!d.done)
    }
    )
  }
    ;
  return b
}, "es6", "es3");
(function (a, c) {
  "object" === typeof exports && "undefined" !== typeof module ? module.exports = c() : "function" === typeof define && define.amd ? define(c) : a.canAutoplay = c()
}
)(this, function () {
  function a(a) {
    return Object.assign({
      muted: !1,
      timeout: 250,
      inline: !1
    }, a)
  }
  function c(a, c) {
    var b = a.muted
      , e = a.timeout;
    a = a.inline;
    c = c();
    var f = c.element;
    c = c.source;
    var h = void 0
      , g = void 0
      , k = void 0;
    f.muted = b;
    !0 === b && f.setAttribute("muted", "muted");
    !0 === a && f.setAttribute("playsinline", "playsinline");
    f.src = c;
    return new Promise(function (a) {
      h = f.play();
      g = setTimeout(function () {
        k(!1, Error("Timeout " + e + " ms has been reached"))
      }, e);
      k = function (b) {
        var c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
        clearTimeout(g);
        a({
          result: b,
          error: c
        })
      }
        ;
      void 0 !== h ? h.then(function () {
        return k(!0)
      }).catch(function (a) {
        return k(!1, a)
      }) : k(!0)
    }
    )
  }
  var e = new Blob([new Uint8Array([255, 227, 24, 196, 0, 0, 0, 3, 72, 1, 64, 0, 0, 4, 132, 16, 31, 227, 192, 225, 76, 255, 67, 12, 255, 221, 27, 255, 228, 97, 73, 63, 255, 195, 131, 69, 192, 232, 223, 255, 255, 207, 102, 239, 255, 255, 255, 101, 158, 206, 70, 20, 59, 255, 254, 95, 70, 149, 66, 4, 16, 128, 0, 2, 2, 32, 240, 138, 255, 36, 106, 183, 255, 227, 24, 196, 59, 11, 34, 62, 80, 49, 135, 40, 0, 253, 29, 191, 209, 200, 141, 71, 7, 255, 252, 152, 74, 15, 130, 33, 185, 6, 63, 255, 252, 195, 70, 203, 86, 53, 15, 255, 255, 247, 103, 76, 121, 64, 32, 47, 255, 34, 227, 194, 209, 138, 76, 65, 77, 69, 51, 46, 57, 55, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 227, 24, 196, 73, 13, 153, 210, 100, 81, 135, 56, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170])], {
    type: "audio/mpeg"
  })
    , f = new Blob([new Uint8Array([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109, 0, 0, 2, 0, 105, 115, 111, 109, 105, 115, 111, 50, 109, 112, 52, 49, 0, 0, 0, 8, 102, 114, 101, 101, 0, 0, 2, 239, 109, 100, 97, 116, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 0, 0, 2, 194, 109, 111, 111, 118, 0, 0, 0, 108, 109, 118, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232, 0, 0, 0, 47, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 236, 116, 114, 97, 107, 0, 0, 0, 92, 116, 107, 104, 100, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 101, 100, 116, 115, 0, 0, 0, 28, 101, 108, 115, 116, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 47, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 100, 109, 100, 105, 97, 0, 0, 0, 32, 109, 100, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 68, 0, 0, 8, 0, 85, 196, 0, 0, 0, 0, 0, 45, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0, 0, 0, 1, 15, 109, 105, 110, 102, 0, 0, 0, 16, 115, 109, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 100, 105, 110, 102, 0, 0, 0, 28, 100, 114, 101, 102, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1, 0, 0, 0, 211, 115, 116, 98, 108, 0, 0, 0, 103, 115, 116, 115, 100, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 87, 109, 112, 52, 97, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 16, 0, 0, 0, 0, 172, 68, 0, 0, 0, 0, 0, 51, 101, 115, 100, 115, 0, 0, 0, 0, 3, 128, 128, 128, 34, 0, 2, 0, 4, 128, 128, 128, 20, 64, 21, 0, 0, 0, 0, 1, 244, 0, 0, 1, 243, 249, 5, 128, 128, 128, 2, 18, 16, 6, 128, 128, 128, 1, 2, 0, 0, 0, 24, 115, 116, 116, 115, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 28, 115, 116, 115, 99, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 28, 115, 116, 115, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 115, 0, 0, 1, 116, 0, 0, 0, 20, 115, 116, 99, 111, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 98, 117, 100, 116, 97, 0, 0, 0, 90, 109, 101, 116, 97, 0, 0, 0, 0, 0, 0, 0, 33, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 109, 100, 105, 114, 97, 112, 112, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 105, 108, 115, 116, 0, 0, 0, 37, 169, 116, 111, 111, 0, 0, 0, 29, 100, 97, 116, 97, 0, 0, 0, 1, 0, 0, 0, 0, 76, 97, 118, 102, 53, 54, 46, 52, 48, 46, 49, 48, 49])], {
      type: "video/mp4"
    });
  return {
    audio: function (b) {
      b = a(b);
      return c(b, function () {
        return {
          element: document.createElement("audio"),
          source: URL.createObjectURL(e)
        }
      })
    },
    video: function (b) {
      b = a(b);
      return c(b, function () {
        return {
          element: document.createElement("video"),
          source: URL.createObjectURL(f)
        }
      })
    }
  }
});

/*! @name tm_videojs-playlist @version 5.1.0 @license Apache-2.0 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('video.js')) :
    typeof define === 'function' && define.amd ? define(['video.js'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.tm_videojsPlaylist = factory(global.tm_videojs));
})(this, (function (tm_videojs) {
  'use strict';

  function _interopDefaultLegacy(e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var tm_videojs__default = /*#__PURE__*/_interopDefaultLegacy(tm_videojs);

  /**
   * Validates a number of seconds to use as the auto-advance delay.
   *
   * @private
   * @param   {number} s
   *          The number to check
   *
   * @return  {boolean}
   *          Whether this is a valid second or not
   */
  const validSeconds = s => typeof s === 'number' && !isNaN(s) && s >= 0 && s < Infinity;
  /**
   * Resets the auto-advance behavior of a player.
   *
   * @param {Player} player
   *        The player to reset the behavior on
   */


  let reset = player => {
    const aa = player.playlist.autoadvance_;

    if (aa.timeout) {
      player.clearTimeout(aa.timeout);
    }

    if (aa.trigger) {
      player.off('ended', aa.trigger);
    }

    aa.timeout = null;
    aa.trigger = null;
  };
  /**
   * Sets up auto-advance behavior on a player.
   *
   * @param  {Player} player
   *         the current player
   *
   * @param  {number} delay
   *         The number of seconds to wait before each auto-advance.
   *
   * @return {undefined}
   *         Used to short circuit function logic
   */


  const setup = (player, delay) => {
    reset(player); // Before queuing up new auto-advance behavior, check if `seconds` was
    // called with a valid value.

    if (!validSeconds(delay)) {
      player.playlist.autoadvance_.delay = null;
      return;
    }

    player.playlist.autoadvance_.delay = delay;

    player.playlist.autoadvance_.trigger = function () {
      // This calls setup again, which will reset the existing auto-advance and
      // set up another auto-advance for the next "ended" event.
      const cancelOnPlay = () => setup(player, delay); // If there is a "play" event while we're waiting for an auto-advance,
      // we need to cancel the auto-advance. This could mean the user seeked
      // back into the content or restarted the content. This is reproducible
      // with an auto-advance > 0.


      player.one('play', cancelOnPlay);
      player.playlist.autoadvance_.timeout = player.setTimeout(() => {
        reset(player);
        player.off('play', cancelOnPlay);
        player.playlist.next();
      }, delay * 1000);
    };

    player.one('ended', player.playlist.autoadvance_.trigger);
  };

  /**
   * Removes all remote text tracks from a player.
   *
   * @param  {Player} player
   *         The player to clear tracks on
   */

  const clearTracks = player => {
    const tracks = player.remoteTextTracks();
    let i = tracks && tracks.length || 0; // This uses a `while` loop rather than `forEach` because the
    // `TextTrackList` object is a live DOM list (not an array).

    while (i--) {
      player.removeRemoteTextTrack(tracks[i]);
    }
  };
  /**
   * Plays an item on a player's playlist.
   *
   * @param  {Player} player
   *         The player to play the item on
   *
   * @param  {Object} item
   *         A source from the playlist.
   *
   * @return {Player}
   *         The player that is now playing the item
   */


  const playItem = (player, item) => {
    const replay = !player.paused() || player.ended();
    player.trigger('beforeplaylistitem', item.originalValue || item);

    if (item.playlistItemId_) {
      player.playlist.currentPlaylistItemId_ = item.playlistItemId_;
    }

    player.poster(item.poster || '');
    player.src(item.sources);
    clearTracks(player);
    player.ready(() => {
      (item.textTracks || []).forEach(player.addRemoteTextTrack.bind(player));
      player.trigger('playlistitem', item.originalValue || item);

      if (replay) {
        const playPromise = player.play(); // silence error when a pause interrupts a play request
        // on browsers which return a promise

        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {
          playPromise.then(null, e => { });
        }
      }

      setup(player, player.playlist.autoadvance_.delay);
    });
    return player;
  };

  let guid = 1;
  /**
   * Transform any primitive playlist item value into an object.
   *
   * For non-object values, adds a property to the transformed item containing
   * original value passed.
   *
   * For all items, add a unique ID to each playlist item object. This id is
   * used to determine the index of an item in the playlist array in cases where
   * there are multiple otherwise identical items.
   *
   * @param  {Object} newItem
   *         An playlist item object, but accepts any value.
   *
   * @return {Object}
   */

  const preparePlaylistItem = newItem => {
    let item = newItem;

    if (!newItem || typeof newItem !== 'object') {
      // Casting to an Object in this way allows primitives to retain their
      // primitiveness (i.e. they will be cast back to primitives as needed).
      item = Object(newItem);
      item.originalValue = newItem;
    }

    item.playlistItemId_ = guid++;
    return item;
  };
  /**
   * Look through an array of playlist items and passes them to
   * preparePlaylistItem.
   *
   * @private
   *
   * @param  {Array} arr
   *         An array of playlist items
   *
   * @return {Array}
   *         A new array with transformed items
   */


  const preparePlaylistItems = arr => arr.map(preparePlaylistItem);
  /**
   * Look through an array of playlist items for a specific playlist item id.
   *
   * @private
   * @param   {Array} list
   *          An array of playlist items to look through
   *
   * @param   {number} currentItemId
   *          The current item ID.
   *
   * @return  {number}
   *          The index of the playlist item or -1 if not found
   */


  const indexInPlaylistItemIds = (list, currentItemId) => {
    for (let i = 0; i < list.length; i++) {
      if (list[i].playlistItemId_ === currentItemId) {
        return i;
      }
    }

    return -1;
  };
  /**
   * Given two sources, check to see whether the two sources are equal.
   * If both source urls have a protocol, the protocols must match, otherwise, protocols
   * are ignored.
   *
   * @private
   * @param {string|Object} source1
   *        The first source
   *
   * @param {string|Object} source2
   *        The second source
   *
   * @return {boolean}
   *         The result
   */


  const sourceEquals = (source1, source2) => {
    let src1 = source1;
    let src2 = source2;

    if (typeof source1 === 'object') {
      src1 = source1.src;
    }

    if (typeof source2 === 'object') {
      src2 = source2.src;
    }

    if (/^\/\//.test(src1)) {
      src2 = src2.slice(src2.indexOf('//'));
    }

    if (/^\/\//.test(src2)) {
      src1 = src1.slice(src1.indexOf('//'));
    }

    return src1 === src2;
  };
  /**
   * Look through an array of playlist items for a specific `source`;
   * checking both the value of elements and the value of their `src`
   * property.
   *
   * @private
   * @param   {Array} arr
   *          An array of playlist items to look through
   *
   * @param   {string} src
   *          The source to look for
   *
   * @return  {number}
   *          The index of that source or -1
   */


  const indexInSources = (arr, src) => {
    for (let i = 0; i < arr.length; i++) {
      const sources = arr[i].sources;

      if (Array.isArray(sources)) {
        for (let j = 0; j < sources.length; j++) {
          const source = sources[j];

          if (source && sourceEquals(source, src)) {
            return i;
          }
        }
      }
    }

    return -1;
  };
  /**
   * Randomize the contents of an array.
   *
   * @private
   * @param  {Array} arr
   *         An array.
   *
   * @return {Array}
   *         The same array that was passed in.
   */


  const randomize = arr => {
    let index = -1;
    const lastIndex = arr.length - 1;

    while (++index < arr.length) {
      const rand = index + Math.floor(Math.random() * (lastIndex - index + 1));
      const value = arr[rand];
      arr[rand] = arr[index];
      arr[index] = value;
    }

    return arr;
  };
  /**
   * Factory function for creating new playlist implementation on the given player.
   *
   * API summary:
   *
   * playlist(['a', 'b', 'c']) // setter
   * playlist() // getter
   * playlist.currentItem() // getter, 0
   * playlist.currentItem(1) // setter, 1
   * playlist.next() // 'c'
   * playlist.previous() // 'b'
   * playlist.first() // 'a'
   * playlist.last() // 'c'
   * playlist.autoadvance(5) // 5 second delay
   * playlist.autoadvance() // cancel autoadvance
   *
   * @param  {Player} player
   *         The current player
   *
   * @param  {Array=} initialList
   *         If given, an initial list of sources with which to populate
   *         the playlist.
   *
   * @param  {number=}  initialIndex
   *         If given, the index of the item in the list that should
   *         be loaded first. If -1, no video is loaded. If omitted, The
   *         the first video is loaded.
   *
   * @return {Function}
   *         Returns the playlist function specific to the given player.
   */


  function factory(player, initialList, initialIndex = 0) {
    let list = null;
    let changing = false;
    /**
     * Get/set the playlist for a player.
     *
     * This function is added as an own property of the player and has its
     * own methods which can be called to manipulate the internal state.
     *
     * @param  {Array} [newList]
     *         If given, a new list of sources with which to populate the
     *         playlist. Without this, the function acts as a getter.
     *
     * @param  {number}  [newIndex]
     *         If given, the index of the item in the list that should
     *         be loaded first. If -1, no video is loaded. If omitted, The
     *         the first video is loaded.
     *
     * @return {Array}
     *         The playlist
     */

    const playlist = player.playlist = (nextPlaylist, newIndex = 0) => {
      if (changing) {
        throw new Error('do not call playlist() during a playlist change');
      }

      if (Array.isArray(nextPlaylist)) {
        // @todo - Simplify this to `list.slice()` for v5.
        const previousPlaylist = Array.isArray(list) ? list.slice() : null;
        list = preparePlaylistItems(nextPlaylist); // Mark the playlist as changing during the duringplaylistchange lifecycle.

        changing = true;
        player.trigger({
          type: 'duringplaylistchange',
          nextIndex: newIndex,
          nextPlaylist,
          previousIndex: playlist.currentIndex_,
          // @todo - Simplify this to simply pass along `previousPlaylist` for v5.
          previousPlaylist: previousPlaylist || []
        });
        changing = false;

        if (newIndex !== -1) {
          playlist.currentItem(newIndex);
        } // The only time the previous playlist is null is the first call to this
        // function. This allows us to fire the `duringplaylistchange` event
        // every time the playlist is populated and to maintain backward
        // compatibility by not firing the `playlistchange` event on the initial
        // population of the list.
        //
        // @todo - Remove this condition in preparation for v5.


        if (previousPlaylist) {
          player.setTimeout(() => {
            player.trigger({
              type: 'playlistchange',
              action: 'change'
            });
          }, 0);
        }
      } // Always return a shallow clone of the playlist list.
      // We also want to return originalValue if any item in the list has it.


      return list.map(item => item.originalValue || item);
    }; // On a new source, if there is no current item, disable auto-advance.


    player.on('loadstart', () => {
      if (playlist.currentItem() === -1) {
        reset(player);
      }
    });
    playlist.currentIndex_ = -1;
    playlist.player_ = player;
    playlist.autoadvance_ = {};
    playlist.repeat_ = false;
    playlist.currentPlaylistItemId_ = null;
    /**
     * Get or set the current item in the playlist.
     *
     * During the duringplaylistchange event, acts only as a getter.
     *
     * @param  {number} [index]
     *         If given as a valid value, plays the playlist item at that index.
     *
     * @return {number}
     *         The current item index.
     */

    playlist.currentItem = index => {
      // If the playlist is changing, only act as a getter.
      if (changing) {
        return playlist.currentIndex_;
      } // Act as a setter when the index is given and is a valid number.


      if (typeof index === 'number' && playlist.currentIndex_ !== index && index >= 0 && index < list.length) {
        playlist.currentIndex_ = index;
        playItem(playlist.player_, list[playlist.currentIndex_]); // When playing multiple videos in a playlist the tm_videojs PosterImage
        // will be hidden using CSS. However, in some browsers the native poster
        // attribute will briefly appear while the new source loads. Prevent
        // this by hiding every poster after the first play list item. This
        // doesn't cover every use case for showing/hiding the poster, but
        // it will significantly improve the user experience.

        if (index > 0) {
          player.poster('');
        }

        return playlist.currentIndex_;
      }

      const src = playlist.player_.currentSrc() || ''; // If there is a currentPlaylistItemId_, validate that it matches the
      // current source URL returned by the player. This is sufficient evidence
      // to suggest that the source was set by the playlist plugin. This code
      // exists primarily to deal with playlists where multiple items have the
      // same source.

      if (playlist.currentPlaylistItemId_) {
        const indexInItemIds = indexInPlaylistItemIds(list, playlist.currentPlaylistItemId_);
        const item = list[indexInItemIds]; // Found a match, this is our current index!

        if (item && Array.isArray(item.sources) && indexInSources([item], src) > -1) {
          playlist.currentIndex_ = indexInItemIds;
          return playlist.currentIndex_;
        } // If this does not match the current source, null it out so subsequent
        // calls can skip this step.


        playlist.currentPlaylistItemId_ = null;
      } // Finally, if we don't have a valid, current playlist item ID, we can
      // auto-detect it based on the player's current source URL.


      playlist.currentIndex_ = playlist.indexOf(src);
      return playlist.currentIndex_;
    };
    /**
     * A custom DOM event that is fired when new item(s) are added to the current
     * playlist (rather than replacing the entire playlist).
     *
     * Unlike playlistchange, this is fired synchronously as it does not
     * affect playback.
     *
     * @typedef  {Object} PlaylistAddEvent
     * @see      [CustomEvent Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
     * @property {string} type
     *           Always "playlistadd"
     *
     * @property {number} count
     *           The number of items that were added.
     *
     * @property {number} index
     *           The starting index where item(s) were added.
     */

    /**
     * A custom DOM event that is fired when new item(s) are removed from the
     * current playlist (rather than replacing the entire playlist).
     *
     * This is fired synchronously as it does not affect playback.
     *
     * @typedef  {Object} PlaylistRemoveEvent
     * @see      [CustomEvent Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
     * @property {string} type
     *           Always "playlistremove"
     *
     * @property {number} count
     *           The number of items that were removed.
     *
     * @property {number} index
     *           The starting index where item(s) were removed.
     */

    /**
     * Add one or more items to the playlist.
     *
     * @fires  {PlaylistAddEvent}
     * @throws {Error}
     *         If called during the duringplaylistchange event, throws an error.
     *
     * @param  {string|Object|Array}  item
     *         An item - or array of items - to be added to the playlist.
     *
     * @param  {number} [index]
     *         If given as a valid value, injects the new playlist item(s)
     *         starting from that index. Otherwise, the item(s) are appended.
     */


    playlist.add = (items, index) => {
      if (changing) {
        throw new Error('cannot modify a playlist that is currently changing');
      }

      if (typeof index !== 'number' || index < 0 || index > list.length) {
        index = list.length;
      }

      if (!Array.isArray(items)) {
        items = [items];
      }

      list.splice(index, 0, ...preparePlaylistItems(items)); // playlistchange is triggered synchronously in this case because it does
      // not change the current media source

      player.trigger({
        type: 'playlistchange',
        action: 'add'
      });
      player.trigger({
        type: 'playlistadd',
        count: items.length,
        index
      });
    };
    /**
     * Remove one or more items from the playlist.
     *
     * @fires  {PlaylistRemoveEvent}
     * @throws {Error}
     *         If called during the duringplaylistchange event, throws an error.
     *
     * @param  {number} index
     *         If a valid index in the current playlist, removes the item at that
     *         index from the playlist.
     *
     *         If no valid index is given, nothing is removed from the playlist.
     *
     * @param  {number} [count=1]
     *         The number of items to remove from the playlist.
     */


    playlist.remove = (index, count = 1) => {
      if (changing) {
        throw new Error('cannot modify a playlist that is currently changing');
      }

      if (typeof index !== 'number' || index < 0 || index > list.length) {
        return;
      }

      list.splice(index, count); // playlistchange is triggered synchronously in this case because it does
      // not change the current media source

      player.trigger({
        type: 'playlistchange',
        action: 'remove'
      });
      player.trigger({
        type: 'playlistremove',
        count,
        index
      });
    };
    /**
     * Checks if the playlist contains a value.
     *
     * @param  {string|Object|Array} value
     *         The value to check
     *
     * @return {boolean}
     *         The result
     */


    playlist.contains = value => {
      return playlist.indexOf(value) !== -1;
    };
    /**
     * Gets the index of a value in the playlist or -1 if not found.
     *
     * @param  {string|Object|Array} value
     *         The value to find the index of
     *
     * @return {number}
     *         The index or -1
     */


    playlist.indexOf = value => {
      if (typeof value === 'string') {
        return indexInSources(list, value);
      }

      const sources = Array.isArray(value) ? value : value.sources;

      for (let i = 0; i < sources.length; i++) {
        const source = sources[i];

        if (typeof source === 'string') {
          return indexInSources(list, source);
        } else if (source.src) {
          return indexInSources(list, source.src);
        }
      }

      return -1;
    };
    /**
     * Get the index of the current item in the playlist. This is identical to
     * calling `currentItem()` with no arguments.
     *
     * @return {number}
     *         The current item index.
     */


    playlist.currentIndex = () => playlist.currentItem();
    /**
     * Get the index of the last item in the playlist.
     *
     * @return {number}
     *         The index of the last item in the playlist or -1 if there are no
     *         items.
     */


    playlist.lastIndex = () => list.length - 1;
    /**
     * Get the index of the next item in the playlist.
     *
     * @return {number}
     *         The index of the next item in the playlist or -1 if there is no
     *         current item.
     */


    playlist.nextIndex = () => {
      const current = playlist.currentItem();

      if (current === -1) {
        return -1;
      }

      const lastIndex = playlist.lastIndex(); // When repeating, loop back to the beginning on the last item.

      if (playlist.repeat_ && current === lastIndex) {
        return 0;
      } // Don't go past the end of the playlist.


      return Math.min(current + 1, lastIndex);
    };
    /**
     * Get the index of the previous item in the playlist.
     *
     * @return {number}
     *         The index of the previous item in the playlist or -1 if there is
     *         no current item.
     */


    playlist.previousIndex = () => {
      const current = playlist.currentItem();

      if (current === -1) {
        return -1;
      } // When repeating, loop back to the end of the playlist.


      if (playlist.repeat_ && current === 0) {
        return playlist.lastIndex();
      } // Don't go past the beginning of the playlist.


      return Math.max(current - 1, 0);
    };
    /**
     * Plays the first item in the playlist.
     *
     * @return {Object|undefined}
     *         Returns undefined and has no side effects if the list is empty.
     */


    playlist.first = () => {
      if (changing) {
        return;
      }

      const newItem = playlist.currentItem(0);

      if (list.length) {
        return list[newItem].originalValue || list[newItem];
      }

      playlist.currentIndex_ = -1;
    };
    /**
     * Plays the last item in the playlist.
     *
     * @return {Object|undefined}
     *         Returns undefined and has no side effects if the list is empty.
     */


    playlist.last = () => {
      if (changing) {
        return;
      }

      const newItem = playlist.currentItem(playlist.lastIndex());

      if (list.length) {
        return list[newItem].originalValue || list[newItem];
      }

      playlist.currentIndex_ = -1;
    };
    /**
     * Plays the next item in the playlist.
     *
     * @return {Object|undefined}
     *         Returns undefined and has no side effects if on last item.
     */


    playlist.next = () => {
      if (changing) {
        return;
      }

      const index = playlist.nextIndex();

      if (index !== playlist.currentIndex_) {
        const newItem = playlist.currentItem(index);
        return list[newItem].originalValue || list[newItem];
      }
    };
    /**
     * Plays the previous item in the playlist.
     *
     * @return {Object|undefined}
     *         Returns undefined and has no side effects if on first item.
     */


    playlist.previous = () => {
      if (changing) {
        return;
      }

      const index = playlist.previousIndex();

      if (index !== playlist.currentIndex_) {
        const newItem = playlist.currentItem(index);
        return list[newItem].originalValue || list[newItem];
      }
    };
    /**
     * Set up auto-advance on the playlist.
     *
     * @param  {number} [delay]
     *         The number of seconds to wait before each auto-advance.
     */


    playlist.autoadvance = delay => {
      setup(playlist.player_, delay);
    };
    /**
     * Sets `repeat` option, which makes the "next" video of the last video in
     * the playlist be the first video in the playlist.
     *
     * @param  {boolean} [val]
     *         The value to set repeat to
     *
     * @return {boolean}
     *         The current value of repeat
     */


    playlist.repeat = val => {
      if (val === undefined) {
        return playlist.repeat_;
      }

      if (typeof val !== 'boolean') {
        tm_videojs__default["default"].log.error('tm_videojs-playlist: Invalid value for repeat', val);
        return;
      }

      playlist.repeat_ = !!val;
      return playlist.repeat_;
    };
    /**
     * Sorts the playlist array.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}
     * @fires playlistsorted
     *
     * @param {Function} compare
     *        A comparator function as per the native Array method.
     */


    playlist.sort = compare => {
      // Bail if the array is empty.
      if (!list.length) {
        return;
      }

      list.sort(compare); // If the playlist is changing, don't trigger events.

      if (changing) {
        return;
      }
      /**
       * Triggered after the playlist is sorted internally.
       *
       * @event playlistsorted
       * @type {Object}
       */


      player.trigger('playlistsorted');
    };
    /**
     * Reverses the playlist array.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}
     * @fires playlistsorted
     */


    playlist.reverse = () => {
      // Bail if the array is empty.
      if (!list.length) {
        return;
      }

      list.reverse(); // If the playlist is changing, don't trigger events.

      if (changing) {
        return;
      }
      /**
       * Triggered after the playlist is sorted internally.
       *
       * @event playlistsorted
       * @type {Object}
       */


      player.trigger('playlistsorted');
    };
    /**
     * Shuffle the contents of the list randomly.
     *
     * @see   {@link https://github.com/lodash/lodash/blob/40e096b6d5291a025e365a0f4c010d9a0efb9a69/shuffle.js}
     * @fires playlistsorted
     * @todo  Make the `rest` option default to `true` in v5.0.0.
     * @param {Object} [options]
     *        An object containing shuffle options.
     *
     * @param {boolean} [options.rest = false]
     *        By default, the entire playlist is randomized. However, this may
     *        not be desirable in all cases, such as when a user is already
     *        watching a video.
     *
     *        When `true` is passed for this option, it will only shuffle
     *        playlist items after the current item. For example, when on the
     *        first item, will shuffle the second item and beyond.
     */


    playlist.shuffle = ({
      rest
    } = {}) => {
      let index = 0;
      let arr = list; // When options.rest is true, start randomization at the item after the
      // current item.

      if (rest) {
        index = playlist.currentIndex_ + 1;
        arr = list.slice(index);
      } // Bail if the array is empty or too short to shuffle.


      if (arr.length <= 1) {
        return;
      }

      randomize(arr); // When options.rest is true, splice the randomized sub-array back into
      // the original array.

      if (rest) {
        list.splice(...[index, arr.length].concat(arr));
      } // If the playlist is changing, don't trigger events.


      if (changing) {
        return;
      }
      /**
       * Triggered after the playlist is sorted internally.
       *
       * @event playlistsorted
       * @type {Object}
       */


      player.trigger('playlistsorted');
    }; // If an initial list was given, populate the playlist with it.


    if (Array.isArray(initialList)) {
      playlist(initialList, initialIndex); // If there is no initial list given, silently set an empty array.
    } else {
      list = [];
    }

    return playlist;
  }

  var version = "5.1.0";

  const registerPlugin = tm_videojs__default["default"].registerPlugin || tm_videojs__default["default"].plugin;
  /**
   * The video.js playlist plugin. Invokes the playlist-maker to create a
   * playlist function on the specific player.
   *
   * @param {Array} list
   *        a list of sources
   *
   * @param {number} item
   *        The index to start at
   */

  const plugin = function (list, item) {
    factory(this, list, item);
  };

  registerPlugin('playlist', plugin);
  plugin.VERSION = version;

  return plugin;

}));

/*! @name tm_videojs-playlist-ui @version 5.0.0 @license Apache-2.0 */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("video.js")) : "function" == typeof define && define.amd ? define(["video.js"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).tm_videojsPlaylistUi = e(t.tm_videojs)
}(this, (function (t) {
  "use strict";
  function e(t) {
    return t && "object" == typeof t && "default" in t ? t : {
      default: t
    }
  }
  var s = e(t);
  const i = s.default.getComponent("Component");
  class l extends i {
    constructor(t, e, s) {
      if (!e.item)
        throw new Error("Cannot construct a PlaylistMenuItem without an item option");
      e.showDescription = s.showDescription,
        super(t, e),
        this.item = e.item,
        this.playOnSelect = s.playOnSelect,
        this.emitTapEvents(),
        this.on(["click", "tap"], this.switchPlaylistItem_),
        this.on("keydown", this.handleKeyDown_)
    }
    handleKeyDown_(t) {
      13 !== t.which && 32 !== t.which || this.switchPlaylistItem_()
    }
    switchPlaylistItem_(t) {
      this.player_.playlist.currentItem(this.player_.playlist().indexOf(this.item)),
        this.playOnSelect && this.player_.play()
    }
    createEl() {
      const t = document.createElement("li")
        , e = this.options_.item
        , i = this.options_.showDescription;
      if ("object" == typeof e.data) {
        Object.keys(e.data).forEach((s => {
          const i = e.data[s];
          t.dataset[s] = i
        }
        ))
      }
      if (t.className = "vjs-playlist-item",
        t.setAttribute("tabIndex", 0),
        this.thumbnail = function (t) {
          if (!t) {
            const t = document.createElement("div");
            return t.className = "vjs-playlist-thumbnail vjs-playlist-thumbnail-placeholder",
              t
          }
          const e = document.createElement("picture");
          if (e.className = "vjs-playlist-thumbnail",
            "string" == typeof t) {
            const s = document.createElement("img");
            s.loading = "lazy",
              s.src = t,
              s.alt = "",
              e.appendChild(s)
          } else {
            for (let s = 0; s < t.length - 1; s++) {
              const i = t[s]
                , l = document.createElement("source");
              for (const t in i)
                l[t] = i[t];
              e.appendChild(l)
            }
            const s = t[t.length - 1]
              , i = document.createElement("img");
            i.loading = "lazy",
              i.alt = "";
            for (const t in s)
              i[t] = s[t];
            e.appendChild(i)
          }
          return e
        }(e.thumbnail),
        t.appendChild(this.thumbnail),
        e.duration) {
        const i = document.createElement("time")
          , l = s.default.time.formatTime(e.duration);
        i.className = "vjs-playlist-duration",
          i.setAttribute("datetime", "PT0H0M" + e.duration + "S"),
          i.appendChild(document.createTextNode(l)),
          t.appendChild(i)
      }
      const l = document.createElement("span")
        , n = this.localize("Now Playing");
      l.className = "vjs-playlist-now-playing-text",
        l.appendChild(document.createTextNode(n)),
        l.setAttribute("title", n),
        this.thumbnail.appendChild(l);
      const a = document.createElement("div");
      a.className = "vjs-playlist-title-container",
        this.thumbnail.appendChild(a);
      const o = document.createElement("span")
        , d = this.localize("Up Next");
      o.className = "vjs-up-next-text",
        o.appendChild(document.createTextNode(d)),
        o.setAttribute("title", d),
        a.appendChild(o);
      const r = document.createElement("cite")
        , c = e.name || this.localize("Untitled Video");
      if (r.className = "vjs-playlist-name",
        r.appendChild(document.createTextNode(c)),
        r.setAttribute("title", c),
        a.appendChild(r),
        this.thumbnail.getElementsByTagName("img").alt = c,
        i) {
        const t = document.createElement("div")
          , s = e.description || "";
        t.className = "vjs-playlist-description",
          t.appendChild(document.createTextNode(s)),
          t.setAttribute("title", s),
          a.appendChild(t)
      }
      return t
    }
  }
  s.default.registerComponent("PlaylistMenuItem", l);
  const n = function (t) {
    t.addClass("vjs-selected")
  }
    , a = function (t) {
      t.removeClass("vjs-selected"),
        t.thumbnail && s.default.dom.removeClass(t.thumbnail, "vjs-playlist-now-playing")
    }
    , o = function (t) {
      t.removeClass("vjs-up-next")
    }
    , d = s.default.getComponent("Component");
  class r extends d {
    constructor(t, e) {
      super(t, e),
        this.items = [],
        e.horizontal ? this.addClass("vjs-playlist-horizontal") : this.addClass("vjs-playlist-vertical"),
        e.supportsCssPointerEvents && this.addClass("vjs-csspointerevents"),
        this.createPlaylist_(),
        s.default.browser.TOUCH_ENABLED || this.addClass("vjs-mouse"),
        this.on(t, ["loadstart", "playlistchange", "playlistsorted"], (t => {
          "playlistchange" === t.type && ["add", "remove"].includes(t.action) || this.update()
        }
        )),
        this.on(t, ["playlistadd"], (t => this.addItems_(t.index, t.count))),
        this.on(t, ["playlistremove"], (t => this.removeItems_(t.index, t.count))),
        this.on(t, "adstart", (() => {
          this.addClass("vjs-ad-playing")
        }
        )),
        this.on(t, "adend", (() => {
          this.removeClass("vjs-ad-playing")
        }
        )),
        this.on("dispose", (() => {
          this.empty_(),
            t.playlistMenu = null
        }
        )),
        this.on(t, "dispose", (() => {
          this.dispose()
        }
        ))
    }
    createEl() {
      return s.default.dom.createEl("div", {
        className: this.options_.className
      })
    }
    empty_() {
      this.items && this.items.length && (this.items.forEach((t => t.dispose())),
        this.items.length = 0)
    }
    createPlaylist_() {
      const t = this.player_.playlist() || [];
      let e = this.el_.querySelector(".vjs-playlist-item-list")
        , i = this.el_.querySelector(".vjs-playlist-ad-overlay");
      e || (e = document.createElement("ol"),
        e.className = "vjs-playlist-item-list",
        this.el_.appendChild(e)),
        this.empty_();
      for (let s = 0; s < t.length; s++) {
        const i = new l(this.player_, {
          item: t[s]
        }, this.options_);
        this.items.push(i),
          e.appendChild(i.el_)
      }
      i || (i = document.createElement("li"),
        i.className = "vjs-playlist-ad-overlay"),
        e.appendChild(i);
      const a = this.player_.playlist.currentItem();
      if (this.items.length && a >= 0) {
        n(this.items[a]);
        const t = this.items[a].$(".vjs-playlist-thumbnail");
        t && s.default.dom.addClass(t, "vjs-playlist-now-playing")
      }
    }
    addItems_(t, e) {
      const s = this.player_.playlist().slice(t, e + t);
      if (!s.length)
        return;
      const i = this.el_.querySelector(".vjs-playlist-item-list")
        , n = this.el_.querySelectorAll(".vjs-playlist-item")[t] || null
        , a = s.map((t => {
          const e = new l(this.player_, {
            item: t
          }, this.options_);
          return i.insertBefore(e.el_, n),
            e
        }
        ));
      this.items.splice(t, 0, ...a)
    }
    removeItems_(t, e) {
      const s = this.items.slice(t, e + t);
      s.length && (s.forEach((t => t.dispose())),
        this.items.splice(t, e))
    }
    update() {
      const t = this.player_.playlist();
      if (this.items.length !== t.length)
        return void this.createPlaylist_();
      for (let e = 0; e < this.items.length; e++)
        if (this.items[e].item !== t[e])
          return void this.createPlaylist_();
      const e = this.player_.playlist.currentItem();
      for (let t = 0; t < this.items.length; t++) {
        const i = this.items[t];
        t === e ? (n(i),
          document.activeElement !== i.el() && s.default.dom.addClass(i.thumbnail, "vjs-playlist-now-playing"),
          o(i)) : t === e + 1 ? (a(i),
            i.addClass("vjs-up-next")) : (a(i),
              o(i))
      }
    }
  }
  s.default.registerComponent("PlaylistMenu", r);
  const c = {
    className: "vjs-playlist",
    playOnSelect: !1,
    supportsCssPointerEvents: (() => {
      const t = document.createElement("x");
      return t.style.cssText = "pointer-events:auto",
        "auto" === t.style.pointerEvents
    }
    )()
  }
    , p = s.default.getPlugin("plugin");
  class h extends p {
    constructor(t, e) {
      super(t, e),
        t.usingPlugin("playlist") ? (e = this.options_ = s.default.obj.merge(c, e),
          s.default.dom.isEl(e.el) || (e.el = this.findRoot_(e.className)),
          this.playlistMenu = t.playlistMenu = new r(t, e)) : t.log.error("tm_videojs-playlist plugin is required by the tm_videojs-playlist-ui plugin")
    }
    dispose() {
      super.dispose(),
        this.playlistMenu.dispose()
    }
    hasChildEls_(t) {
      for (let e = 0; e < t.childNodes.length; e++)
        if (s.default.dom.isEl(t.childNodes[e]))
          return !0;
      return !1
    }
    findRoot_(t) {
      const e = document.querySelectorAll("." + t);
      for (let t = 0; t < e.length; t++)
        if (!this.hasChildEls_(e[t]))
          return e[t]
    }
  }
  return s.default.registerPlugin("playlistUi", h),
    h.VERSION = "5.0.0",
    h
}
));

/*! @name tm_videojs-overlay @version 3.1.0 @license Apache-2.0 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("video.js")) : "function" == typeof define && define.amd ? define(["video.js"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).tm_videojsOverlay = e(t.tm_videojs) }(this, (function (t) { "use strict"; function e(t) { return t && "object" == typeof t && "default" in t ? t : { default: t } } var n = e(t); const s = { align: "top-left", class: "", content: "This overlay will show up while the video is playing", debug: !1, showBackground: !0, attachToControlBar: !1, overlays: [{ start: "playing", end: "paused" }] }, i = n.default.getComponent("Component"), o = n.default.dom || n.default, r = n.default.registerPlugin || n.default.plugin, h = t => "number" == typeof t && t == t, a = t => "string" == typeof t && /^\S+$/.test(t); class d extends i { constructor(t, e) { super(t, e), ["start", "end"].forEach((t => { const e = this.options_[t]; if (h(e)) this[t + "Event_"] = "timeupdate"; else if (a(e)) this[t + "Event_"] = e; else if ("start" === t) throw new Error('invalid "start" option; expected number or string') })), ["endListener_", "rewindListener_", "startListener_"].forEach((t => { this[t] = e => d.prototype[t].call(this, e) })), "timeupdate" === this.startEvent_ && this.on(t, "timeupdate", this.rewindListener_), this.debug(`created, listening to "${this.startEvent_}" for "start" and "${this.endEvent_ || "nothing"}" for "end"`), this.hide() } createEl() { const t = this.options_, e = t.content, n = t.showBackground ? "vjs-overlay-background" : "vjs-overlay-no-background", s = o.createEl("div", { className: `\n        vjs-overlay\n        vjs-overlay-${t.align}\n        ${t.class}\n        ${n}\n        vjs-hidden\n      ` }); return "string" == typeof e ? s.innerHTML = e : e instanceof window.DocumentFragment ? s.appendChild(e) : o.appendContent(s, e), s } debug(...t) { if (!this.options_.debug) return; const e = n.default.log; let s = e; e.hasOwnProperty(t[0]) && "function" == typeof e[t[0]] && (s = e[t.shift()]), s(`overlay#${this.id()}: `, ...t) } hide() { return super.hide(), this.debug("hidden"), this.debug(`bound \`startListener_\` to "${this.startEvent_}"`), this.endEvent_ && (this.debug(`unbound \`endListener_\` from "${this.endEvent_}"`), this.off(this.player(), this.endEvent_, this.endListener_)), this.on(this.player(), this.startEvent_, this.startListener_), this } shouldHide_(t, e) { const n = this.options_.end; return h(n) ? t >= n : n === e } show() { return super.show(), this.off(this.player(), this.startEvent_, this.startListener_), this.debug("shown"), this.debug(`unbound \`startListener_\` from "${this.startEvent_}"`), this.endEvent_ && (this.debug(`bound \`endListener_\` to "${this.endEvent_}"`), this.on(this.player(), this.endEvent_, this.endListener_)), this } shouldShow_(t, e) { const n = this.options_.start, s = this.options_.end; return h(n) ? h(s) ? t >= n && t < s : this.hasShownSinceSeek_ ? Math.floor(t) === n : (this.hasShownSinceSeek_ = !0, t >= n) : n === e } startListener_(t) { const e = this.player().currentTime(); this.shouldShow_(e, t.type) && this.show() } endListener_(t) { const e = this.player().currentTime(); this.shouldHide_(e, t.type) && this.hide() } rewindListener_(t) { const e = this.player().currentTime(), n = this.previousTime_, s = this.options_.start, i = this.options_.end; e < n && (this.debug("rewind detected"), h(i) && !this.shouldShow_(e) ? (this.debug(`hiding; ${i} is an integer and overlay should not show at this time`), this.hasShownSinceSeek_ = !1, this.hide()) : a(i) && e < s && (this.debug(`hiding; show point (${s}) is before now (${e}) and end point (${i}) is an event`), this.hasShownSinceSeek_ = !1, this.hide())), this.previousTime_ = e } } n.default.registerComponent("Overlay", d); const l = function (t) { const e = this, i = n.default.mergeOptions(s, t); Array.isArray(this.overlays_) && this.overlays_.forEach((t => { this.removeChild(t), this.controlBar && this.controlBar.removeChild(t), t.dispose() })); const o = i.overlays; delete i.overlays; const r = t => t.map((t => { const e = n.default.mergeOptions(i, t), s = "string" == typeof e.attachToControlBar || !0 === e.attachToControlBar; if (!this.controls() || !this.controlBar) return this.addChild("overlay", e); if (s && -1 !== e.align.indexOf("bottom")) { let t = this.controlBar.children()[0]; if (void 0 !== this.controlBar.getChild(e.attachToControlBar) && (t = this.controlBar.getChild(e.attachToControlBar)), t) { const n = this.controlBar.children().indexOf(t); return this.controlBar.addChild("overlay", e, n) } } const o = this.addChild("overlay", e); return this.el().insertBefore(o.el(), this.controlBar.el()), o })); return this.overlays_ = r(o), { add: function (t) { Array.isArray(t) || (t = [t]); const n = r(t); return e.overlays_ = e.overlays_.concat(n), n }, remove: function (t) { const n = e.overlays_.indexOf(t); -1 !== n ? (t.el().parentNode.removeChild(t.el()), e.overlays_.splice(n, 1)) : e.log.warn("overlay does not exist and cannot be removed") }, get: function () { return e.overlays_ } } }; return l.VERSION = "3.1.0", r("overlay", l), l }));

/*! @name @tm_videojs/http-streaming @version 3.4.0 @license Apache-2.0 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports, require("video.js"), require("@xmldom/xmldom")) : "function" == typeof define && define.amd ? define(["exports", "video.js", "@xmldom/xmldom"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).httpStreaming = {}, e.tm_videojs, e.window) }(this, (function (e, t, i) {
  "use strict"; function n(e) { return e && "object" == typeof e && "default" in e ? e : { default: e } } var s = n(t), a = { exports: {} }; !function (e, t) { !function (t) { var i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/, n = /^([^\/?#]*)([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, r = { buildAbsoluteURL: function (e, t, i) { if (i = i || {}, e = e.trim(), !(t = t.trim())) { if (!i.alwaysNormalize) return e; var s = r.parseURL(e); if (!s) throw new Error("Error trying to parse base URL."); return s.path = r.normalizePath(s.path), r.buildURLFromParts(s) } var a = r.parseURL(t); if (!a) throw new Error("Error trying to parse relative URL."); if (a.scheme) return i.alwaysNormalize ? (a.path = r.normalizePath(a.path), r.buildURLFromParts(a)) : t; var o = r.parseURL(e); if (!o) throw new Error("Error trying to parse base URL."); if (!o.netLoc && o.path && "/" !== o.path[0]) { var d = n.exec(o.path); o.netLoc = d[1], o.path = d[2] } o.netLoc && !o.path && (o.path = "/"); var u = { scheme: o.scheme, netLoc: a.netLoc, path: null, params: a.params, query: a.query, fragment: a.fragment }; if (!a.netLoc && (u.netLoc = o.netLoc, "/" !== a.path[0])) if (a.path) { var l = o.path, h = l.substring(0, l.lastIndexOf("/") + 1) + a.path; u.path = r.normalizePath(h) } else u.path = o.path, a.params || (u.params = o.params, a.query || (u.query = o.query)); return null === u.path && (u.path = i.alwaysNormalize ? r.normalizePath(a.path) : a.path), r.buildURLFromParts(u) }, parseURL: function (e) { var t = i.exec(e); return t ? { scheme: t[1] || "", netLoc: t[2] || "", path: t[3] || "", params: t[4] || "", query: t[5] || "", fragment: t[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(s, ""); e.length !== (e = e.replace(a, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }; e.exports = r }() }(a); var r = a.exports, o = "http://example.com", d = function (e, t) { if (/^[a-z]+:/i.test(t)) return t; /^data:/.test(e) && (e = window.location && window.location.href || ""); var i = "function" == typeof window.URL, n = /^\/\//.test(e), s = !window.location && !/\/\//i.test(e); if (i ? e = new window.URL(e, window.location || o) : /\/\//i.test(e) || (e = r.buildAbsoluteURL(window.location && window.location.href || "", e)), i) { var a = new URL(t, e); return s ? a.href.slice(o.length) : n ? a.href.slice(a.protocol.length) : a.href } return r.buildAbsoluteURL(e, t) }; const u = d, l = (e, t) => t && t.responseURL && e !== t.responseURL ? t.responseURL : e, h = e => s.default.log.debug ? s.default.log.debug.bind(s.default, "VHS:", `${e} >`) : function () { }; function c() { return c = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]) } return e }, c.apply(this, arguments) } var p = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { if (!this.listeners[e]) return !1; var i = this.listeners[e].indexOf(t); return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(i, 1), i > -1 }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var i = t.length, n = 0; n < i; ++n)t[n].call(this, arguments[1]); else for (var s = Array.prototype.slice.call(arguments, 1), a = t.length, r = 0; r < a; ++r)t[r].apply(this, s) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (e) { this.on("data", (function (t) { e.push(t) })) }, e }(); function m(e) { for (var t, i = (t = e, window.atob ? window.atob(t) : Buffer.from(t, "base64").toString("binary")), n = new Uint8Array(i.length), s = 0; s < i.length; s++)n[s] = i.charCodeAt(s); return n }
/*! @name m3u8-parser @version 6.2.0 @license Apache-2.0 */class f extends p { constructor() { super(), this.buffer = "" } push(e) { let t; for (this.buffer += e, t = this.buffer.indexOf("\n"); t > -1; t = this.buffer.indexOf("\n"))this.trigger("data", this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1) } } const g = String.fromCharCode(9), y = function (e) { const t = /([0-9.]*)?@?([0-9.]*)?/.exec(e || ""), i = {}; return t[1] && (i.length = parseInt(t[1], 10)), t[2] && (i.offset = parseInt(t[2], 10)), i }, _ = function (e) { const t = {}; if (!e) return t; const i = e.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))')); let n, s = i.length; for (; s--;)"" !== i[s] && (n = /([^=]*)=(.*)/.exec(i[s]).slice(1), n[0] = n[0].replace(/^\s+|\s+$/g, ""), n[1] = n[1].replace(/^\s+|\s+$/g, ""), n[1] = n[1].replace(/^['"](.*)['"]$/g, "$1"), t[n[0]] = n[1]); return t }; class T extends p { constructor() { super(), this.customParsers = [], this.tagMappers = [] } push(e) { let t, i; 0 !== (e = e.trim()).length && ("#" === e[0] ? this.tagMappers.reduce(((t, i) => { const n = i(e); return n === e ? t : t.concat([n]) }), [e]).forEach((e => { for (let t = 0; t < this.customParsers.length; t++)if (this.customParsers[t].call(this, e)) return; if (0 === e.indexOf("#EXT")) if (e = e.replace("\r", ""), t = /^#EXTM3U/.exec(e), t) this.trigger("data", { type: "tag", tagType: "m3u" }); else { if (t = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(e), t) return i = { type: "tag", tagType: "inf" }, t[1] && (i.duration = parseFloat(t[1])), t[2] && (i.title = t[2]), void this.trigger("data", i); if (t = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(e), t) return i = { type: "tag", tagType: "targetduration" }, t[1] && (i.duration = parseInt(t[1], 10)), void this.trigger("data", i); if (t = /^#EXT-X-VERSION:([0-9.]*)?/.exec(e), t) return i = { type: "tag", tagType: "version" }, t[1] && (i.version = parseInt(t[1], 10)), void this.trigger("data", i); if (t = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(e), t) return i = { type: "tag", tagType: "media-sequence" }, t[1] && (i.number = parseInt(t[1], 10)), void this.trigger("data", i); if (t = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(e), t) return i = { type: "tag", tagType: "discontinuity-sequence" }, t[1] && (i.number = parseInt(t[1], 10)), void this.trigger("data", i); if (t = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(e), t) return i = { type: "tag", tagType: "playlist-type" }, t[1] && (i.playlistType = t[1]), void this.trigger("data", i); if (t = /^#EXT-X-BYTERANGE:(.*)?$/.exec(e), t) return i = c(y(t[1]), { type: "tag", tagType: "byterange" }), void this.trigger("data", i); if (t = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(e), t) return i = { type: "tag", tagType: "allow-cache" }, t[1] && (i.allowed = !/NO/.test(t[1])), void this.trigger("data", i); if (t = /^#EXT-X-MAP:(.*)$/.exec(e), t) { if (i = { type: "tag", tagType: "map" }, t[1]) { const e = _(t[1]); e.URI && (i.uri = e.URI), e.BYTERANGE && (i.byterange = y(e.BYTERANGE)) } this.trigger("data", i) } else if (t = /^#EXT-X-STREAM-INF:(.*)$/.exec(e), t) { if (i = { type: "tag", tagType: "stream-inf" }, t[1]) { if (i.attributes = _(t[1]), i.attributes.RESOLUTION) { const e = i.attributes.RESOLUTION.split("x"), t = {}; e[0] && (t.width = parseInt(e[0], 10)), e[1] && (t.height = parseInt(e[1], 10)), i.attributes.RESOLUTION = t } i.attributes.BANDWIDTH && (i.attributes.BANDWIDTH = parseInt(i.attributes.BANDWIDTH, 10)), i.attributes["FRAME-RATE"] && (i.attributes["FRAME-RATE"] = parseFloat(i.attributes["FRAME-RATE"])), i.attributes["PROGRAM-ID"] && (i.attributes["PROGRAM-ID"] = parseInt(i.attributes["PROGRAM-ID"], 10)) } this.trigger("data", i) } else { if (t = /^#EXT-X-MEDIA:(.*)$/.exec(e), t) return i = { type: "tag", tagType: "media" }, t[1] && (i.attributes = _(t[1])), void this.trigger("data", i); if (t = /^#EXT-X-ENDLIST/.exec(e), t) this.trigger("data", { type: "tag", tagType: "endlist" }); else if (t = /^#EXT-X-DISCONTINUITY/.exec(e), t) this.trigger("data", { type: "tag", tagType: "discontinuity" }); else { if (t = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(e), t) return i = { type: "tag", tagType: "program-date-time" }, t[1] && (i.dateTimeString = t[1], i.dateTimeObject = new Date(t[1])), void this.trigger("data", i); if (t = /^#EXT-X-KEY:(.*)$/.exec(e), t) return i = { type: "tag", tagType: "key" }, t[1] && (i.attributes = _(t[1]), i.attributes.IV && ("0x" === i.attributes.IV.substring(0, 2).toLowerCase() && (i.attributes.IV = i.attributes.IV.substring(2)), i.attributes.IV = i.attributes.IV.match(/.{8}/g), i.attributes.IV[0] = parseInt(i.attributes.IV[0], 16), i.attributes.IV[1] = parseInt(i.attributes.IV[1], 16), i.attributes.IV[2] = parseInt(i.attributes.IV[2], 16), i.attributes.IV[3] = parseInt(i.attributes.IV[3], 16), i.attributes.IV = new Uint32Array(i.attributes.IV))), void this.trigger("data", i); if (t = /^#EXT-X-START:(.*)$/.exec(e), t) return i = { type: "tag", tagType: "start" }, t[1] && (i.attributes = _(t[1]), i.attributes["TIME-OFFSET"] = parseFloat(i.attributes["TIME-OFFSET"]), i.attributes.PRECISE = /YES/.test(i.attributes.PRECISE)), void this.trigger("data", i); if (t = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(e), t) return i = { type: "tag", tagType: "cue-out-cont" }, t[1] ? i.data = t[1] : i.data = "", void this.trigger("data", i); if (t = /^#EXT-X-CUE-OUT:(.*)?$/.exec(e), t) return i = { type: "tag", tagType: "cue-out" }, t[1] ? i.data = t[1] : i.data = "", void this.trigger("data", i); if (t = /^#EXT-X-CUE-IN:(.*)?$/.exec(e), t) return i = { type: "tag", tagType: "cue-in" }, t[1] ? i.data = t[1] : i.data = "", void this.trigger("data", i); if (t = /^#EXT-X-SKIP:(.*)$/.exec(e), t && t[1]) return i = { type: "tag", tagType: "skip" }, i.attributes = _(t[1]), i.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (i.attributes["SKIPPED-SEGMENTS"] = parseInt(i.attributes["SKIPPED-SEGMENTS"], 10)), i.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (i.attributes["RECENTLY-REMOVED-DATERANGES"] = i.attributes["RECENTLY-REMOVED-DATERANGES"].split(g)), void this.trigger("data", i); if (t = /^#EXT-X-PART:(.*)$/.exec(e), t && t[1]) return i = { type: "tag", tagType: "part" }, i.attributes = _(t[1]), ["DURATION"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), ["INDEPENDENT", "GAP"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/.test(i.attributes[e])) })), i.attributes.hasOwnProperty("BYTERANGE") && (i.attributes.byterange = y(i.attributes.BYTERANGE)), void this.trigger("data", i); if (t = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(e), t && t[1]) return i = { type: "tag", tagType: "server-control" }, i.attributes = _(t[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/.test(i.attributes[e])) })), void this.trigger("data", i); if (t = /^#EXT-X-PART-INF:(.*)$/.exec(e), t && t[1]) return i = { type: "tag", tagType: "part-inf" }, i.attributes = _(t[1]), ["PART-TARGET"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), void this.trigger("data", i); if (t = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(e), t && t[1]) return i = { type: "tag", tagType: "preload-hint" }, i.attributes = _(t[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach((function (e) { if (i.attributes.hasOwnProperty(e)) { i.attributes[e] = parseInt(i.attributes[e], 10); const t = "BYTERANGE-LENGTH" === e ? "length" : "offset"; i.attributes.byterange = i.attributes.byterange || {}, i.attributes.byterange[t] = i.attributes[e], delete i.attributes[e] } })), void this.trigger("data", i); if (t = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(e), t && t[1]) return i = { type: "tag", tagType: "rendition-report" }, i.attributes = _(t[1]), ["LAST-MSN", "LAST-PART"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseInt(i.attributes[e], 10)) })), void this.trigger("data", i); if (t = /^#EXT-X-DATERANGE:(.*)$/.exec(e), t && t[1]) { i = { type: "tag", tagType: "daterange" }, i.attributes = _(t[1]), ["ID", "CLASS"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = String(i.attributes[e])) })), ["START-DATE", "END-DATE"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = new Date(i.attributes[e])) })), ["DURATION", "PLANNED-DURATION"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), ["END-ON-NEXT"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/i.test(i.attributes[e])) })), ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = i.attributes[e].toString(16)) })); const e = /^X-([A-Z]+-)+[A-Z]+$/; for (const t in i.attributes) { if (!e.test(t)) continue; const n = /[0-9A-Fa-f]{6}/g.test(i.attributes[t]), s = /^\d+(\.\d+)?$/.test(i.attributes[t]); i.attributes[t] = n ? i.attributes[t].toString(16) : s ? parseFloat(i.attributes[t]) : String(i.attributes[t]) } this.trigger("data", i) } else t = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(e), t ? this.trigger("data", { type: "tag", tagType: "independent-segments" }) : this.trigger("data", { type: "tag", data: e.slice(4) }) } } } else this.trigger("data", { type: "comment", text: e.slice(1) }) })) : this.trigger("data", { type: "uri", uri: e })) } addParser({ expression: e, customType: t, dataParser: i, segment: n }) { "function" != typeof i && (i = e => e), this.customParsers.push((s => { if (e.exec(s)) return this.trigger("data", { type: "custom", data: i(s), customType: t, segment: n }), !0 })) } addTagMapper({ expression: e, map: t }) { this.tagMappers.push((i => e.test(i) ? t(i) : i)) } } const b = function (e) { const t = {}; return Object.keys(e).forEach((function (i) { var n; t[(n = i, n.toLowerCase().replace(/-(\w)/g, (e => e[1].toUpperCase())))] = e[i] })), t }, S = function (e) { const { serverControl: t, targetDuration: i, partTargetDuration: n } = e; if (!t) return; const s = "#EXT-X-SERVER-CONTROL", a = "holdBack", r = "partHoldBack", o = i && 3 * i, d = n && 2 * n; i && !t.hasOwnProperty(a) && (t[a] = o, this.trigger("info", { message: `${s} defaulting HOLD-BACK to targetDuration * 3 (${o}).` })), o && t[a] < o && (this.trigger("warn", { message: `${s} clamping HOLD-BACK (${t[a]}) to targetDuration * 3 (${o})` }), t[a] = o), n && !t.hasOwnProperty(r) && (t[r] = 3 * n, this.trigger("info", { message: `${s} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${t[r]}).` })), n && t[r] < d && (this.trigger("warn", { message: `${s} clamping PART-HOLD-BACK (${t[r]}) to partTargetDuration * 2 (${d}).` }), t[r] = d) }; class v extends p { constructor() { super(), this.lineStream = new f, this.parseStream = new T, this.lineStream.pipe(this.parseStream); const e = this, t = []; let i, n, s = {}, a = !1; const r = function () { }, o = { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }; let d = 0; this.manifest = { allowCache: !0, discontinuityStarts: [], segments: [] }; let u = 0, l = 0; const h = {}; this.on("end", (() => { s.uri || !s.parts && !s.preloadHints || (!s.map && i && (s.map = i), !s.key && n && (s.key = n), s.timeline || "number" != typeof d || (s.timeline = d), this.manifest.preloadSegment = s) })), this.parseStream.on("data", (function (p) { let f, g; ({ tag() { ({ version() { p.version && (this.manifest.version = p.version) }, "allow-cache"() { this.manifest.allowCache = p.allowed, "allowed" in p || (this.trigger("info", { message: "defaulting allowCache to YES" }), this.manifest.allowCache = !0) }, byterange() { const e = {}; "length" in p && (s.byterange = e, e.length = p.length, "offset" in p || (p.offset = u)), "offset" in p && (s.byterange = e, e.offset = p.offset), u = e.offset + e.length }, endlist() { this.manifest.endList = !0 }, inf() { "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", { message: "defaulting media sequence to zero" })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", { message: "defaulting discontinuity sequence to zero" })), p.duration > 0 && (s.duration = p.duration), 0 === p.duration && (s.duration = .01, this.trigger("info", { message: "updating zero segment duration to a small value" })), this.manifest.segments = t }, key() { if (p.attributes) if ("NONE" !== p.attributes.METHOD) if (p.attributes.URI) { if ("com.apple.streamingkeydelivery" === p.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.apple.fps.1_0"] = { attributes: p.attributes }); if ("com.microsoft.playready" === p.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.microsoft.playready"] = { uri: p.attributes.URI }); if ("urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" === p.attributes.KEYFORMAT) return -1 === ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(p.attributes.METHOD) ? void this.trigger("warn", { message: "invalid key method provided for Widevine" }) : ("SAMPLE-AES-CENC" === p.attributes.METHOD && this.trigger("warn", { message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead" }), "data:text/plain;base64," !== p.attributes.URI.substring(0, 23) ? void this.trigger("warn", { message: "invalid key URI provided for Widevine" }) : p.attributes.KEYID && "0x" === p.attributes.KEYID.substring(0, 2) ? (this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.widevine.alpha"] = { attributes: { schemeIdUri: p.attributes.KEYFORMAT, keyId: p.attributes.KEYID.substring(2) }, pssh: m(p.attributes.URI.split(",")[1]) })) : void this.trigger("warn", { message: "invalid key ID provided for Widevine" })); p.attributes.METHOD || this.trigger("warn", { message: "defaulting key method to AES-128" }), n = { method: p.attributes.METHOD || "AES-128", uri: p.attributes.URI }, void 0 !== p.attributes.IV && (n.iv = p.attributes.IV) } else this.trigger("warn", { message: "ignoring key declaration without URI" }); else n = null; else this.trigger("warn", { message: "ignoring key declaration without attribute list" }) }, "media-sequence"() { isFinite(p.number) ? this.manifest.mediaSequence = p.number : this.trigger("warn", { message: "ignoring invalid media sequence: " + p.number }) }, "discontinuity-sequence"() { isFinite(p.number) ? (this.manifest.discontinuitySequence = p.number, d = p.number) : this.trigger("warn", { message: "ignoring invalid discontinuity sequence: " + p.number }) }, "playlist-type"() { /VOD|EVENT/.test(p.playlistType) ? this.manifest.playlistType = p.playlistType : this.trigger("warn", { message: "ignoring unknown playlist type: " + p.playlist }) }, map() { i = {}, p.uri && (i.uri = p.uri), p.byterange && (i.byterange = p.byterange), n && (i.key = n) }, "stream-inf"() { this.manifest.playlists = t, this.manifest.mediaGroups = this.manifest.mediaGroups || o, p.attributes ? (s.attributes || (s.attributes = {}), c(s.attributes, p.attributes)) : this.trigger("warn", { message: "ignoring empty stream-inf attributes" }) }, media() { if (this.manifest.mediaGroups = this.manifest.mediaGroups || o, !(p.attributes && p.attributes.TYPE && p.attributes["GROUP-ID"] && p.attributes.NAME)) return void this.trigger("warn", { message: "ignoring incomplete or missing media group" }); const e = this.manifest.mediaGroups[p.attributes.TYPE]; e[p.attributes["GROUP-ID"]] = e[p.attributes["GROUP-ID"]] || {}, f = e[p.attributes["GROUP-ID"]], g = { default: /yes/i.test(p.attributes.DEFAULT) }, g.default ? g.autoselect = !0 : g.autoselect = /yes/i.test(p.attributes.AUTOSELECT), p.attributes.LANGUAGE && (g.language = p.attributes.LANGUAGE), p.attributes.URI && (g.uri = p.attributes.URI), p.attributes["INSTREAM-ID"] && (g.instreamId = p.attributes["INSTREAM-ID"]), p.attributes.CHARACTERISTICS && (g.characteristics = p.attributes.CHARACTERISTICS), p.attributes.FORCED && (g.forced = /yes/i.test(p.attributes.FORCED)), f[p.attributes.NAME] = g }, discontinuity() { d += 1, s.discontinuity = !0, this.manifest.discontinuityStarts.push(t.length) }, "program-date-time"() { void 0 === this.manifest.dateTimeString && (this.manifest.dateTimeString = p.dateTimeString, this.manifest.dateTimeObject = p.dateTimeObject), s.dateTimeString = p.dateTimeString, s.dateTimeObject = p.dateTimeObject }, targetduration() { !isFinite(p.duration) || p.duration < 0 ? this.trigger("warn", { message: "ignoring invalid target duration: " + p.duration }) : (this.manifest.targetDuration = p.duration, S.call(this, this.manifest)) }, start() { p.attributes && !isNaN(p.attributes["TIME-OFFSET"]) ? this.manifest.start = { timeOffset: p.attributes["TIME-OFFSET"], precise: p.attributes.PRECISE } : this.trigger("warn", { message: "ignoring start declaration without appropriate attribute list" }) }, "cue-out"() { s.cueOut = p.data }, "cue-out-cont"() { s.cueOutCont = p.data }, "cue-in"() { s.cueIn = p.data }, skip() { this.manifest.skip = b(p.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", p.attributes, ["SKIPPED-SEGMENTS"]) }, part() { a = !0; const e = this.manifest.segments.length, t = b(p.attributes); s.parts = s.parts || [], s.parts.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = l), l = t.byterange.offset + t.byterange.length); const i = s.parts.length - 1; this.warnOnMissingAttributes_(`#EXT-X-PART #${i} for segment #${e}`, p.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach(((e, t) => { e.hasOwnProperty("lastPart") || this.trigger("warn", { message: `#EXT-X-RENDITION-REPORT #${t} lacks required attribute(s): LAST-PART` }) })) }, "server-control"() { const e = this.manifest.serverControl = b(p.attributes); e.hasOwnProperty("canBlockReload") || (e.canBlockReload = !1, this.trigger("info", { message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false" })), S.call(this, this.manifest), e.canSkipDateranges && !e.hasOwnProperty("canSkipUntil") && this.trigger("warn", { message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set" }) }, "preload-hint"() { const e = this.manifest.segments.length, t = b(p.attributes), i = t.type && "PART" === t.type; s.preloadHints = s.preloadHints || [], s.preloadHints.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = i ? l : 0, i && (l = t.byterange.offset + t.byterange.length))); const n = s.preloadHints.length - 1; if (this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${n} for segment #${e}`, p.attributes, ["TYPE", "URI"]), t.type) for (let i = 0; i < s.preloadHints.length - 1; i++) { const a = s.preloadHints[i]; a.type && a.type === t.type && this.trigger("warn", { message: `#EXT-X-PRELOAD-HINT #${n} for segment #${e} has the same TYPE ${t.type} as preload hint #${i}` }) } }, "rendition-report"() { const e = b(p.attributes); this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(e); const t = this.manifest.renditionReports.length - 1, i = ["LAST-MSN", "URI"]; a && i.push("LAST-PART"), this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${t}`, p.attributes, i) }, "part-inf"() { this.manifest.partInf = b(p.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", p.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), S.call(this, this.manifest) }, daterange() { this.manifest.daterange = this.manifest.daterange || [], this.manifest.daterange.push(b(p.attributes)); const e = this.manifest.daterange.length - 1; this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${e}`, p.attributes, ["ID", "START-DATE"]); const t = this.manifest.daterange[e]; t.endDate && t.startDate && new Date(t.endDate) < new Date(t.startDate) && this.trigger("warn", { message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE" }), t.duration && t.duration < 0 && this.trigger("warn", { message: "EXT-X-DATERANGE DURATION must not be negative" }), t.plannedDuration && t.plannedDuration < 0 && this.trigger("warn", { message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative" }); const i = !!t.endOnNext; if (i && !t.class && this.trigger("warn", { message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute" }), i && (t.duration || t.endDate) && this.trigger("warn", { message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes" }), t.duration && t.endDate) { const i = t.startDate, n = i.setSeconds(i.getSeconds() + t.duration); this.manifest.daterange[e].endDate = new Date(n) } if (t && !this.manifest.dateTimeString && this.trigger("warn", { message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag" }), h[t.id]) { for (const e in h[t.id]) if (h[t.id][e] !== t[e]) { this.trigger("warn", { message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes and same attribute values" }); break } } else h[t.id] = t }, "independent-segments"() { this.manifest.independentSegments = !0 } }[p.tagType] || r).call(e) }, uri() { s.uri = p.uri, t.push(s), this.manifest.targetDuration && !("duration" in s) && (this.trigger("warn", { message: "defaulting segment duration to the target duration" }), s.duration = this.manifest.targetDuration), n && (s.key = n), s.timeline = d, i && (s.map = i), l = 0, s = {} }, comment() { }, custom() { p.segment ? (s.custom = s.custom || {}, s.custom[p.customType] = p.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[p.customType] = p.data) } })[p.type].call(e) })) } warnOnMissingAttributes_(e, t, i) { const n = []; i.forEach((function (e) { t.hasOwnProperty(e) || n.push(e) })), n.length && this.trigger("warn", { message: `${e} lacks required attribute(s): ${n.join(", ")}` }) } push(e) { this.lineStream.push(e) } end() { this.lineStream.push("\n"), this.trigger("end") } addParser(e) { this.parseStream.addParser(e) } addTagMapper(e) { this.parseStream.addTagMapper(e) } } var w = { mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/, webm: /^(vp0?[89]|av0?1|opus|vorbis)/, ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/, video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/, audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/, text: /^(stpp.ttml.im1t)/, muxerVideo: /^(avc0?1)/, muxerAudio: /^(mp4a)/, muxerText: /a^/ }, I = ["video", "audio", "text"], E = ["Video", "Audio", "Text"], A = function (e) { return e ? e.replace(/avc1\.(\d+)\.(\d+)/i, (function (e, t, i) { return "avc1." + ("00" + Number(t).toString(16)).slice(-2) + "00" + ("00" + Number(i).toString(16)).slice(-2) })) : e }, L = function (e) { void 0 === e && (e = ""); var t = e.split(","), i = []; return t.forEach((function (e) { var t; e = e.trim(), I.forEach((function (n) { var s = w[n].exec(e.toLowerCase()); if (s && !(s.length <= 1)) { t = n; var a = e.substring(0, s[1].length), r = e.replace(a, ""); i.push({ type: a, details: r, mediaType: n }) } })), t || i.push({ type: e, details: "", mediaType: "unknown" }) })), i }, D = function (e) { return void 0 === e && (e = ""), w.audio.test(e.trim().toLowerCase()) }, x = function (e) { if (e && "string" == typeof e) { var t, i = e.toLowerCase().split(",").map((function (e) { return A(e.trim()) })), n = "video"; 1 === i.length && D(i[0]) ? n = "audio" : 1 === i.length && (void 0 === (t = i[0]) && (t = ""), w.text.test(t.trim().toLowerCase())) && (n = "application"); var s = "mp4"; return i.every((function (e) { return w.mp4.test(e) })) ? s = "mp4" : i.every((function (e) { return w.webm.test(e) })) ? s = "webm" : i.every((function (e) { return w.ogg.test(e) })) && (s = "ogg"), n + "/" + s + ';codecs="' + e + '"' } }, k = function (e) { return void 0 === e && (e = ""), window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(x(e)) || !1 }, O = function (e) { return void 0 === e && (e = ""), e.toLowerCase().split(",").every((function (e) { e = e.trim(); for (var t = 0; t < E.length; t++)if (w["muxer" + E[t]].test(e)) return !0; return !1 })) }, P = "mp4a.40.2"; function C(...e) { const t = s.default.obj || s.default; return (t.merge || t.mergeOptions).apply(t, e) } function U(...e) { const t = s.default.time || s.default; return (t.createTimeRanges || t.createTimeRanges).apply(t, e) } const R = 1 / 30, M = .1, B = function (e, t) { const i = []; let n; if (e && e.length) for (n = 0; n < e.length; n++)t(e.start(n), e.end(n)) && i.push([e.start(n), e.end(n)]); return U(i) }, N = function (e, t) { return B(e, (function (e, i) { return e - M <= t && i + M >= t })) }, F = function (e, t) { return B(e, (function (e) { return e - R >= t })) }, $ = e => { const t = []; if (!e || !e.length) return ""; for (let i = 0; i < e.length; i++)t.push(e.start(i) + " => " + e.end(i)); return t.join(", ") }, q = e => { const t = []; for (let i = 0; i < e.length; i++)t.push({ start: e.start(i), end: e.end(i) }); return t }, G = function (e) { if (e && e.length && e.end) return e.end(e.length - 1) }, W = function (e, t) { let i = 0; if (!e || !e.length) return i; for (let n = 0; n < e.length; n++) { const s = e.start(n), a = e.end(n); t > a || (i += t > s && t <= a ? a - t : a - s) } return i }, V = (e, t) => { if (!t.preload) return t.duration; let i = 0; return (t.parts || []).forEach((function (e) { i += e.duration })), (t.preloadHints || []).forEach((function (t) { "PART" === t.type && (i += e.partTargetDuration) })), i }, H = e => (e.segments || []).reduce(((e, t, i) => (t.parts ? t.parts.forEach((function (n, s) { e.push({ duration: n.duration, segmentIndex: i, partIndex: s, part: n, segment: t }) })) : e.push({ duration: t.duration, segmentIndex: i, partIndex: null, segment: t, part: null }), e)), []), X = e => { const t = e.segments && e.segments.length && e.segments[e.segments.length - 1]; return t && t.parts || [] }, j = ({ preloadSegment: e }) => { if (!e) return; const { parts: t, preloadHints: i } = e; let n = (i || []).reduce(((e, t) => e + ("PART" === t.type ? 1 : 0)), 0); return n += t && t.length ? t.length : 0, n }, z = (e, t) => { if (t.endList) return 0; if (e && e.suggestedPresentationDelay) return e.suggestedPresentationDelay; const i = X(t).length > 0; return i && t.serverControl && t.serverControl.partHoldBack ? t.serverControl.partHoldBack : i && t.partTargetDuration ? 3 * t.partTargetDuration : t.serverControl && t.serverControl.holdBack ? t.serverControl.holdBack : t.targetDuration ? 3 * t.targetDuration : 0 }, Y = function (e, t, i) { if (void 0 === t && (t = e.mediaSequence + e.segments.length), t < e.mediaSequence) return 0; const n = function (e, t) { let i = 0, n = t - e.mediaSequence, s = e.segments[n]; if (s) { if (void 0 !== s.start) return { result: s.start, precise: !0 }; if (void 0 !== s.end) return { result: s.end - s.duration, precise: !0 } } for (; n--;) { if (s = e.segments[n], void 0 !== s.end) return { result: i + s.end, precise: !0 }; if (i += V(e, s), void 0 !== s.start) return { result: i + s.start, precise: !0 } } return { result: i, precise: !1 } }(e, t); if (n.precise) return n.result; const s = function (e, t) { let i, n = 0, s = t - e.mediaSequence; for (; s < e.segments.length; s++) { if (i = e.segments[s], void 0 !== i.start) return { result: i.start - n, precise: !0 }; if (n += V(e, i), void 0 !== i.end) return { result: i.end - n, precise: !0 } } return { result: -1, precise: !1 } }(e, t); return s.precise ? s.result : n.result + i }, Q = function (e, t, i) { if (!e) return 0; if ("number" != typeof i && (i = 0), void 0 === t) { if (e.totalDuration) return e.totalDuration; if (!e.endList) return window.Infinity } return Y(e, t, i) }, K = function ({ defaultDuration: e, durationList: t, startIndex: i, endIndex: n }) { let s = 0; if (i > n && ([i, n] = [n, i]), i < 0) { for (let t = i; t < Math.min(0, n); t++)s += e; i = 0 } for (let e = i; e < n; e++)s += t[e].duration; return s }, J = function (e, t, i, n) { if (!e || !e.segments) return null; if (e.endList) return Q(e); if (null === t) return null; t = t || 0; let s = Y(e, e.mediaSequence + e.segments.length, t); return i && (s -= n = "number" == typeof n ? n : z(null, e)), Math.max(0, s) }, Z = function (e) { return e.excludeUntil && e.excludeUntil > Date.now() }, ee = function (e) { return e.excludeUntil && e.excludeUntil === 1 / 0 }, te = function (e) { const t = Z(e); return !e.disabled && !t }, ie = function (e, t) { return t.attributes && t.attributes[e] }, ne = (e, t) => { if (1 === e.playlists.length) return !0; const i = t.attributes.BANDWIDTH || Number.MAX_VALUE; return 0 === e.playlists.filter((e => !!te(e) && (e.attributes.BANDWIDTH || 0) < i)).length }, se = (e, t) => !(!e && !t || !e && t || e && !t || e !== t && (!e.id || !t.id || e.id !== t.id) && (!e.resolvedUri || !t.resolvedUri || e.resolvedUri !== t.resolvedUri) && (!e.uri || !t.uri || e.uri !== t.uri)), ae = function (e, t) { const i = e && e.mediaGroups && e.mediaGroups.AUDIO || {}; let n = !1; for (const e in i) { for (const s in i[e]) if (n = t(i[e][s]), n) break; if (n) break } return !!n }, re = e => { if (!e || !e.playlists || !e.playlists.length) return ae(e, (e => e.playlists && e.playlists.length || e.uri)); for (let t = 0; t < e.playlists.length; t++) { const i = e.playlists[t], n = i.attributes && i.attributes.CODECS; if ((!n || !n.split(",").every((e => D(e)))) && !ae(e, (e => se(i, e)))) return !1 } return !0 }; var oe = { liveEdgeDelay: z, duration: Q, seekable: function (e, t, i) { const n = t || 0, s = J(e, t, !0, i); return null === s ? U() : U(n, s) }, getMediaInfoForTime: function ({ playlist: e, currentTime: t, startingSegmentIndex: i, startingPartIndex: n, startTime: s, exactManifestTimings: a }) { let r = t - s; const o = H(e); let d = 0; for (let e = 0; e < o.length; e++) { const t = o[e]; if (i === t.segmentIndex && ("number" != typeof n || "number" != typeof t.partIndex || n === t.partIndex)) { d = e; break } } if (r < 0) { if (d > 0) for (let t = d - 1; t >= 0; t--) { const i = o[t]; if (r += i.duration, a) { if (r < 0) continue } else if (r + R <= 0) continue; return { partIndex: i.partIndex, segmentIndex: i.segmentIndex, startTime: s - K({ defaultDuration: e.targetDuration, durationList: o, startIndex: d, endIndex: t }) } } return { partIndex: o[0] && o[0].partIndex || null, segmentIndex: o[0] && o[0].segmentIndex || 0, startTime: t } } if (d < 0) { for (let i = d; i < 0; i++)if (r -= e.targetDuration, r < 0) return { partIndex: o[0] && o[0].partIndex || null, segmentIndex: o[0] && o[0].segmentIndex || 0, startTime: t }; d = 0 } for (let t = d; t < o.length; t++) { const i = o[t]; if (r -= i.duration, a) { if (r > 0) continue } else if (r - R >= 0) continue; return { partIndex: i.partIndex, segmentIndex: i.segmentIndex, startTime: s + K({ defaultDuration: e.targetDuration, durationList: o, startIndex: d, endIndex: t }) } } return { segmentIndex: o[o.length - 1].segmentIndex, partIndex: o[o.length - 1].partIndex, startTime: t } }, isEnabled: te, isDisabled: function (e) { return e.disabled }, isExcluded: Z, isIncompatible: ee, playlistEnd: J, isAes: function (e) { for (let t = 0; t < e.segments.length; t++)if (e.segments[t].key) return !0; return !1 }, hasAttribute: ie, estimateSegmentRequestTime: function (e, t, i, n = 0) { return ie("BANDWIDTH", i) ? (e * i.attributes.BANDWIDTH - 8 * n) / t : NaN }, isLowestEnabledRendition: ne, isAudioOnly: re, playlistMatch: se, segmentDurationWithParts: V }; const { log: de } = s.default, ue = (e, t) => `${e}-${t}`, le = (e, t, i) => `placeholder-uri-${e}-${t}-${i}`, he = (e, t) => { e.mediaGroups && ["AUDIO", "SUBTITLES"].forEach((i => { if (e.mediaGroups[i]) for (const n in e.mediaGroups[i]) for (const s in e.mediaGroups[i][n]) { const a = e.mediaGroups[i][n][s]; t(a, i, n, s) } })) }, ce = ({ playlist: e, uri: t, id: i }) => { e.id = i, e.playlistErrors_ = 0, t && (e.uri = t), e.attributes = e.attributes || {} }, pe = (e, t, i = le) => { e.uri = t; for (let t = 0; t < e.playlists.length; t++)if (!e.playlists[t].uri) { const i = `placeholder-uri-${t}`; e.playlists[t].uri = i } const n = re(e); he(e, ((t, s, a, r) => { if (!t.playlists || !t.playlists.length) { if (n && "AUDIO" === s && !t.uri) for (let t = 0; t < e.playlists.length; t++) { const i = e.playlists[t]; if (i.attributes && i.attributes.AUDIO && i.attributes.AUDIO === a) return } t.playlists = [c({}, t)] } t.playlists.forEach((function (t, n) { const o = i(s, a, r, t), d = ue(n, o); t.uri ? t.resolvedUri = t.resolvedUri || u(e.uri, t.uri) : (t.uri = 0 === n ? o : d, t.resolvedUri = t.uri), t.id = t.id || d, t.attributes = t.attributes || {}, e.playlists[t.id] = t, e.playlists[t.uri] = t })) })), (e => { let t = e.playlists.length; for (; t--;) { const i = e.playlists[t]; ce({ playlist: i, id: ue(t, i.uri) }), i.resolvedUri = u(e.uri, i.uri), e.playlists[i.id] = i, e.playlists[i.uri] = i, i.attributes.BANDWIDTH || de.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.") } })(e), (e => { he(e, (t => { t.uri && (t.resolvedUri = u(e.uri, t.uri)) })) })(e) }, { EventTarget: me } = s.default, fe = (e, t) => { if (!e) return t; const i = C(e, t); if (e.preloadHints && !t.preloadHints && delete i.preloadHints, e.parts && !t.parts) delete i.parts; else if (e.parts && t.parts) for (let n = 0; n < t.parts.length; n++)e.parts && e.parts[n] && (i.parts[n] = C(e.parts[n], t.parts[n])); return !e.skipped && t.skipped && (i.skipped = !1), e.preload && !t.preload && (i.preload = !1), i }, ge = (e, t) => { !e.resolvedUri && e.uri && (e.resolvedUri = u(t, e.uri)), e.key && !e.key.resolvedUri && (e.key.resolvedUri = u(t, e.key.uri)), e.map && !e.map.resolvedUri && (e.map.resolvedUri = u(t, e.map.uri)), e.map && e.map.key && !e.map.key.resolvedUri && (e.map.key.resolvedUri = u(t, e.map.key.uri)), e.parts && e.parts.length && e.parts.forEach((e => { e.resolvedUri || (e.resolvedUri = u(t, e.uri)) })), e.preloadHints && e.preloadHints.length && e.preloadHints.forEach((e => { e.resolvedUri || (e.resolvedUri = u(t, e.uri)) })) }, ye = function (e) { const t = e.segments || [], i = e.preloadSegment; if (i && i.parts && i.parts.length) { if (i.preloadHints) for (let e = 0; e < i.preloadHints.length; e++)if ("MAP" === i.preloadHints[e].type) return t; i.duration = e.targetDuration, i.preload = !0, t.push(i) } return t }, _e = (e, t) => e === t || e.segments && t.segments && e.segments.length === t.segments.length && e.endList === t.endList && e.mediaSequence === t.mediaSequence && e.preloadSegment === t.preloadSegment, Te = (e, t, i = _e) => { const n = C(e, {}), s = n.playlists[t.id]; if (!s) return null; if (i(s, t)) return null; t.segments = ye(t); const a = C(s, t); if (a.preloadSegment && !t.preloadSegment && delete a.preloadSegment, s.segments) { if (t.skip) { t.segments = t.segments || []; for (let e = 0; e < t.skip.skippedSegments; e++)t.segments.unshift({ skipped: !0 }) } a.segments = ((e, t, i) => { const n = e.slice(), s = t.slice(); i = i || 0; const a = []; let r; for (let e = 0; e < s.length; e++) { const t = n[e + i], o = s[e]; t ? (r = t.map || r, a.push(fe(t, o))) : (r && !o.map && (o.map = r), a.push(o)) } return a })(s.segments, t.segments, t.mediaSequence - s.mediaSequence) } a.segments.forEach((e => { ge(e, a.resolvedUri) })); for (let e = 0; e < n.playlists.length; e++)n.playlists[e].id === t.id && (n.playlists[e] = a); return n.playlists[t.id] = a, n.playlists[t.uri] = a, he(e, ((e, i, n, s) => { if (e.playlists) for (let i = 0; i < e.playlists.length; i++)t.id === e.playlists[i].id && (e.playlists[i] = a) })), n }, be = (e, t) => { const i = e.segments || [], n = i[i.length - 1], s = n && n.parts && n.parts[n.parts.length - 1], a = s && s.duration || n && n.duration; return t && a ? 1e3 * a : 500 * (e.partTargetDuration || e.targetDuration || 10) }; class Se extends me { constructor(e, t, i = {}) { if (super(), !e) throw new Error("A non-empty playlist URL or object is required"); this.logger_ = h("PlaylistLoader"); const { withCredentials: n = !1 } = i; this.src = e, this.vhs_ = t, this.withCredentials = n; const s = t.options_; this.customTagParsers = s && s.customTagParsers || [], this.customTagMappers = s && s.customTagMappers || [], this.llhls = s && s.llhls, this.state = "HAVE_NOTHING", this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this), this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_) } handleMediaupdatetimeout_() { if ("HAVE_METADATA" !== this.state) return; const e = this.media(); let t = u(this.main.uri, e.uri); this.llhls && (t = ((e, t) => { if (t.endList || !t.serverControl) return e; const i = {}; if (t.serverControl.canBlockReload) { const { preloadSegment: e } = t; let n = t.mediaSequence + t.segments.length; if (e) { const s = e.parts || [], a = j(t) - 1; a > -1 && a !== s.length - 1 && (i._HLS_part = a), (a > -1 || s.length) && n-- } i._HLS_msn = n } if (t.serverControl && t.serverControl.canSkipUntil && (i._HLS_skip = t.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(i).length) { const t = new window.URL(e);["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach((function (e) { i.hasOwnProperty(e) && t.searchParams.set(e, i[e]) })), e = t.toString() } return e })(t, e)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({ uri: t, withCredentials: this.withCredentials }, ((e, t) => { if (this.request) return e ? this.playlistRequestError(this.request, this.media(), "HAVE_METADATA") : void this.haveMetadata({ playlistString: this.request.responseText, url: this.media().uri, id: this.media().id }) })) } playlistRequestError(e, t, i) { const { uri: n, id: s } = t; this.request = null, i && (this.state = i), this.error = { playlist: this.main.playlists[s], status: e.status, message: `HLS playlist request error at URL: ${n}.`, responseText: e.responseText, code: e.status >= 500 ? 4 : 2 }, this.trigger("error") } parseManifest_({ url: e, manifestString: t }) { return (({ onwarn: e, oninfo: t, manifestString: i, customTagParsers: n = [], customTagMappers: s = [], llhls: a }) => { const r = new v; e && r.on("warn", e), t && r.on("info", t), n.forEach((e => r.addParser(e))), s.forEach((e => r.addTagMapper(e))), r.push(i), r.end(); const o = r.manifest; if (a || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach((function (e) { o.hasOwnProperty(e) && delete o[e] })), o.segments && o.segments.forEach((function (e) { ["parts", "preloadHints"].forEach((function (t) { e.hasOwnProperty(t) && delete e[t] })) }))), !o.targetDuration) { let t = 10; o.segments && o.segments.length && (t = o.segments.reduce(((e, t) => Math.max(e, t.duration)), 0)), e && e(`manifest has no targetDuration defaulting to ${t}`), o.targetDuration = t } const d = X(o); if (d.length && !o.partTargetDuration) { const t = d.reduce(((e, t) => Math.max(e, t.duration)), 0); e && (e(`manifest has no partTargetDuration defaulting to ${t}`), de.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), o.partTargetDuration = t } return o })({ onwarn: ({ message: t }) => this.logger_(`m3u8-parser warn for ${e}: ${t}`), oninfo: ({ message: t }) => this.logger_(`m3u8-parser info for ${e}: ${t}`), manifestString: t, customTagParsers: this.customTagParsers, customTagMappers: this.customTagMappers, llhls: this.llhls }) } haveMetadata({ playlistString: e, playlistObject: t, url: i, id: n }) { this.request = null, this.state = "HAVE_METADATA"; const s = t || this.parseManifest_({ url: i, manifestString: e }); s.lastRequest = Date.now(), ce({ playlist: s, uri: i, id: n }); const a = Te(this.main, s); this.targetDuration = s.partTargetDuration || s.targetDuration, this.pendingMedia_ = null, a ? (this.main = a, this.media_ = this.main.playlists[n]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(be(this.media(), !!a)), this.trigger("loadedplaylist") } dispose() { this.trigger("dispose"), this.stopRequest(), window.clearTimeout(this.mediaUpdateTimeout), window.clearTimeout(this.finalRenditionTimeout), this.off() } stopRequest() { if (this.request) { const e = this.request; this.request = null, e.onreadystatechange = null, e.abort() } } media(e, t) { if (!e) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); if ("string" == typeof e) { if (!this.main.playlists[e]) throw new Error("Unknown playlist URI: " + e); e = this.main.playlists[e] } if (window.clearTimeout(this.finalRenditionTimeout), t) { const t = (e.partTargetDuration || e.targetDuration) / 2 * 1e3 || 5e3; return void (this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, e, !1), t)) } const i = this.state, n = !this.media_ || e.id !== this.media_.id, s = this.main.playlists[e.id]; if (s && s.endList || e.endList && e.segments.length) return this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = e, void (n && (this.trigger("mediachanging"), "HAVE_MAIN_MANIFEST" === i ? this.trigger("loadedmetadata") : this.trigger("mediachange"))); if (this.updateMediaUpdateTimeout_(be(e, !0)), n) { if (this.state = "SWITCHING_MEDIA", this.request) { if (e.resolvedUri === this.request.url) return; this.request.onreadystatechange = null, this.request.abort(), this.request = null } this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = e, this.request = this.vhs_.xhr({ uri: e.resolvedUri, withCredentials: this.withCredentials }, ((t, n) => { if (this.request) { if (e.lastRequest = Date.now(), e.resolvedUri = l(e.resolvedUri, n), t) return this.playlistRequestError(this.request, e, i); this.haveMetadata({ playlistString: n.responseText, url: e.uri, id: e.id }), "HAVE_MAIN_MANIFEST" === i ? this.trigger("loadedmetadata") : this.trigger("mediachange") } })) } } pause() { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA") } load(e) { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null); const t = this.media(); if (e) { const e = t ? (t.partTargetDuration || t.targetDuration) / 2 * 1e3 : 5e3; this.mediaUpdateTimeout = window.setTimeout((() => { this.mediaUpdateTimeout = null, this.load() }), e) } else this.started ? t && !t.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist") : this.start() } updateMediaUpdateTimeout_(e) { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.media() && !this.media().endList && (this.mediaUpdateTimeout = window.setTimeout((() => { this.mediaUpdateTimeout = null, this.trigger("mediaupdatetimeout"), this.updateMediaUpdateTimeout_(e) }), e)) } start() { if (this.started = !0, "object" == typeof this.src) return this.src.uri || (this.src.uri = window.location.href), this.src.resolvedUri = this.src.uri, void setTimeout((() => { this.setupInitialPlaylist(this.src) }), 0); this.request = this.vhs_.xhr({ uri: this.src, withCredentials: this.withCredentials }, ((e, t) => { if (!this.request) return; if (this.request = null, e) return this.error = { status: t.status, message: `HLS playlist request error at URL: ${this.src}.`, responseText: t.responseText, code: 2 }, "HAVE_NOTHING" === this.state && (this.started = !1), this.trigger("error"); this.src = l(this.src, t); const i = this.parseManifest_({ manifestString: t.responseText, url: this.src }); this.setupInitialPlaylist(i) })) } srcUri() { return "string" == typeof this.src ? this.src : this.src.uri } setupInitialPlaylist(e) { if (this.state = "HAVE_MAIN_MANIFEST", e.playlists) return this.main = e, pe(this.main, this.srcUri()), e.playlists.forEach((e => { e.segments = ye(e), e.segments.forEach((t => { ge(t, e.resolvedUri) })) })), this.trigger("loadedplaylist"), void (this.request || this.media(this.main.playlists[0])); const t = this.srcUri() || window.location.href; this.main = ((e, t) => { const i = ue(0, t), n = { mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: window.location.href, resolvedUri: window.location.href, playlists: [{ uri: t, id: i, resolvedUri: t, attributes: {} }] }; return n.playlists[i] = n.playlists[0], n.playlists[t] = n.playlists[0], n })(0, t), this.haveMetadata({ playlistObject: e, url: t, id: this.main.playlists[0].id }), this.trigger("loadedmetadata") } } const { xhr: ve } = s.default, we = function (e, t, i, n) { const s = "arraybuffer" === e.responseType ? e.response : e.responseText; !t && s && (e.responseTime = Date.now(), e.roundTripTime = e.responseTime - e.requestTime, e.bytesReceived = s.byteLength || s.length, e.bandwidth || (e.bandwidth = Math.floor(e.bytesReceived / e.roundTripTime * 8 * 1e3))), i.headers && (e.responseHeaders = i.headers), t && "ETIMEDOUT" === t.code && (e.timedout = !0), t || e.aborted || 200 === i.statusCode || 206 === i.statusCode || 0 === i.statusCode || (t = new Error("XHR Failed with a response of: " + (e && (s || e.responseText)))), n(t, e) }, Ie = function () { const e = function e(t, i) { t = C({ timeout: 45e3 }, t); const n = e.beforeRequest || s.default.Vhs.xhr.beforeRequest, a = e._requestCallbackSet || s.default.Vhs.xhr._requestCallbackSet || new Set, r = e._responseCallbackSet || s.default.Vhs.xhr._responseCallbackSet; n && "function" == typeof n && (s.default.log.warn("beforeRequest is deprecated, use onRequest instead."), a.add(n)); const o = !0 === s.default.Vhs.xhr.original ? ve : s.default.Vhs.xhr, d = ((e, t) => { if (!e || !e.size) return; let i = t; return e.forEach((e => { i = e(i) })), i })(a, t); a.delete(n); const u = o(d || t, (function (e, t) { return ((e, t, i, n) => { e && e.size && e.forEach((e => { e(t, i, n) })) })(r, u, e, t), we(u, e, t, i) })), l = u.abort; return u.abort = function () { return u.aborted = !0, l.apply(u, arguments) }, u.uri = t.uri, u.requestTime = Date.now(), u }; return e.original = !0, e }, Ee = function (e) { const t = {}; return e.byterange && (t.Range = function (e) { let t; const i = e.offset; return t = "bigint" == typeof e.offset || "bigint" == typeof e.length ? window.BigInt(e.offset) + window.BigInt(e.length) - window.BigInt(1) : e.offset + e.length - 1, "bytes=" + i + "-" + t }(e.byterange)), t }; var Ae, Le, De = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, xe = /^application\/dash\+xml/i, ke = function (e) { return De.test(e) ? "hls" : xe.test(e) ? "dash" : "application/vnd.tm_videojs.vhs+json" === e ? "vhs-json" : null }, Oe = function (e) { return "function" === ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer }, Pe = function (e) { return e instanceof Uint8Array ? e : (Array.isArray(e) || Oe(e) || e instanceof ArrayBuffer || (e = "number" != typeof e || "number" == typeof e && e != e ? 0 : [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0)) }, Ce = window.BigInt || Number, Ue = [Ce("0x1"), Ce("0x100"), Ce("0x10000"), Ce("0x1000000"), Ce("0x100000000"), Ce("0x10000000000"), Ce("0x1000000000000"), Ce("0x100000000000000"), Ce("0x10000000000000000")]; Ae = new Uint16Array([65484]), 255 === (Le = new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength))[0] || Le[0]; var Re = function (e, t) { var i = void 0 === t ? {} : t, n = i.signed, s = void 0 !== n && n, a = i.le, r = void 0 !== a && a; e = Pe(e); var o = r ? "reduce" : "reduceRight", d = (e[o] ? e[o] : Array.prototype[o]).call(e, (function (t, i, n) { var s = r ? n : Math.abs(n + 1 - e.length); return t + Ce(i) * Ue[s] }), Ce(0)); if (s) { var u = Ue[e.length] / Ce(2) - Ce(1); (d = Ce(d)) > u && (d -= u, d -= u, d -= Ce(2)) } return Number(d) }, Me = function (e, t) { if ("string" != typeof e && e && "function" == typeof e.toString && (e = e.toString()), "string" != typeof e) return new Uint8Array; t || (e = unescape(encodeURIComponent(e))); for (var i = new Uint8Array(e.length), n = 0; n < e.length; n++)i[n] = e.charCodeAt(n); return i }, Be = function (e, t, i) { var n = void 0 === i ? {} : i, s = n.offset, a = void 0 === s ? 0 : s, r = n.mask, o = void 0 === r ? [] : r; e = Pe(e); var d = (t = Pe(t)).every ? t.every : Array.prototype.every; return t.length && e.length - a >= t.length && d.call(t, (function (t, i) { return t === (o[i] ? o[i] & e[a + i] : e[a + i]) })) }; const Ne = function (e, t) { return e.start(t) + "-" + e.end(t) }, Fe = function (e, t) { const i = e.toString(16); return "00".substring(0, 2 - i.length) + i + (t % 2 ? " " : "") }, $e = function (e) { return e >= 32 && e < 126 ? String.fromCharCode(e) : "." }, qe = function (e) { const t = {}; return Object.keys(e).forEach((i => { const n = e[i]; Oe(n) ? t[i] = { bytes: n.buffer, byteOffset: n.byteOffset, byteLength: n.byteLength } : t[i] = n })), t }, Ge = function (e) { const t = e.byterange || { length: 1 / 0, offset: 0 }; return [t.length, t.offset, e.resolvedUri].join(",") }, We = function (e) { return e.resolvedUri }, Ve = e => { const t = Array.prototype.slice.call(e), i = 16; let n, s, a = ""; for (let e = 0; e < t.length / i; e++)n = t.slice(e * i, e * i + i).map(Fe).join(""), s = t.slice(e * i, e * i + i).map($e).join(""), a += n + " " + s + "\n"; return a }; var He = Object.freeze({ __proto__: null, createTransferableMessage: qe, initSegmentId: Ge, segmentKeyId: We, hexDump: Ve, tagDump: ({ bytes: e }) => Ve(e), textRanges: e => { let t, i = ""; for (t = 0; t < e.length; t++)i += Ne(e, t) + " "; return i } }); const Xe = ({ programTime: e, playlist: t, retryCount: i = 2, seekTo: n, pauseAfterSeek: s = !0, tech: a, callback: r }) => { if (!r) throw new Error("seekToProgramTime: callback must be provided"); if (void 0 === e || !t || !n) return r({ message: "seekToProgramTime: programTime, seekTo and playlist must be provided" }); if (!t.endList && !a.hasStarted_) return r({ message: "player must be playing a live stream to start buffering" }); if (!(e => { if (!e.segments || 0 === e.segments.length) return !1; for (let t = 0; t < e.segments.length; t++)if (!e.segments[t].dateTimeObject) return !1; return !0 })(t)) return r({ message: "programDateTime tags must be provided in the manifest " + t.resolvedUri }); const o = ((e, t) => { let i; try { i = new Date(e) } catch (e) { return null } if (!t || !t.segments || 0 === t.segments.length) return null; let n = t.segments[0]; if (i < n.dateTimeObject) return null; for (let e = 0; e < t.segments.length - 1 && (n = t.segments[e], !(i < t.segments[e + 1].dateTimeObject)); e++); const s = t.segments[t.segments.length - 1], a = s.dateTimeObject, r = s.videoTimingInfo ? (o = s.videoTimingInfo).transmuxedPresentationEnd - o.transmuxedPresentationStart - o.transmuxerPrependedSeconds : s.duration + .25 * s.duration; var o; return i > new Date(a.getTime() + 1e3 * r) ? null : (i > a && (n = s), { segment: n, estimatedStart: n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationStart : oe.duration(t, t.mediaSequence + t.segments.indexOf(n)), type: n.videoTimingInfo ? "accurate" : "estimate" }) })(e, t); if (!o) return r({ message: `${e} was not found in the stream` }); const d = o.segment, u = ((e, t) => { let i, n; try { i = new Date(e), n = new Date(t) } catch (e) { } const s = i.getTime(); return (n.getTime() - s) / 1e3 })(d.dateTimeObject, e); if ("estimate" === o.type) return 0 === i ? r({ message: `${e} is not buffered yet. Try again` }) : (n(o.estimatedStart + u), void a.one("seeked", (() => { Xe({ programTime: e, playlist: t, retryCount: i - 1, seekTo: n, pauseAfterSeek: s, tech: a, callback: r }) }))); const l = d.start + u; a.one("seeked", (() => r(null, a.currentTime()))), s && a.pause(), n(l) }, je = e => !!e && "object" == typeof e, ze = (...e) => e.reduce(((e, t) => ("object" != typeof t || Object.keys(t).forEach((i => { Array.isArray(e[i]) && Array.isArray(t[i]) ? e[i] = e[i].concat(t[i]) : je(e[i]) && je(t[i]) ? e[i] = ze(e[i], t[i]) : e[i] = t[i] })), e)), {}), Ye = e => Object.keys(e).map((t => e[t])), Qe = e => e.reduce(((e, t) => e.concat(t)), []), Ke = e => { if (!e.length) return []; const t = []; for (let i = 0; i < e.length; i++)t.push(e[i]); return t }; const Je = ({ baseUrl: e = "", source: t = "", range: i = "", indexRange: n = "" }) => { const s = { uri: t, resolvedUri: d(e || "", t) }; if (i || n) { const e = (i || n).split("-"); let t, a = window.BigInt ? window.BigInt(e[0]) : parseInt(e[0], 10), r = window.BigInt ? window.BigInt(e[1]) : parseInt(e[1], 10); a < Number.MAX_SAFE_INTEGER && "bigint" == typeof a && (a = Number(a)), r < Number.MAX_SAFE_INTEGER && "bigint" == typeof r && (r = Number(r)), t = "bigint" == typeof r || "bigint" == typeof a ? window.BigInt(r) - window.BigInt(a) + window.BigInt(1) : r - a + 1, "bigint" == typeof t && t < Number.MAX_SAFE_INTEGER && (t = Number(t)), s.byterange = { length: t, offset: a } } return s }, Ze = e => (e && "number" != typeof e && (e = parseInt(e, 10)), isNaN(e) ? null : e), et = { static(e) { const { duration: t, timescale: i = 1, sourceDuration: n, periodDuration: s } = e, a = Ze(e.endNumber), r = t / i; return "number" == typeof a ? { start: 0, end: a } : "number" == typeof s ? { start: 0, end: s / r } : { start: 0, end: n / r } }, dynamic(e) { const { NOW: t, clientOffset: i, availabilityStartTime: n, timescale: s = 1, duration: a, periodStart: r = 0, minimumUpdatePeriod: o = 0, timeShiftBufferDepth: d = 1 / 0 } = e, u = Ze(e.endNumber), l = (t + i) / 1e3, h = n + r, c = l + o - h, p = Math.ceil(c * s / a), m = Math.floor((l - h - d) * s / a), f = Math.floor((l - h) * s / a); return { start: Math.max(0, m), end: "number" == typeof u ? u : Math.min(p, f) } } }, tt = e => { const { type: t, duration: i, timescale: n = 1, periodDuration: s, sourceDuration: a } = e, { start: r, end: o } = et[t](e), d = ((e, t) => { const i = []; for (let n = e; n < t; n++)i.push(n); return i })(r, o).map((e => t => { const { duration: i, timescale: n = 1, periodStart: s, startNumber: a = 1 } = e; return { number: a + t, duration: i / n, timeline: s, time: t * i } })(e)); if ("static" === t) { const e = d.length - 1, t = "number" == typeof s ? s : a; d[e].duration = t - i / n * e } return d }, it = e => { const { baseUrl: t, initialization: i = {}, sourceDuration: n, indexRange: s = "", periodStart: a, presentationTime: r, number: o = 0, duration: d } = e; if (!t) throw new Error("NO_BASE_URL"); const u = Je({ baseUrl: t, source: i.sourceURL, range: i.range }), l = Je({ baseUrl: t, source: t, indexRange: s }); if (l.map = u, d) { const t = tt(e); t.length && (l.duration = t[0].duration, l.timeline = t[0].timeline) } else n && (l.duration = n, l.timeline = a); return l.presentationTime = r || a, l.number = o, [l] }, nt = (e, t, i) => { const n = e.sidx.map ? e.sidx.map : null, s = e.sidx.duration, a = e.timeline || 0, r = e.sidx.byterange, o = r.offset + r.length, d = t.timescale, u = t.references.filter((e => 1 !== e.referenceType)), l = [], h = e.endList ? "static" : "dynamic", c = e.sidx.timeline; let p, m = c, f = e.mediaSequence || 0; p = "bigint" == typeof t.firstOffset ? window.BigInt(o) + t.firstOffset : o + t.firstOffset; for (let e = 0; e < u.length; e++) { const r = t.references[e], o = r.referencedSize, u = r.subsegmentDuration; let g; g = "bigint" == typeof p ? p + window.BigInt(o) - window.BigInt(1) : p + o - 1; const y = it({ baseUrl: i, timescale: d, timeline: a, periodStart: c, presentationTime: m, number: f, duration: u, sourceDuration: s, indexRange: `${p}-${g}`, type: h })[0]; n && (y.map = n), l.push(y), p += "bigint" == typeof p ? window.BigInt(o) : o, m += u / d, f++ } return e.segments = l, e }, st = ["AUDIO", "SUBTITLES"], at = e => { return (t = e, i = ({ timeline: e }) => e, Ye(t.reduce(((e, t) => (t.forEach((t => { e[i(t)] = t })), e)), {}))).sort(((e, t) => e.timeline > t.timeline ? 1 : -1)); var t, i }, rt = e => { let t = []; var i, n; return i = e, n = (e, i, n, s) => { t = t.concat(e.playlists || []) }, st.forEach((function (e) { for (var t in i.mediaGroups[e]) for (var s in i.mediaGroups[e][t]) { var a = i.mediaGroups[e][t][s]; n(a) } })), t }, ot = ({ playlist: e, mediaSequence: t }) => { e.mediaSequence = t, e.segments.forEach(((t, i) => { t.number = e.mediaSequence + i })) }, dt = e => e && e.uri + "-" + (e => { let t; return t = "bigint" == typeof e.offset || "bigint" == typeof e.length ? window.BigInt(e.offset) + window.BigInt(e.length) - window.BigInt(1) : e.offset + e.length - 1, `${e.offset}-${t}` })(e.byterange), ut = e => Ye(e.reduce(((e, t) => { const i = t.attributes.id + (t.attributes.lang || ""); return e[i] ? (t.segments && (t.segments[0] && (t.segments[0].discontinuity = !0), e[i].segments.push(...t.segments)), t.attributes.contentProtection && (e[i].attributes.contentProtection = t.attributes.contentProtection)) : (e[i] = t, e[i].attributes.timelineStarts = []), e[i].attributes.timelineStarts.push({ start: t.attributes.periodStart, timeline: t.attributes.periodStart }), e }), {})).map((e => { var t; return e.discontinuityStarts = (t = e.segments || [], "discontinuity", t.reduce(((e, t, i) => (t.discontinuity && e.push(i), e)), [])), e })), lt = (e, t) => { const i = dt(e.sidx), n = i && t[i] && t[i].sidx; return n && nt(e, n, e.sidx.resolvedUri), e }, ht = (e, t = {}) => { if (!Object.keys(t).length) return e; for (const i in e) e[i] = lt(e[i], t); return e }, ct = ({ attributes: e, segments: t, sidx: i, discontinuityStarts: n }) => { const s = { attributes: { NAME: e.id, AUDIO: "audio", SUBTITLES: "subs", RESOLUTION: { width: e.width, height: e.height }, CODECS: e.codecs, BANDWIDTH: e.bandwidth, "PROGRAM-ID": 1 }, uri: "", endList: "static" === e.type, timeline: e.periodStart, resolvedUri: "", targetDuration: e.duration, discontinuityStarts: n, timelineStarts: e.timelineStarts, segments: t }; return e.frameRate && (s.attributes["FRAME-RATE"] = e.frameRate), e.contentProtection && (s.contentProtection = e.contentProtection), i && (s.sidx = i), s }, pt = ({ attributes: e }) => "video/mp4" === e.mimeType || "video/webm" === e.mimeType || "video" === e.contentType, mt = ({ attributes: e }) => "audio/mp4" === e.mimeType || "audio/webm" === e.mimeType || "audio" === e.contentType, ft = ({ attributes: e }) => "text/vtt" === e.mimeType || "text" === e.contentType, gt = e => e ? Object.keys(e).reduce(((t, i) => { const n = e[i]; return t.concat(n.playlists) }), []) : [], yt = ({ dashPlaylists: e, locations: t, sidxMapping: i = {}, previousManifest: n, eventStream: s }) => { if (!e.length) return {}; const { sourceDuration: a, type: r, suggestedPresentationDelay: o, minimumUpdatePeriod: d } = e[0].attributes, u = ut(e.filter(pt)).map(ct), l = ut(e.filter(mt)), h = ut(e.filter(ft)), c = e.map((e => e.attributes.captionServices)).filter(Boolean), p = { allowCache: !0, discontinuityStarts: [], segments: [], endList: !0, mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: "", duration: a, playlists: ht(u, i) }; d >= 0 && (p.minimumUpdatePeriod = 1e3 * d), t && (p.locations = t), "dynamic" === r && (p.suggestedPresentationDelay = o), s && s.length > 0 && (p.eventStream = s); const m = 0 === p.playlists.length, f = l.length ? ((e, t = {}, i = !1) => { let n; const s = e.reduce(((e, s) => { const a = s.attributes.role && s.attributes.role.value || "", r = s.attributes.lang || ""; let o = s.attributes.label || "main"; if (r && !s.attributes.label) { const e = a ? ` (${a})` : ""; o = `${s.attributes.lang}${e}` } e[o] || (e[o] = { language: r, autoselect: !0, default: "main" === a, playlists: [], uri: "" }); const d = lt((({ attributes: e, segments: t, sidx: i, mediaSequence: n, discontinuitySequence: s, discontinuityStarts: a }, r) => { const o = { attributes: { NAME: e.id, BANDWIDTH: e.bandwidth, CODECS: e.codecs, "PROGRAM-ID": 1 }, uri: "", endList: "static" === e.type, timeline: e.periodStart, resolvedUri: "", targetDuration: e.duration, discontinuitySequence: s, discontinuityStarts: a, timelineStarts: e.timelineStarts, mediaSequence: n, segments: t }; return e.contentProtection && (o.contentProtection = e.contentProtection), i && (o.sidx = i), r && (o.attributes.AUDIO = "audio", o.attributes.SUBTITLES = "subs"), o })(s, i), t); return e[o].playlists.push(d), void 0 === n && "main" === a && (n = s, n.default = !0), e }), {}); return n || (s[Object.keys(s)[0]].default = !0), s })(l, i, m) : null, g = h.length ? ((e, t = {}) => e.reduce(((e, i) => { const n = i.attributes.label || i.attributes.lang || "text"; return e[n] || (e[n] = { language: n, default: !1, autoselect: !1, playlists: [], uri: "" }), e[n].playlists.push(lt((({ attributes: e, segments: t, mediaSequence: i, discontinuityStarts: n, discontinuitySequence: s }) => { void 0 === t && (t = [{ uri: e.baseUrl, timeline: e.periodStart, resolvedUri: e.baseUrl || "", duration: e.sourceDuration, number: 0 }], e.duration = e.sourceDuration); const a = { NAME: e.id, BANDWIDTH: e.bandwidth, "PROGRAM-ID": 1 }; return e.codecs && (a.CODECS = e.codecs), { attributes: a, uri: "", endList: "static" === e.type, timeline: e.periodStart, resolvedUri: e.baseUrl || "", targetDuration: e.duration, timelineStarts: e.timelineStarts, discontinuityStarts: n, discontinuitySequence: s, mediaSequence: i, segments: t } })(i), t)), e }), {}))(h, i) : null, y = u.concat(gt(f), gt(g)), _ = y.map((({ timelineStarts: e }) => e)); var T, b; return p.timelineStarts = at(_), T = y, b = p.timelineStarts, T.forEach((e => { e.mediaSequence = 0, e.discontinuitySequence = b.findIndex((function ({ timeline: t }) { return t === e.timeline })), e.segments && e.segments.forEach(((e, t) => { e.number = t })) })), f && (p.mediaGroups.AUDIO.audio = f), g && (p.mediaGroups.SUBTITLES.subs = g), c.length && (p.mediaGroups["CLOSED-CAPTIONS"].cc = c.reduce(((e, t) => t ? (t.forEach((t => { const { channel: i, language: n } = t; e[n] = { autoselect: !1, default: !1, instreamId: i, language: n }, t.hasOwnProperty("aspectRatio") && (e[n].aspectRatio = t.aspectRatio), t.hasOwnProperty("easyReader") && (e[n].easyReader = t.easyReader), t.hasOwnProperty("3D") && (e[n]["3D"] = t["3D"]) })), e) : e), {})), n ? (({ oldManifest: e, newManifest: t }) => { const i = e.playlists.concat(rt(e)), n = t.playlists.concat(rt(t)); return t.timelineStarts = at([e.timelineStarts, t.timelineStarts]), (({ oldPlaylists: e, newPlaylists: t, timelineStarts: i }) => { t.forEach((t => { t.discontinuitySequence = i.findIndex((function ({ timeline: e }) { return e === t.timeline })); const n = ((e, t) => { for (let i = 0; i < e.length; i++)if (e[i].attributes.NAME === t) return e[i]; return null })(e, t.attributes.NAME); if (!n) return; if (t.sidx) return; const s = t.segments[0], a = n.segments.findIndex((function (e) { return Math.abs(e.presentationTime - s.presentationTime) < .016666666666666666 })); if (-1 === a) return ot({ playlist: t, mediaSequence: n.mediaSequence + n.segments.length }), t.segments[0].discontinuity = !0, t.discontinuityStarts.unshift(0), void ((!n.segments.length && t.timeline > n.timeline || n.segments.length && t.timeline > n.segments[n.segments.length - 1].timeline) && t.discontinuitySequence--); n.segments[a].discontinuity && !s.discontinuity && (s.discontinuity = !0, t.discontinuityStarts.unshift(0), t.discontinuitySequence--), ot({ playlist: t, mediaSequence: n.segments[a].number }) })) })({ oldPlaylists: i, newPlaylists: n, timelineStarts: t.timelineStarts }), t })({ oldManifest: n, newManifest: p }) : p }, _t = (e, t, i) => { const { NOW: n, clientOffset: s, availabilityStartTime: a, timescale: r = 1, periodStart: o = 0, minimumUpdatePeriod: d = 0 } = e, u = (n + s) / 1e3 + d - (a + o); return Math.ceil((u * r - t) / i) }, Tt = (e, t) => { const { type: i, minimumUpdatePeriod: n = 0, media: s = "", sourceDuration: a, timescale: r = 1, startNumber: o = 1, periodStart: d } = e, u = []; let l = -1; for (let h = 0; h < t.length; h++) { const c = t[h], p = c.d, m = c.r || 0, f = c.t || 0; let g; if (l < 0 && (l = f), f && f > l && (l = f), m < 0) { const o = h + 1; g = o === t.length ? "dynamic" === i && n > 0 && s.indexOf("$Number$") > 0 ? _t(e, l, p) : (a * r - l) / p : (t[o].t - l) / p } else g = m + 1; const y = o + u.length + g; let _ = o + u.length; for (; _ < y;)u.push({ number: _, duration: p / r, time: l, timeline: d }), l += p, _++ } return u }, bt = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, St = (e, t) => e.replace(bt, (e => (t, i, n, s) => { if ("$$" === t) return "$"; if (void 0 === e[i]) return t; const a = "" + e[i]; return "RepresentationID" === i ? a : (s = n ? parseInt(s, 10) : 1, a.length >= s ? a : `${new Array(s - a.length + 1).join("0")}${a}`) })(t)), vt = (e, t) => { const i = { RepresentationID: e.id, Bandwidth: e.bandwidth || 0 }, { initialization: n = { sourceURL: "", range: "" } } = e, s = Je({ baseUrl: e.baseUrl, source: St(n.sourceURL, i), range: n.range }), a = ((e, t) => e.duration || t ? e.duration ? tt(e) : Tt(e, t) : [{ number: e.startNumber || 1, duration: e.sourceDuration, time: 0, timeline: e.periodStart }])(e, t); return a.map((t => { i.Number = t.number, i.Time = t.time; const n = St(e.media || "", i), a = e.timescale || 1, r = e.presentationTimeOffset || 0, o = e.periodStart + (t.time - r) / a; return { uri: n, timeline: t.timeline, duration: t.duration, resolvedUri: d(e.baseUrl || "", n), map: s, number: t.number, presentationTime: o } })) }, wt = (e, t) => { const { duration: i, segmentUrls: n = [], periodStart: s } = e; if (!i && !t || i && t) throw new Error("SEGMENT_TIME_UNSPECIFIED"); const a = n.map((t => ((e, t) => { const { baseUrl: i, initialization: n = {} } = e, s = Je({ baseUrl: i, source: n.sourceURL, range: n.range }), a = Je({ baseUrl: i, source: t.media, range: t.mediaRange }); return a.map = s, a })(e, t))); let r; return i && (r = tt(e)), t && (r = Tt(e, t)), r.map(((t, i) => { if (a[i]) { const n = a[i], r = e.timescale || 1, o = e.presentationTimeOffset || 0; return n.timeline = t.timeline, n.duration = t.duration, n.number = t.number, n.presentationTime = s + (t.time - o) / r, n } })).filter((e => e)) }, It = ({ attributes: e, segmentInfo: t }) => { let i, n; t.template ? (n = vt, i = ze(e, t.template)) : t.base ? (n = it, i = ze(e, t.base)) : t.list && (n = wt, i = ze(e, t.list)); const s = { attributes: e }; if (!n) return s; const a = n(i, t.segmentTimeline); if (i.duration) { const { duration: e, timescale: t = 1 } = i; i.duration = e / t } else a.length ? i.duration = a.reduce(((e, t) => Math.max(e, Math.ceil(t.duration))), 0) : i.duration = 0; return s.attributes = i, s.segments = a, t.base && i.indexRange && (s.sidx = a[0], s.segments = []), s }, Et = (e, t) => Ke(e.childNodes).filter((({ tagName: e }) => e === t)), At = e => e.textContent.trim(), Lt = e => { const t = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(e); if (!t) return 0; const [i, n, s, a, r, o] = t.slice(1); return 31536e3 * parseFloat(i || 0) + 2592e3 * parseFloat(n || 0) + 86400 * parseFloat(s || 0) + 3600 * parseFloat(a || 0) + 60 * parseFloat(r || 0) + parseFloat(o || 0) }, Dt = { mediaPresentationDuration: e => Lt(e), availabilityStartTime(e) { return /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(t = e) && (t += "Z"), Date.parse(t) / 1e3; var t }, minimumUpdatePeriod: e => Lt(e), suggestedPresentationDelay: e => Lt(e), type: e => e, timeShiftBufferDepth: e => Lt(e), start: e => Lt(e), width: e => parseInt(e, 10), height: e => parseInt(e, 10), bandwidth: e => parseInt(e, 10), frameRate: e => (e => parseFloat(e.split("/").reduce(((e, t) => e / t))))(e), startNumber: e => parseInt(e, 10), timescale: e => parseInt(e, 10), presentationTimeOffset: e => parseInt(e, 10), duration(e) { const t = parseInt(e, 10); return isNaN(t) ? Lt(e) : t }, d: e => parseInt(e, 10), t: e => parseInt(e, 10), r: e => parseInt(e, 10), presentationTime: e => parseInt(e, 10), DEFAULT: e => e }, xt = e => e && e.attributes ? Ke(e.attributes).reduce(((e, t) => { const i = Dt[t.name] || Dt.DEFAULT; return e[t.name] = i(t.value), e }), {}) : {}, kt = { "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha", "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready", "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime" }, Ot = (e, t) => t.length ? Qe(e.map((function (e) { return t.map((function (t) { return d(e, At(t)) })) }))) : e, Pt = e => { const t = Et(e, "SegmentTemplate")[0], i = Et(e, "SegmentList")[0], n = i && Et(i, "SegmentURL").map((e => ze({ tag: "SegmentURL" }, xt(e)))), s = Et(e, "SegmentBase")[0], a = i || t, r = a && Et(a, "SegmentTimeline")[0], o = i || s || t, d = o && Et(o, "Initialization")[0], u = t && xt(t); u && d ? u.initialization = d && xt(d) : u && u.initialization && (u.initialization = { sourceURL: u.initialization }); const l = { template: u, segmentTimeline: r && Et(r, "S").map((e => xt(e))), list: i && ze(xt(i), { segmentUrls: n, initialization: xt(d) }), base: s && ze(xt(s), { initialization: xt(d) }) }; return Object.keys(l).forEach((e => { l[e] || delete l[e] })), l }, Ct = e => Qe(Et(e.node, "EventStream").map((t => { const i = xt(t), n = i.schemeIdUri; return Et(t, "Event").map((t => { const s = xt(t), a = s.presentationTime || 0, r = i.timescale || 1, o = s.duration || 0, d = a / r + e.attributes.start; return { schemeIdUri: n, value: i.value, id: s.id, start: d, end: d + o / r, messageData: At(t) || s.messageData, contentEncoding: i.contentEncoding, presentationTimeOffset: i.presentationTimeOffset || 0 } })) }))), Ut = (e, t) => (i, n) => { const s = Ot(t, Et(i.node, "BaseURL")), a = ze(e, { periodStart: i.attributes.start }); "number" == typeof i.attributes.duration && (a.periodDuration = i.attributes.duration); const r = Et(i.node, "AdaptationSet"), o = Pt(i.node); return Qe(r.map(((e, t, i) => n => { const s = xt(n), a = Ot(t, Et(n, "BaseURL")), r = Et(n, "Role")[0], o = { role: xt(r) }; let d = ze(e, s, o); const u = Et(n, "Accessibility")[0], l = "urn:scte:dash:cc:cea-608:2015" === (h = xt(u)).schemeIdUri ? ("string" != typeof h.value ? [] : h.value.split(";")).map((e => { let t, i; return i = e, /^CC\d=/.test(e) ? [t, i] = e.split("=") : /^CC\d$/.test(e) && (t = e), { channel: t, language: i } })) : "urn:scte:dash:cc:cea-708:2015" === h.schemeIdUri ? ("string" != typeof h.value ? [] : h.value.split(";")).map((e => { const t = { channel: void 0, language: void 0, aspectRatio: 1, easyReader: 0, "3D": 0 }; if (/=/.test(e)) { const [i, n = ""] = e.split("="); t.channel = i, t.language = e, n.split(",").forEach((e => { const [i, n] = e.split(":"); "lang" === i ? t.language = n : "er" === i ? t.easyReader = Number(n) : "war" === i ? t.aspectRatio = Number(n) : "3D" === i && (t["3D"] = Number(n)) })) } else t.language = e; return t.channel && (t.channel = "SERVICE" + t.channel), t })) : void 0; var h; l && (d = ze(d, { captionServices: l })); const c = Et(n, "Label")[0]; if (c && c.childNodes.length) { const e = c.childNodes[0].nodeValue.trim(); d = ze(d, { label: e }) } const p = Et(n, "ContentProtection").reduce(((e, t) => { const i = xt(t); i.schemeIdUri && (i.schemeIdUri = i.schemeIdUri.toLowerCase()); const n = kt[i.schemeIdUri]; if (n) { e[n] = { attributes: i }; const s = Et(t, "cenc:pssh")[0]; if (s) { const t = At(s); e[n].pssh = t && m(t) } } return e }), {}); Object.keys(p).length && (d = ze(d, { contentProtection: p })); const f = Pt(n), g = Et(n, "Representation"), y = ze(i, f); return Qe(g.map(((e, t, i) => n => { const s = Et(n, "BaseURL"), a = Ot(t, s), r = ze(e, xt(n)), o = Pt(n); return a.map((e => ({ segmentInfo: ze(i, o), attributes: ze(r, { baseUrl: e }) }))) })(d, a, y))) })(a, s, o))) }, Rt = e => { if ("" === e) throw new Error("DASH_EMPTY_MANIFEST"); const t = new i.DOMParser; let n, s; try { n = t.parseFromString(e, "application/xml"), s = n && "MPD" === n.documentElement.tagName ? n.documentElement : null } catch (e) { } if (!s || s && s.getElementsByTagName("parsererror").length > 0) throw new Error("DASH_INVALID_XML"); return s }; var Mt = Math.pow(2, 32), Bt = function (e) { var t, i = new DataView(e.buffer, e.byteOffset, e.byteLength); return i.getBigUint64 ? (t = i.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : i.getUint32(0) * Mt + i.getUint32(4) }, Nt = Pe([73, 68, 51]), Ft = function e(t, i) { return void 0 === i && (i = 0), (t = Pe(t)).length - i < 10 || !Be(t, Nt, { offset: i }) ? i : (i += function (e, t) { void 0 === t && (t = 0); var i = (e = Pe(e))[t + 5], n = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]; return (16 & i) >> 4 ? n + 20 : n + 10 }(t, i), e(t, i)) }, $t = function (e) { return "string" == typeof e ? Me(e) : e }, qt = function e(t, i, n) { void 0 === n && (n = !1), i = function (e) { return Array.isArray(e) ? e.map((function (e) { return $t(e) })) : [$t(e)] }(i), t = Pe(t); var s = []; if (!i.length) return s; for (var a = 0; a < t.length;) { var r = (t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3]) >>> 0, o = t.subarray(a + 4, a + 8); if (0 === r) break; var d = a + r; if (d > t.length) { if (n) break; d = t.length } var u = t.subarray(a + 8, d); Be(o, i[0]) && (1 === i.length ? s.push(u) : s.push.apply(s, e(u, i.slice(1), n))), a = d } return s }, Gt = { EBML: Pe([26, 69, 223, 163]), DocType: Pe([66, 130]), Segment: Pe([24, 83, 128, 103]), SegmentInfo: Pe([21, 73, 169, 102]), Tracks: Pe([22, 84, 174, 107]), Track: Pe([174]), TrackNumber: Pe([215]), DefaultDuration: Pe([35, 227, 131]), TrackEntry: Pe([174]), TrackType: Pe([131]), FlagDefault: Pe([136]), CodecID: Pe([134]), CodecPrivate: Pe([99, 162]), VideoTrack: Pe([224]), AudioTrack: Pe([225]), Cluster: Pe([31, 67, 182, 117]), Timestamp: Pe([231]), TimestampScale: Pe([42, 215, 177]), BlockGroup: Pe([160]), BlockDuration: Pe([155]), Block: Pe([161]), SimpleBlock: Pe([163]) }, Wt = [128, 64, 32, 16, 8, 4, 2, 1], Vt = function (e, t, i, n) { void 0 === i && (i = !0), void 0 === n && (n = !1); var s = function (e) { for (var t = 1, i = 0; i < Wt.length && !(e & Wt[i]); i++)t++; return t }(e[t]), a = e.subarray(t, t + s); return i && ((a = Array.prototype.slice.call(e, t, t + s))[0] ^= Wt[s - 1]), { length: s, value: Re(a, { signed: n }), bytes: a } }, Ht = function e(t) { return "string" == typeof t ? t.match(/.{1,2}/g).map((function (t) { return e(t) })) : "number" == typeof t ? function (e, t) { var i = (void 0 === t ? {} : t).le, n = void 0 !== i && i; ("bigint" != typeof e && "number" != typeof e || "number" == typeof e && e != e) && (e = 0); for (var s, a = (s = e = Ce(e), Math.ceil(function (e) { return e.toString(2).length }(s) / 8)), r = new Uint8Array(new ArrayBuffer(a)), o = 0; o < a; o++) { var d = n ? o : Math.abs(o + 1 - r.length); r[d] = Number(e / Ue[o] & Ce(255)), e < 0 && (r[d] = Math.abs(~r[d]), r[d] -= 0 === o ? 1 : 2) } return r }(t) : t }, Xt = function e(t, i, n) { if (n >= i.length) return i.length; var s = Vt(i, n, !1); if (Be(t.bytes, s.bytes)) return n; var a = Vt(i, n + s.length); return e(t, i, n + a.length + a.value + s.length) }, jt = function e(t, i) { i = function (e) { return Array.isArray(e) ? e.map((function (e) { return Ht(e) })) : [Ht(e)] }(i), t = Pe(t); var n = []; if (!i.length) return n; for (var s = 0; s < t.length;) { var a = Vt(t, s, !1), r = Vt(t, s + a.length), o = s + a.length + r.length; 127 === r.value && (r.value = Xt(a, t, o), r.value !== t.length && (r.value -= o)); var d = o + r.value > t.length ? t.length : o + r.value, u = t.subarray(o, d); Be(i[0], a.bytes) && (1 === i.length ? n.push(u) : n = n.concat(e(u, i.slice(1)))), s += a.length + r.length + u.length } return n }, zt = Pe([0, 0, 0, 1]), Yt = Pe([0, 0, 1]), Qt = Pe([0, 0, 3]), Kt = function (e) { for (var t = [], i = 1; i < e.length - 2;)Be(e.subarray(i, i + 3), Qt) && (t.push(i + 2), i++), i++; if (0 === t.length) return e; var n = e.length - t.length, s = new Uint8Array(n), a = 0; for (i = 0; i < n; a++, i++)a === t[0] && (a++, t.shift()), s[i] = e[a]; return s }, Jt = function (e, t, i, n) { void 0 === n && (n = 1 / 0), e = Pe(e), i = [].concat(i); for (var s, a = 0, r = 0; a < e.length && (r < n || s);) { var o = void 0; if (Be(e.subarray(a), zt) ? o = 4 : Be(e.subarray(a), Yt) && (o = 3), o) { if (r++, s) return Kt(e.subarray(s, a)); var d = void 0; "h264" === t ? d = 31 & e[a + o] : "h265" === t && (d = e[a + o] >> 1 & 63), -1 !== i.indexOf(d) && (s = a + o), a += o + ("h264" === t ? 1 : 2) } else a++ } return e.subarray(0, 0) }, Zt = { webm: Pe([119, 101, 98, 109]), matroska: Pe([109, 97, 116, 114, 111, 115, 107, 97]), flac: Pe([102, 76, 97, 67]), ogg: Pe([79, 103, 103, 83]), ac3: Pe([11, 119]), riff: Pe([82, 73, 70, 70]), avi: Pe([65, 86, 73]), wav: Pe([87, 65, 86, 69]), "3gp": Pe([102, 116, 121, 112, 51, 103]), mp4: Pe([102, 116, 121, 112]), fmp4: Pe([115, 116, 121, 112]), mov: Pe([102, 116, 121, 112, 113, 116]), moov: Pe([109, 111, 111, 118]), moof: Pe([109, 111, 111, 102]) }, ei = { aac: function (e) { var t = Ft(e); return Be(e, [255, 16], { offset: t, mask: [255, 22] }) }, mp3: function (e) { var t = Ft(e); return Be(e, [255, 2], { offset: t, mask: [255, 6] }) }, webm: function (e) { var t = jt(e, [Gt.EBML, Gt.DocType])[0]; return Be(t, Zt.webm) }, mkv: function (e) { var t = jt(e, [Gt.EBML, Gt.DocType])[0]; return Be(t, Zt.matroska) }, mp4: function (e) { return !ei["3gp"](e) && !ei.mov(e) && (!(!Be(e, Zt.mp4, { offset: 4 }) && !Be(e, Zt.fmp4, { offset: 4 })) || !(!Be(e, Zt.moof, { offset: 4 }) && !Be(e, Zt.moov, { offset: 4 })) || void 0) }, mov: function (e) { return Be(e, Zt.mov, { offset: 4 }) }, "3gp": function (e) { return Be(e, Zt["3gp"], { offset: 4 }) }, ac3: function (e) { var t = Ft(e); return Be(e, Zt.ac3, { offset: t }) }, ts: function (e) { if (e.length < 189 && e.length >= 1) return 71 === e[0]; for (var t = 0; t + 188 < e.length && t < 188;) { if (71 === e[t] && 71 === e[t + 188]) return !0; t += 1 } return !1 }, flac: function (e) { var t = Ft(e); return Be(e, Zt.flac, { offset: t }) }, ogg: function (e) { return Be(e, Zt.ogg) }, avi: function (e) { return Be(e, Zt.riff) && Be(e, Zt.avi, { offset: 8 }) }, wav: function (e) { return Be(e, Zt.riff) && Be(e, Zt.wav, { offset: 8 }) }, h264: function (e) { return function (e, t, i) { return Jt(e, "h264", 7, 3) }(e).length }, h265: function (e) { return function (e, t, i) { return Jt(e, "h265", [32, 33], 3) }(e).length } }, ti = Object.keys(ei).filter((function (e) { return "ts" !== e && "h264" !== e && "h265" !== e })).concat(["ts", "h264", "h265"]); ti.forEach((function (e) { var t = ei[e]; ei[e] = function (e) { return t(Pe(e)) } })); var ii = ei, ni = function (e) { e = Pe(e); for (var t = 0; t < ti.length; t++) { var i = ti[t]; if (ii[i](e)) return i } return "" }; const si = (e, t) => { if (4 === e.readyState) return t() }, { EventTarget: ai } = s.default, ri = function (e, t) { if (!_e(e, t)) return !1; if (e.sidx && t.sidx && (e.sidx.offset !== t.sidx.offset || e.sidx.length !== t.sidx.length)) return !1; if (!e.sidx && t.sidx || e.sidx && !t.sidx) return !1; if (e.segments && !t.segments || !e.segments && t.segments) return !1; if (!e.segments && !t.segments) return !0; for (let i = 0; i < e.segments.length; i++) { const n = e.segments[i], s = t.segments[i]; if (n.uri !== s.uri) return !1; if (!n.byterange && !s.byterange) continue; const a = n.byterange, r = s.byterange; if (a && !r || !a && r) return !1; if (a.offset !== r.offset || a.length !== r.length) return !1 } return !0 }, oi = (e, t, i, n) => `placeholder-uri-${e}-${t}-${n.attributes.NAME || i}`, di = (e, t) => (Boolean(!e.map && !t.map) || Boolean(e.map && t.map && e.map.byterange.offset === t.map.byterange.offset && e.map.byterange.length === t.map.byterange.length)) && e.uri === t.uri && e.byterange.offset === t.byterange.offset && e.byterange.length === t.byterange.length, ui = (e, t) => { const i = {}; for (const n in e) { const s = e[n].sidx; if (s) { const e = dt(s); if (!t[e]) break; const n = t[e].sidxInfo; di(n, s) && (i[e] = t[e]) } } return i }; class li extends ai { constructor(e, t, i = {}, n) { super(), this.mainPlaylistLoader_ = n || this, n || (this.isMain_ = !0); const { withCredentials: s = !1 } = i; if (this.vhs_ = t, this.withCredentials = s, this.addMetadataToTextTrack = i.addMetadataToTextTrack, !e) throw new Error("A non-empty playlist URL or object is required"); this.on("minimumUpdatePeriod", (() => { this.refreshXml_() })), this.on("mediaupdatetimeout", (() => { this.refreshMedia_(this.media().id) })), this.state = "HAVE_NOTHING", this.loadedPlaylists_ = {}, this.logger_ = h("DashPlaylistLoader"), this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = e, this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = e } requestErrored_(e, t, i) { return !this.request || (this.request = null, e ? (this.error = "object" != typeof e || e instanceof Error ? { status: t.status, message: "DASH request error at URL: " + t.uri, response: t.response, code: 2 } : e, i && (this.state = i), this.trigger("error"), !0) : void 0) } addSidxSegments_(e, t, i) { const n = e.sidx && dt(e.sidx); if (!e.sidx || !n || this.mainPlaylistLoader_.sidxMapping_[n]) return void (this.mediaRequest_ = window.setTimeout((() => i(!1)), 0)); const s = l(e.sidx.resolvedUri), a = (s, a) => { if (this.requestErrored_(s, a, t)) return; const r = this.mainPlaylistLoader_.sidxMapping_; let o; try { o = function (e) { var t = new DataView(e.buffer, e.byteOffset, e.byteLength), i = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), references: [], referenceId: t.getUint32(4), timescale: t.getUint32(8) }, n = 12; 0 === i.version ? (i.earliestPresentationTime = t.getUint32(n), i.firstOffset = t.getUint32(n + 4), n += 8) : (i.earliestPresentationTime = Bt(e.subarray(n)), i.firstOffset = Bt(e.subarray(n + 8)), n += 16), n += 2; var s = t.getUint16(n); for (n += 2; s > 0; n += 12, s--)i.references.push({ referenceType: (128 & e[n]) >>> 7, referencedSize: 2147483647 & t.getUint32(n), subsegmentDuration: t.getUint32(n + 4), startsWithSap: !!(128 & e[n + 8]), sapType: (112 & e[n + 8]) >>> 4, sapDeltaTime: 268435455 & t.getUint32(n + 8) }); return i }(Pe(a.response).subarray(8)) } catch (e) { return void this.requestErrored_(e, a, t) } return r[n] = { sidxInfo: e.sidx, sidx: o }, nt(e, o, e.sidx.resolvedUri), i(!0) }; this.request = ((e, t, i) => { let n, s = [], a = !1; const r = function (e, t, n, s) { return t.abort(), a = !0, i(e, t, n, s) }, o = function (e, t) { if (a) return; if (e) return r(e, t, "", s); const i = t.responseText.substring(s && s.byteLength || 0, t.responseText.length); if (s = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; if (t = t.filter((function (e) { return e && (e.byteLength || e.length) && "string" != typeof e })), t.length <= 1) return Pe(t[0]); var n = t.reduce((function (e, t, i) { return e + (t.byteLength || t.length) }), 0), s = new Uint8Array(n), a = 0; return t.forEach((function (e) { e = Pe(e), s.set(e, a), a += e.byteLength })), s }(s, Me(i, !0)), n = n || Ft(s), s.length < 10 || n && s.length < n + 2) return si(t, (() => r(e, t, "", s))); const o = ni(s); return "ts" === o && s.length < 188 || !o && s.length < 376 ? si(t, (() => r(e, t, "", s))) : r(null, t, o, s) }, d = { uri: e, beforeSend(e) { e.overrideMimeType("text/plain; charset=x-user-defined"), e.addEventListener("progress", (function ({ total: t, loaded: i }) { return we(e, null, { statusCode: e.status }, o) })) } }, u = t(d, (function (e, t) { return we(u, e, t, o) })); return u })(s, this.vhs_.xhr, ((t, i, n, r) => { if (t) return a(t, i); if (!n || "mp4" !== n) return a({ status: i.status, message: `Unsupported ${n || "unknown"} container type for sidx segment at URL: ${s}`, response: "", playlist: e, internal: !0, playlistExclusionDuration: 1 / 0, code: 2 }, i); const { offset: o, length: d } = e.sidx.byterange; if (r.length >= d + o) return a(t, { response: r.subarray(o, o + d), status: i.status, uri: i.uri }); this.request = this.vhs_.xhr({ uri: s, responseType: "arraybuffer", headers: Ee({ byterange: e.sidx.byterange }) }, a) })) } dispose() { this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, window.clearTimeout(this.minimumUpdatePeriodTimeout_), window.clearTimeout(this.mediaRequest_), window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.off() } hasPendingRequest() { return this.request || this.mediaRequest_ } stopRequest() { if (this.request) { const e = this.request; this.request = null, e.onreadystatechange = null, e.abort() } } media(e) { if (!e) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); const t = this.state; if ("string" == typeof e) { if (!this.mainPlaylistLoader_.main.playlists[e]) throw new Error("Unknown playlist URI: " + e); e = this.mainPlaylistLoader_.main.playlists[e] } const i = !this.media_ || e.id !== this.media_.id; if (i && this.loadedPlaylists_[e.id] && this.loadedPlaylists_[e.id].endList) return this.state = "HAVE_METADATA", this.media_ = e, void (i && (this.trigger("mediachanging"), this.trigger("mediachange"))); i && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(e, t, (i => { this.haveMetadata({ startingState: t, playlist: e }) }))) } haveMetadata({ startingState: e, playlist: t }) { this.state = "HAVE_METADATA", this.loadedPlaylists_[t.id] = t, this.mediaRequest_ = null, this.refreshMedia_(t.id), "HAVE_MAIN_MANIFEST" === e ? this.trigger("loadedmetadata") : this.trigger("mediachange") } pause() { this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMain_ && (window.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_), this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), "HAVE_NOTHING" === this.state && (this.started = !1) } load(e) { window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null; const t = this.media(); if (e) { const e = t ? t.targetDuration / 2 * 1e3 : 5e3; this.mediaUpdateTimeout = window.setTimeout((() => this.load()), e) } else this.started ? t && !t.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist") : this.start() } start() { this.started = !0, this.isMain_ ? this.requestMain_(((e, t) => { this.haveMain_(), this.hasPendingRequest() || this.media_ || this.media(this.mainPlaylistLoader_.main.playlists[0]) })) : this.mediaRequest_ = window.setTimeout((() => this.haveMain_()), 0) } requestMain_(e) { this.request = this.vhs_.xhr({ uri: this.mainPlaylistLoader_.srcUrl, withCredentials: this.withCredentials }, ((t, i) => { if (this.requestErrored_(t, i)) return void ("HAVE_NOTHING" === this.state && (this.started = !1)); const n = i.responseText !== this.mainPlaylistLoader_.mainXml_; return this.mainPlaylistLoader_.mainXml_ = i.responseText, i.responseHeaders && i.responseHeaders.date ? this.mainLoaded_ = Date.parse(i.responseHeaders.date) : this.mainLoaded_ = Date.now(), this.mainPlaylistLoader_.srcUrl = l(this.mainPlaylistLoader_.srcUrl, i), n ? (this.handleMain_(), void this.syncClientServerClock_((() => e(i, n)))) : e(i, n) })) } syncClientServerClock_(e) { const t = (i = this.mainPlaylistLoader_.mainXml_, (e => { const t = Et(e, "UTCTiming")[0]; if (!t) return null; const i = xt(t); switch (i.schemeIdUri) { case "urn:mpeg:dash:utc:http-head:2014": case "urn:mpeg:dash:utc:http-head:2012": i.method = "HEAD"; break; case "urn:mpeg:dash:utc:http-xsdate:2014": case "urn:mpeg:dash:utc:http-iso:2014": case "urn:mpeg:dash:utc:http-xsdate:2012": case "urn:mpeg:dash:utc:http-iso:2012": i.method = "GET"; break; case "urn:mpeg:dash:utc:direct:2014": case "urn:mpeg:dash:utc:direct:2012": i.method = "DIRECT", i.value = Date.parse(i.value); break; default: throw new Error("UNSUPPORTED_UTC_TIMING_SCHEME") }return i })(Rt(i))); var i; return null === t ? (this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e()) : "DIRECT" === t.method ? (this.mainPlaylistLoader_.clientOffset_ = t.value - Date.now(), e()) : void (this.request = this.vhs_.xhr({ uri: u(this.mainPlaylistLoader_.srcUrl, t.value), method: t.method, withCredentials: this.withCredentials }, ((i, n) => { if (!this.request) return; if (i) return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e(); let s; s = "HEAD" === t.method ? n.responseHeaders && n.responseHeaders.date ? Date.parse(n.responseHeaders.date) : this.mainLoaded_ : Date.parse(n.responseText), this.mainPlaylistLoader_.clientOffset_ = s - Date.now(), e() }))) } haveMain_() { this.state = "HAVE_MAIN_MANIFEST", this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_) } handleMain_() { this.mediaRequest_ = null; const e = this.mainPlaylistLoader_.main; let t = (({ mainXml: e, srcUrl: t, clientOffset: i, sidxMapping: n, previousManifest: s }) => { const a = ((e, t = {}) => { const i = ((e, t = {}) => { const { manifestUri: i = "", NOW: n = Date.now(), clientOffset: s = 0 } = t, a = Et(e, "Period"); if (!a.length) throw new Error("INVALID_NUMBER_OF_PERIOD"); const r = Et(e, "Location"), o = xt(e), d = Ot([i], Et(e, "BaseURL")); o.type = o.type || "static", o.sourceDuration = o.mediaPresentationDuration || 0, o.NOW = n, o.clientOffset = s, r.length && (o.locations = r.map(At)); const u = []; return a.forEach(((e, t) => { const i = xt(e), n = u[t - 1]; i.start = (({ attributes: e, priorPeriodAttributes: t, mpdType: i }) => "number" == typeof e.start ? e.start : t && "number" == typeof t.start && "number" == typeof t.duration ? t.start + t.duration : t || "static" !== i ? null : 0)({ attributes: i, priorPeriodAttributes: n ? n.attributes : null, mpdType: o.type }), u.push({ node: e, attributes: i }) })), { locations: o.locations, representationInfo: Qe(u.map(Ut(o, d))), eventStream: Qe(u.map(Ct)) } })(Rt(e), t), n = i.representationInfo.map(It); return yt({ dashPlaylists: n, locations: i.locations, sidxMapping: t.sidxMapping, previousManifest: t.previousManifest, eventStream: i.eventStream }) })(e, { manifestUri: t, clientOffset: i, sidxMapping: n, previousManifest: s }); return pe(a, t, oi), a })({ mainXml: this.mainPlaylistLoader_.mainXml_, srcUrl: this.mainPlaylistLoader_.srcUrl, clientOffset: this.mainPlaylistLoader_.clientOffset_, sidxMapping: this.mainPlaylistLoader_.sidxMapping_, previousManifest: e }); e && (t = ((e, t, i) => { let n = !0, s = C(e, { duration: t.duration, minimumUpdatePeriod: t.minimumUpdatePeriod, timelineStarts: t.timelineStarts }); for (let e = 0; e < t.playlists.length; e++) { const a = t.playlists[e]; if (a.sidx) { const e = dt(a.sidx); i && i[e] && i[e].sidx && nt(a, i[e].sidx, a.sidx.resolvedUri) } const r = Te(s, a, ri); r && (s = r, n = !1) } return he(t, ((e, t, i, a) => { if (e.playlists && e.playlists.length) { const r = e.playlists[0].id, o = Te(s, e.playlists[0], ri); o && (s = o, a in s.mediaGroups[t][i] || (s.mediaGroups[t][i][a] = e), s.mediaGroups[t][i][a].playlists[0] = s.playlists[r], n = !1) } })), ((e, t) => { he(e, ((i, n, s, a) => { a in t.mediaGroups[n][s] || delete e.mediaGroups[n][s][a] })) })(s, t), t.minimumUpdatePeriod !== e.minimumUpdatePeriod && (n = !1), n ? null : s })(e, t, this.mainPlaylistLoader_.sidxMapping_)), this.mainPlaylistLoader_.main = t || e; const i = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0]; return i && i !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = i), (!e || t && t.minimumUpdatePeriod !== e.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), this.addEventStreamToMetadataTrack_(t), Boolean(t) } updateMinimumUpdatePeriodTimeout_() { const e = this.mainPlaylistLoader_; e.createMupOnMedia_ && (e.off("loadedmetadata", e.createMupOnMedia_), e.createMupOnMedia_ = null), e.minimumUpdatePeriodTimeout_ && (window.clearTimeout(e.minimumUpdatePeriodTimeout_), e.minimumUpdatePeriodTimeout_ = null); let t = e.main && e.main.minimumUpdatePeriod; 0 === t && (e.media() ? t = 1e3 * e.media().targetDuration : (e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_, e.one("loadedmetadata", e.createMupOnMedia_))), "number" != typeof t || t <= 0 ? t < 0 && this.logger_(`found invalid minimumUpdatePeriod of ${t}, not setting a timeout`) : this.createMUPTimeout_(t) } createMUPTimeout_(e) { const t = this.mainPlaylistLoader_; t.minimumUpdatePeriodTimeout_ = window.setTimeout((() => { t.minimumUpdatePeriodTimeout_ = null, t.trigger("minimumUpdatePeriod"), t.createMUPTimeout_(e) }), e) } refreshXml_() { this.requestMain_(((e, t) => { t && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]), this.mainPlaylistLoader_.sidxMapping_ = ((e, t) => { let i = ui(e.playlists, t); return he(e, ((e, n, s, a) => { if (e.playlists && e.playlists.length) { const n = e.playlists; i = C(i, ui(n, t)) } })), i })(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_), this.addSidxSegments_(this.media(), this.state, (e => { this.refreshMedia_(this.media().id) }))) })) } refreshMedia_(e) { if (!e) throw new Error("refreshMedia_ must take a media id"); this.media_ && this.isMain_ && this.handleMain_(); const t = this.mainPlaylistLoader_.main.playlists, i = !this.media_ || this.media_ !== t[e]; if (i ? this.media_ = t[e] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) { const e = () => { this.media().endList || (this.mediaUpdateTimeout = window.setTimeout((() => { this.trigger("mediaupdatetimeout"), e() }), be(this.media(), Boolean(i)))) }; e() } this.trigger("loadedplaylist") } addEventStreamToMetadataTrack_(e) { if (e && this.mainPlaylistLoader_.main.eventStream) { const e = this.mainPlaylistLoader_.main.eventStream.map((e => ({ cueTime: e.start, frames: [{ data: e.messageData }] }))); this.addMetadataToTextTrack("EventStream", e, this.mainPlaylistLoader_.main.duration) } } } var hi = { GOAL_BUFFER_LENGTH: 30, MAX_GOAL_BUFFER_LENGTH: 60, BACK_BUFFER_LENGTH: 30, GOAL_BUFFER_LENGTH_RATE: 1, INITIAL_BANDWIDTH: 4194304, BANDWIDTH_VARIANCE: 1.2, BUFFER_LOW_WATER_LINE: 0, MAX_BUFFER_LOW_WATER_LINE: 30, EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16, BUFFER_LOW_WATER_LINE_RATE: 1, BUFFER_HIGH_WATER_LINE: 30 }; const ci = function (e) { return e.on = e.addEventListener, e.off = e.removeEventListener, e }, pi = function (e) { return function () { const t = function (e) { try { return URL.createObjectURL(new Blob([e], { type: "application/javascript" })) } catch (t) { const i = new BlobBuilder; return i.append(e), URL.createObjectURL(i.getBlob()) } }(e), i = ci(new Worker(t)); i.objURL = t; const n = i.terminate; return i.on = i.addEventListener, i.off = i.removeEventListener, i.terminate = function () { return URL.revokeObjectURL(t), n.call(this) }, i } }, mi = function (e) { return `var browserWorkerPolyFill = ${ci.toString()};\nbrowserWorkerPolyFill(self);\n` + e }, fi = function (e) { return e.toString().replace(/^function.+?{/, "").slice(0, -1) }, gi = mi(fi((function () { var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, t = function () { this.init = function () { var e = {}; this.on = function (t, i) { e[t] || (e[t] = []), e[t] = e[t].concat(i) }, this.off = function (t, i) { var n; return !!e[t] && (n = e[t].indexOf(i), e[t] = e[t].slice(), e[t].splice(n, 1), n > -1) }, this.trigger = function (t) { var i, n, s, a; if (i = e[t]) if (2 === arguments.length) for (s = i.length, n = 0; n < s; ++n)i[n].call(this, arguments[1]); else { for (a = [], n = arguments.length, n = 1; n < arguments.length; ++n)a.push(arguments[n]); for (s = i.length, n = 0; n < s; ++n)i[n].apply(this, a) } }, this.dispose = function () { e = {} } } }; t.prototype.pipe = function (e) { return this.on("data", (function (t) { e.push(t) })), this.on("done", (function (t) { e.flush(t) })), this.on("partialdone", (function (t) { e.partialFlush(t) })), this.on("endedtimeline", (function (t) { e.endTimeline(t) })), this.on("reset", (function (t) { e.reset(t) })), e }, t.prototype.push = function (e) { this.trigger("data", e) }, t.prototype.flush = function (e) { this.trigger("done", e) }, t.prototype.partialFlush = function (e) { this.trigger("partialdone", e) }, t.prototype.endTimeline = function (e) { this.trigger("endedtimeline", e) }, t.prototype.reset = function (e) { this.trigger("reset", e) }; var i, n, s, a, r, o, d, u, l, h, c, p, m, f, g, y, _, T, b, S, v, w, I, E, A, L, D, x, k, O, P, C, U, R, M, B, N, F, $, q, G = t, W = Math.pow(2, 32), V = { getUint64: function (e) { var t, i = new DataView(e.buffer, e.byteOffset, e.byteLength); return i.getBigUint64 ? (t = i.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : i.getUint32(0) * W + i.getUint32(4) }, MAX_UINT32: W }, H = V.MAX_UINT32; !function () { var e; if (w = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], pasp: [], sdtp: [], smhd: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], styp: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [] }, "undefined" != typeof Uint8Array) { for (e in w) w.hasOwnProperty(e) && (w[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); I = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), A = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), E = new Uint8Array([0, 0, 0, 1]), L = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), D = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), x = { video: L, audio: D }, P = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), O = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), C = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), U = C, R = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), M = C, k = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) } }(), i = function (e) { var t, i, n = [], s = 0; for (t = 1; t < arguments.length; t++)n.push(arguments[t]); for (t = n.length; t--;)s += n[t].byteLength; for (i = new Uint8Array(s + 8), new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(0, i.byteLength), i.set(e, 4), t = 0, s = 8; t < n.length; t++)i.set(n[t], s), s += n[t].byteLength; return i }, n = function () { return i(w.dinf, i(w.dref, P)) }, s = function (e) { return i(w.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, e.audioobjecttype << 3 | e.samplingfrequencyindex >>> 1, e.samplingfrequencyindex << 7 | e.channelcount << 3, 6, 1, 2])) }, g = function (e) { return i(w.hdlr, x[e]) }, f = function (e) { var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, e.duration >>> 24 & 255, e.duration >>> 16 & 255, e.duration >>> 8 & 255, 255 & e.duration, 85, 196, 0, 0]); return e.samplerate && (t[12] = e.samplerate >>> 24 & 255, t[13] = e.samplerate >>> 16 & 255, t[14] = e.samplerate >>> 8 & 255, t[15] = 255 & e.samplerate), i(w.mdhd, t) }, m = function (e) { return i(w.mdia, f(e), g(e.type), o(e)) }, r = function (e) { return i(w.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e])) }, o = function (e) { return i(w.minf, "video" === e.type ? i(w.vmhd, k) : i(w.smhd, O), n(), _(e)) }, d = function (e, t) { for (var n = [], s = t.length; s--;)n[s] = b(t[s]); return i.apply(null, [w.moof, r(e)].concat(n)) }, u = function (e) { for (var t = e.length, n = []; t--;)n[t] = c(e[t]); return i.apply(null, [w.moov, h(4294967295)].concat(n).concat(l(e))) }, l = function (e) { for (var t = e.length, n = []; t--;)n[t] = S(e[t]); return i.apply(null, [w.mvex].concat(n)) }, h = function (e) { var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return i(w.mvhd, t) }, y = function (e) { var t, n, s = e.samples || [], a = new Uint8Array(4 + s.length); for (n = 0; n < s.length; n++)t = s[n].flags, a[n + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy; return i(w.sdtp, a) }, _ = function (e) { return i(w.stbl, T(e), i(w.stts, M), i(w.stsc, U), i(w.stsz, R), i(w.stco, C)) }, T = function (e) { return i(w.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), "video" === e.type ? B(e) : N(e)) }, B = function (e) { var t, n, s = e.sps || [], a = e.pps || [], r = [], o = []; for (t = 0; t < s.length; t++)r.push((65280 & s[t].byteLength) >>> 8), r.push(255 & s[t].byteLength), r = r.concat(Array.prototype.slice.call(s[t])); for (t = 0; t < a.length; t++)o.push((65280 & a[t].byteLength) >>> 8), o.push(255 & a[t].byteLength), o = o.concat(Array.prototype.slice.call(a[t])); if (n = [w.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, (65280 & e.height) >> 8, 255 & e.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), i(w.avcC, new Uint8Array([1, e.profileIdc, e.profileCompatibility, e.levelIdc, 255].concat([s.length], r, [a.length], o))), i(w.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))], e.sarRatio) { var d = e.sarRatio[0], u = e.sarRatio[1]; n.push(i(w.pasp, new Uint8Array([(4278190080 & d) >> 24, (16711680 & d) >> 16, (65280 & d) >> 8, 255 & d, (4278190080 & u) >> 24, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u]))) } return i.apply(null, n) }, N = function (e) { return i(w.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.channelcount) >> 8, 255 & e.channelcount, (65280 & e.samplesize) >> 8, 255 & e.samplesize, 0, 0, 0, 0, (65280 & e.samplerate) >> 8, 255 & e.samplerate, 0, 0]), s(e)) }, p = function (e) { var t = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 0, (4278190080 & e.duration) >> 24, (16711680 & e.duration) >> 16, (65280 & e.duration) >> 8, 255 & e.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, 0, 0, (65280 & e.height) >> 8, 255 & e.height, 0, 0]); return i(w.tkhd, t) }, b = function (e) { var t, n, s, a, r, o; return t = i(w.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), r = Math.floor(e.baseMediaDecodeTime / H), o = Math.floor(e.baseMediaDecodeTime % H), n = i(w.tfdt, new Uint8Array([1, 0, 0, 0, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o])), "audio" === e.type ? (s = v(e, 92), i(w.traf, t, n, s)) : (a = y(e), s = v(e, a.length + 92), i(w.traf, t, n, s, a)) }, c = function (e) { return e.duration = e.duration || 4294967295, i(w.trak, p(e), m(e)) }, S = function (e) { var t = new Uint8Array([0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]); return "video" !== e.type && (t[t.length - 1] = 0), i(w.trex, t) }, q = function (e, t) { var i = 0, n = 0, s = 0, a = 0; return e.length && (void 0 !== e[0].duration && (i = 1), void 0 !== e[0].size && (n = 2), void 0 !== e[0].flags && (s = 4), void 0 !== e[0].compositionTimeOffset && (a = 8)), [0, 0, i | n | s | a, 1, (4278190080 & e.length) >>> 24, (16711680 & e.length) >>> 16, (65280 & e.length) >>> 8, 255 & e.length, (4278190080 & t) >>> 24, (16711680 & t) >>> 16, (65280 & t) >>> 8, 255 & t] }, $ = function (e, t) { var n, s, a, r, o, d; for (t += 20 + 16 * (r = e.samples || []).length, a = q(r, t), (s = new Uint8Array(a.length + 16 * r.length)).set(a), n = a.length, d = 0; d < r.length; d++)o = r[d], s[n++] = (4278190080 & o.duration) >>> 24, s[n++] = (16711680 & o.duration) >>> 16, s[n++] = (65280 & o.duration) >>> 8, s[n++] = 255 & o.duration, s[n++] = (4278190080 & o.size) >>> 24, s[n++] = (16711680 & o.size) >>> 16, s[n++] = (65280 & o.size) >>> 8, s[n++] = 255 & o.size, s[n++] = o.flags.isLeading << 2 | o.flags.dependsOn, s[n++] = o.flags.isDependedOn << 6 | o.flags.hasRedundancy << 4 | o.flags.paddingValue << 1 | o.flags.isNonSyncSample, s[n++] = 61440 & o.flags.degradationPriority, s[n++] = 15 & o.flags.degradationPriority, s[n++] = (4278190080 & o.compositionTimeOffset) >>> 24, s[n++] = (16711680 & o.compositionTimeOffset) >>> 16, s[n++] = (65280 & o.compositionTimeOffset) >>> 8, s[n++] = 255 & o.compositionTimeOffset; return i(w.trun, s) }, F = function (e, t) { var n, s, a, r, o, d; for (t += 20 + 8 * (r = e.samples || []).length, a = q(r, t), (n = new Uint8Array(a.length + 8 * r.length)).set(a), s = a.length, d = 0; d < r.length; d++)o = r[d], n[s++] = (4278190080 & o.duration) >>> 24, n[s++] = (16711680 & o.duration) >>> 16, n[s++] = (65280 & o.duration) >>> 8, n[s++] = 255 & o.duration, n[s++] = (4278190080 & o.size) >>> 24, n[s++] = (16711680 & o.size) >>> 16, n[s++] = (65280 & o.size) >>> 8, n[s++] = 255 & o.size; return i(w.trun, n) }, v = function (e, t) { return "audio" === e.type ? F(e, t) : $(e, t) }; var X, j, z, Y, Q, K, J, Z, ee = { ftyp: a = function () { return i(w.ftyp, I, E, I, A) }, mdat: function (e) { return i(w.mdat, e) }, moof: d, moov: u, initSegment: function (e) { var t, i = a(), n = u(e); return (t = new Uint8Array(i.byteLength + n.byteLength)).set(i), t.set(n, i.byteLength), t } }, te = function (e, t) { var i = { size: 0, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0, degradationPriority: 0, isNonSyncSample: 1 } }; return i.dataOffset = t, i.compositionTimeOffset = e.pts - e.dts, i.duration = e.duration, i.size = 4 * e.length, i.size += e.byteLength, e.keyFrame && (i.flags.dependsOn = 2, i.flags.isNonSyncSample = 0), i }, ie = { groupNalsIntoFrames: function (e) { var t, i, n = [], s = []; for (s.byteLength = 0, s.nalCount = 0, s.duration = 0, n.byteLength = 0, t = 0; t < e.length; t++)"access_unit_delimiter_rbsp" === (i = e[t]).nalUnitType ? (n.length && (n.duration = i.dts - n.dts, s.byteLength += n.byteLength, s.nalCount += n.length, s.duration += n.duration, s.push(n)), (n = [i]).byteLength = i.data.byteLength, n.pts = i.pts, n.dts = i.dts) : ("slice_layer_without_partitioning_rbsp_idr" === i.nalUnitType && (n.keyFrame = !0), n.duration = i.dts - n.dts, n.byteLength += i.data.byteLength, n.push(i)); return s.length && (!n.duration || n.duration <= 0) && (n.duration = s[s.length - 1].duration), s.byteLength += n.byteLength, s.nalCount += n.length, s.duration += n.duration, s.push(n), s }, groupFramesIntoGops: function (e) { var t, i, n = [], s = []; for (n.byteLength = 0, n.nalCount = 0, n.duration = 0, n.pts = e[0].pts, n.dts = e[0].dts, s.byteLength = 0, s.nalCount = 0, s.duration = 0, s.pts = e[0].pts, s.dts = e[0].dts, t = 0; t < e.length; t++)(i = e[t]).keyFrame ? (n.length && (s.push(n), s.byteLength += n.byteLength, s.nalCount += n.nalCount, s.duration += n.duration), (n = [i]).nalCount = i.length, n.byteLength = i.byteLength, n.pts = i.pts, n.dts = i.dts, n.duration = i.duration) : (n.duration += i.duration, n.nalCount += i.length, n.byteLength += i.byteLength, n.push(i)); return s.length && n.duration <= 0 && (n.duration = s[s.length - 1].duration), s.byteLength += n.byteLength, s.nalCount += n.nalCount, s.duration += n.duration, s.push(n), s }, extendFirstKeyFrame: function (e) { var t; return !e[0][0].keyFrame && e.length > 1 && (t = e.shift(), e.byteLength -= t.byteLength, e.nalCount -= t.nalCount, e[0][0].dts = t.dts, e[0][0].pts = t.pts, e[0][0].duration += t.duration), e }, generateSampleTable: function (e, t) { var i, n, s, a, r, o = t || 0, d = []; for (i = 0; i < e.length; i++)for (a = e[i], n = 0; n < a.length; n++)r = a[n], o += (s = te(r, o)).size, d.push(s); return d }, concatenateNalData: function (e) { var t, i, n, s, a, r, o = 0, d = e.byteLength, u = e.nalCount, l = new Uint8Array(d + 4 * u), h = new DataView(l.buffer); for (t = 0; t < e.length; t++)for (s = e[t], i = 0; i < s.length; i++)for (a = s[i], n = 0; n < a.length; n++)r = a[n], h.setUint32(o, r.data.byteLength), o += 4, l.set(r.data, o), o += r.data.byteLength; return l }, generateSampleTableForFrame: function (e, t) { var i, n = []; return i = te(e, t || 0), n.push(i), n }, concatenateNalDataForFrame: function (e) { var t, i, n = 0, s = e.byteLength, a = e.length, r = new Uint8Array(s + 4 * a), o = new DataView(r.buffer); for (t = 0; t < e.length; t++)i = e[t], o.setUint32(n, i.data.byteLength), n += 4, r.set(i.data, n), n += i.data.byteLength; return r } }, ne = [33, 16, 5, 32, 164, 27], se = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], ae = function (e) { for (var t = []; e--;)t.push(0); return t }, re = 9e4; K = function (e, t) { return j(Q(e, t)) }, J = function (e, t) { return z(Y(e), t) }, Z = function (e, t, i) { return Y(i ? e : e - t) }; var oe = { ONE_SECOND_IN_TS: re, secondsToVideoTs: j = function (e) { return e * re }, secondsToAudioTs: z = function (e, t) { return e * t }, videoTsToSeconds: Y = function (e) { return e / re }, audioTsToSeconds: Q = function (e, t) { return e / t }, audioTsToVideoTs: K, videoTsToAudioTs: J, metadataTsToSeconds: Z }, de = oe, ue = { prefixWithSilence: function (e, t, i, n) { var s, a, r, o, d, u = 0, l = 0, h = 0; if (t.length && (s = de.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), a = Math.ceil(de.ONE_SECOND_IN_TS / (e.samplerate / 1024)), i && n && (u = s - Math.max(i, n), h = (l = Math.floor(u / a)) * a), !(l < 1 || h > de.ONE_SECOND_IN_TS / 2))) { for ((r = function () { if (!X) { var e = { 96e3: [ne, [227, 64], ae(154), [56]], 88200: [ne, [231], ae(170), [56]], 64e3: [ne, [248, 192], ae(240), [56]], 48e3: [ne, [255, 192], ae(268), [55, 148, 128], ae(54), [112]], 44100: [ne, [255, 192], ae(268), [55, 163, 128], ae(84), [112]], 32e3: [ne, [255, 192], ae(268), [55, 234], ae(226), [112]], 24e3: [ne, [255, 192], ae(268), [55, 255, 128], ae(268), [111, 112], ae(126), [224]], 16e3: [ne, [255, 192], ae(268), [55, 255, 128], ae(268), [111, 255], ae(269), [223, 108], ae(195), [1, 192]], 12e3: [se, ae(268), [3, 127, 248], ae(268), [6, 255, 240], ae(268), [13, 255, 224], ae(268), [27, 253, 128], ae(259), [56]], 11025: [se, ae(268), [3, 127, 248], ae(268), [6, 255, 240], ae(268), [13, 255, 224], ae(268), [27, 255, 192], ae(268), [55, 175, 128], ae(108), [112]], 8e3: [se, ae(268), [3, 121, 16], ae(47), [7]] }; t = e, X = Object.keys(t).reduce((function (e, i) { return e[i] = new Uint8Array(t[i].reduce((function (e, t) { return e.concat(t) }), [])), e }), {}) } var t; return X }()[e.samplerate]) || (r = t[0].data), o = 0; o < l; o++)d = t[0], t.splice(0, 0, { data: r, dts: d.dts - a, pts: d.pts - a }); return e.baseMediaDecodeTime -= Math.floor(de.videoTsToAudioTs(h, e.samplerate)), h } }, trimAdtsFramesByEarliestDts: function (e, t, i) { return t.minSegmentDts >= i ? e : (t.minSegmentDts = 1 / 0, e.filter((function (e) { return e.dts >= i && (t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), t.minSegmentPts = t.minSegmentDts, !0) }))) }, generateSampleTable: function (e) { var t, i, n = []; for (t = 0; t < e.length; t++)i = e[t], n.push({ size: i.data.byteLength, duration: 1024 }); return n }, concatenateFrameData: function (e) { var t, i, n = 0, s = new Uint8Array(function (e) { var t, i = 0; for (t = 0; t < e.length; t++)i += e[t].data.byteLength; return i }(e)); for (t = 0; t < e.length; t++)i = e[t], s.set(i.data, n), n += i.data.byteLength; return s } }, le = oe.ONE_SECOND_IN_TS, he = { clearDtsInfo: function (e) { delete e.minSegmentDts, delete e.maxSegmentDts, delete e.minSegmentPts, delete e.maxSegmentPts }, calculateTrackBaseMediaDecodeTime: function (e, t) { var i, n = e.minSegmentDts; return t || (n -= e.timelineStartInfo.dts), i = e.timelineStartInfo.baseMediaDecodeTime, i += n, i = Math.max(0, i), "audio" === e.type && (i *= e.samplerate / le, i = Math.floor(i)), i }, collectDtsInfo: function (e, t) { "number" == typeof t.pts && (void 0 === e.timelineStartInfo.pts && (e.timelineStartInfo.pts = t.pts), void 0 === e.minSegmentPts ? e.minSegmentPts = t.pts : e.minSegmentPts = Math.min(e.minSegmentPts, t.pts), void 0 === e.maxSegmentPts ? e.maxSegmentPts = t.pts : e.maxSegmentPts = Math.max(e.maxSegmentPts, t.pts)), "number" == typeof t.dts && (void 0 === e.timelineStartInfo.dts && (e.timelineStartInfo.dts = t.dts), void 0 === e.minSegmentDts ? e.minSegmentDts = t.dts : e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), void 0 === e.maxSegmentDts ? e.maxSegmentDts = t.dts : e.maxSegmentDts = Math.max(e.maxSegmentDts, t.dts)) } }, ce = { parseSei: function (e) { for (var t = 0, i = { payloadType: -1, payloadSize: 0 }, n = 0, s = 0; t < e.byteLength && 128 !== e[t];) { for (; 255 === e[t];)n += 255, t++; for (n += e[t++]; 255 === e[t];)s += 255, t++; if (s += e[t++], !i.payload && 4 === n) { if ("GA94" === String.fromCharCode(e[t + 3], e[t + 4], e[t + 5], e[t + 6])) { i.payloadType = n, i.payloadSize = s, i.payload = e.subarray(t, t + s); break } i.payload = void 0 } t += s, n = 0, s = 0 } return i }, parseUserData: function (e) { return 181 !== e.payload[0] || 49 != (e.payload[1] << 8 | e.payload[2]) || "GA94" !== String.fromCharCode(e.payload[3], e.payload[4], e.payload[5], e.payload[6]) || 3 !== e.payload[7] ? null : e.payload.subarray(8, e.payload.length - 1) }, parseCaptionPackets: function (e, t) { var i, n, s, a, r = []; if (!(64 & t[0])) return r; for (n = 31 & t[0], i = 0; i < n; i++)a = { type: 3 & t[2 + (s = 3 * i)], pts: e }, 4 & t[s + 2] && (a.ccData = t[s + 3] << 8 | t[s + 4], r.push(a)); return r }, discardEmulationPreventionBytes: function (e) { for (var t, i, n = e.byteLength, s = [], a = 1; a < n - 2;)0 === e[a] && 0 === e[a + 1] && 3 === e[a + 2] ? (s.push(a + 2), a += 2) : a++; if (0 === s.length) return e; t = n - s.length, i = new Uint8Array(t); var r = 0; for (a = 0; a < t; r++, a++)r === s[0] && (r++, s.shift()), i[a] = e[r]; return i }, USER_DATA_REGISTERED_ITU_T_T35: 4 }, pe = G, me = ce, fe = function (e) { e = e || {}, fe.prototype.init.call(this), this.parse708captions_ = "boolean" != typeof e.parse708captions || e.parse708captions, this.captionPackets_ = [], this.ccStreams_ = [new Ee(0, 0), new Ee(0, 1), new Ee(1, 0), new Ee(1, 1)], this.parse708captions_ && (this.cc708Stream_ = new be({ captionServices: e.captionServices })), this.reset(), this.ccStreams_.forEach((function (e) { e.on("data", this.trigger.bind(this, "data")), e.on("partialdone", this.trigger.bind(this, "partialdone")), e.on("done", this.trigger.bind(this, "done")) }), this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done"))) }; fe.prototype = new pe, fe.prototype.push = function (e) { var t, i, n; if ("sei_rbsp" === e.nalUnitType && (t = me.parseSei(e.escapedRBSP)).payload && t.payloadType === me.USER_DATA_REGISTERED_ITU_T_T35 && (i = me.parseUserData(t))) if (e.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0; else { if (e.dts === this.latestDts_ && this.ignoreNextEqualDts_) return this.numSameDts_--, void (this.numSameDts_ || (this.ignoreNextEqualDts_ = !1)); n = me.parseCaptionPackets(e.pts, i), this.captionPackets_ = this.captionPackets_.concat(n), this.latestDts_ !== e.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = e.dts } }, fe.prototype.flushCCStreams = function (e) { this.ccStreams_.forEach((function (t) { return "flush" === e ? t.flush() : t.partialFlush() }), this) }, fe.prototype.flushStream = function (e) { this.captionPackets_.length ? (this.captionPackets_.forEach((function (e, t) { e.presortIndex = t })), this.captionPackets_.sort((function (e, t) { return e.pts === t.pts ? e.presortIndex - t.presortIndex : e.pts - t.pts })), this.captionPackets_.forEach((function (e) { e.type < 2 ? this.dispatchCea608Packet(e) : this.dispatchCea708Packet(e) }), this), this.captionPackets_.length = 0, this.flushCCStreams(e)) : this.flushCCStreams(e) }, fe.prototype.flush = function () { return this.flushStream("flush") }, fe.prototype.partialFlush = function () { return this.flushStream("partialFlush") }, fe.prototype.reset = function () { this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach((function (e) { e.reset() })) }, fe.prototype.dispatchCea608Packet = function (e) { this.setsTextOrXDSActive(e) ? this.activeCea608Channel_[e.type] = null : this.setsChannel1Active(e) ? this.activeCea608Channel_[e.type] = 0 : this.setsChannel2Active(e) && (this.activeCea608Channel_[e.type] = 1), null !== this.activeCea608Channel_[e.type] && this.ccStreams_[(e.type << 1) + this.activeCea608Channel_[e.type]].push(e) }, fe.prototype.setsChannel1Active = function (e) { return 4096 == (30720 & e.ccData) }, fe.prototype.setsChannel2Active = function (e) { return 6144 == (30720 & e.ccData) }, fe.prototype.setsTextOrXDSActive = function (e) { return 256 == (28928 & e.ccData) || 4138 == (30974 & e.ccData) || 6186 == (30974 & e.ccData) }, fe.prototype.dispatchCea708Packet = function (e) { this.parse708captions_ && this.cc708Stream_.push(e) }; var ge = { 127: 9834, 4128: 32, 4129: 160, 4133: 8230, 4138: 352, 4140: 338, 4144: 9608, 4145: 8216, 4146: 8217, 4147: 8220, 4148: 8221, 4149: 8226, 4153: 8482, 4154: 353, 4156: 339, 4157: 8480, 4159: 376, 4214: 8539, 4215: 8540, 4216: 8541, 4217: 8542, 4218: 9168, 4219: 9124, 4220: 9123, 4221: 9135, 4222: 9126, 4223: 9121, 4256: 12600 }, ye = function (e) { return 32 <= e && e <= 127 || 160 <= e && e <= 255 }, _e = function (e) { this.windowNum = e, this.reset() }; _e.prototype.reset = function () { this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0 }, _e.prototype.getText = function () { return this.rows.join("\n") }, _e.prototype.clearText = function () { this.rows = [""], this.rowIdx = 0 }, _e.prototype.newLine = function (e) { for (this.rows.length >= this.virtualRowCount && "function" == typeof this.beforeRowOverflow && this.beforeRowOverflow(e), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount;)this.rows.shift(), this.rowIdx-- }, _e.prototype.isEmpty = function () { return 0 === this.rows.length || 1 === this.rows.length && "" === this.rows[0] }, _e.prototype.addText = function (e) { this.rows[this.rowIdx] += e }, _e.prototype.backspace = function () { if (!this.isEmpty()) { var e = this.rows[this.rowIdx]; this.rows[this.rowIdx] = e.substr(0, e.length - 1) } }; var Te = function (e, t, i) { this.serviceNum = e, this.text = "", this.currentWindow = new _e(-1), this.windows = [], this.stream = i, "string" == typeof t && this.createTextDecoder(t) }; Te.prototype.init = function (e, t) { this.startPts = e; for (var i = 0; i < 8; i++)this.windows[i] = new _e(i), "function" == typeof t && (this.windows[i].beforeRowOverflow = t) }, Te.prototype.setCurrentWindow = function (e) { this.currentWindow = this.windows[e] }, Te.prototype.createTextDecoder = function (e) { if ("undefined" == typeof TextDecoder) this.stream.trigger("log", { level: "warn", message: "The `encoding` option is unsupported without TextDecoder support" }); else try { this.textDecoder_ = new TextDecoder(e) } catch (t) { this.stream.trigger("log", { level: "warn", message: "TextDecoder could not be created with " + e + " encoding. " + t }) } }; var be = function (e) { e = e || {}, be.prototype.init.call(this); var t, i = this, n = e.captionServices || {}, s = {}; Object.keys(n).forEach((e => { t = n[e], /^SERVICE/.test(e) && (s[e] = t.encoding) })), this.serviceEncodings = s, this.current708Packet = null, this.services = {}, this.push = function (e) { 3 === e.type ? (i.new708Packet(), i.add708Bytes(e)) : (null === i.current708Packet && i.new708Packet(), i.add708Bytes(e)) } }; be.prototype = new pe, be.prototype.new708Packet = function () { null !== this.current708Packet && this.push708Packet(), this.current708Packet = { data: [], ptsVals: [] } }, be.prototype.add708Bytes = function (e) { var t = e.ccData, i = t >>> 8, n = 255 & t; this.current708Packet.ptsVals.push(e.pts), this.current708Packet.data.push(i), this.current708Packet.data.push(n) }, be.prototype.push708Packet = function () { var e = this.current708Packet, t = e.data, i = null, n = null, s = 0, a = t[s++]; for (e.seq = a >> 6, e.sizeCode = 63 & a; s < t.length; s++)n = 31 & (a = t[s++]), 7 == (i = a >> 5) && n > 0 && (i = a = t[s++]), this.pushServiceBlock(i, s, n), n > 0 && (s += n - 1) }, be.prototype.pushServiceBlock = function (e, t, i) { var n, s = t, a = this.current708Packet.data, r = this.services[e]; for (r || (r = this.initService(e, s)); s < t + i && s < a.length; s++)n = a[s], ye(n) ? s = this.handleText(s, r) : 24 === n ? s = this.multiByteCharacter(s, r) : 16 === n ? s = this.extendedCommands(s, r) : 128 <= n && n <= 135 ? s = this.setCurrentWindow(s, r) : 152 <= n && n <= 159 ? s = this.defineWindow(s, r) : 136 === n ? s = this.clearWindows(s, r) : 140 === n ? s = this.deleteWindows(s, r) : 137 === n ? s = this.displayWindows(s, r) : 138 === n ? s = this.hideWindows(s, r) : 139 === n ? s = this.toggleWindows(s, r) : 151 === n ? s = this.setWindowAttributes(s, r) : 144 === n ? s = this.setPenAttributes(s, r) : 145 === n ? s = this.setPenColor(s, r) : 146 === n ? s = this.setPenLocation(s, r) : 143 === n ? r = this.reset(s, r) : 8 === n ? r.currentWindow.backspace() : 12 === n ? r.currentWindow.clearText() : 13 === n ? r.currentWindow.pendingNewLine = !0 : 14 === n ? r.currentWindow.clearText() : 141 === n && s++ }, be.prototype.extendedCommands = function (e, t) { var i = this.current708Packet.data[++e]; return ye(i) && (e = this.handleText(e, t, { isExtended: !0 })), e }, be.prototype.getPts = function (e) { return this.current708Packet.ptsVals[Math.floor(e / 2)] }, be.prototype.initService = function (e, t) { var i, n, s = this; return (i = "SERVICE" + e) in this.serviceEncodings && (n = this.serviceEncodings[i]), this.services[e] = new Te(e, n, s), this.services[e].init(this.getPts(t), (function (t) { s.flushDisplayed(t, s.services[e]) })), this.services[e] }, be.prototype.handleText = function (e, t, i) { var n, s, a, r, o = i && i.isExtended, d = i && i.isMultiByte, u = this.current708Packet.data, l = o ? 4096 : 0, h = u[e], c = u[e + 1], p = t.currentWindow; return t.textDecoder_ && !o ? (d ? (s = [h, c], e++) : s = [h], n = t.textDecoder_.decode(new Uint8Array(s))) : (r = ge[a = l | h] || a, n = 4096 & a && a === r ? "" : String.fromCharCode(r)), p.pendingNewLine && !p.isEmpty() && p.newLine(this.getPts(e)), p.pendingNewLine = !1, p.addText(n), e }, be.prototype.multiByteCharacter = function (e, t) { var i = this.current708Packet.data, n = i[e + 1], s = i[e + 2]; return ye(n) && ye(s) && (e = this.handleText(++e, t, { isMultiByte: !0 })), e }, be.prototype.setCurrentWindow = function (e, t) { var i = 7 & this.current708Packet.data[e]; return t.setCurrentWindow(i), e }, be.prototype.defineWindow = function (e, t) { var i = this.current708Packet.data, n = i[e], s = 7 & n; t.setCurrentWindow(s); var a = t.currentWindow; return n = i[++e], a.visible = (32 & n) >> 5, a.rowLock = (16 & n) >> 4, a.columnLock = (8 & n) >> 3, a.priority = 7 & n, n = i[++e], a.relativePositioning = (128 & n) >> 7, a.anchorVertical = 127 & n, n = i[++e], a.anchorHorizontal = n, n = i[++e], a.anchorPoint = (240 & n) >> 4, a.rowCount = 15 & n, n = i[++e], a.columnCount = 63 & n, n = i[++e], a.windowStyle = (56 & n) >> 3, a.penStyle = 7 & n, a.virtualRowCount = a.rowCount + 1, e }, be.prototype.setWindowAttributes = function (e, t) { var i = this.current708Packet.data, n = i[e], s = t.currentWindow.winAttr; return n = i[++e], s.fillOpacity = (192 & n) >> 6, s.fillRed = (48 & n) >> 4, s.fillGreen = (12 & n) >> 2, s.fillBlue = 3 & n, n = i[++e], s.borderType = (192 & n) >> 6, s.borderRed = (48 & n) >> 4, s.borderGreen = (12 & n) >> 2, s.borderBlue = 3 & n, n = i[++e], s.borderType += (128 & n) >> 5, s.wordWrap = (64 & n) >> 6, s.printDirection = (48 & n) >> 4, s.scrollDirection = (12 & n) >> 2, s.justify = 3 & n, n = i[++e], s.effectSpeed = (240 & n) >> 4, s.effectDirection = (12 & n) >> 2, s.displayEffect = 3 & n, e }, be.prototype.flushDisplayed = function (e, t) { for (var i = [], n = 0; n < 8; n++)t.windows[n].visible && !t.windows[n].isEmpty() && i.push(t.windows[n].getText()); t.endPts = e, t.text = i.join("\n\n"), this.pushCaption(t), t.startPts = e }, be.prototype.pushCaption = function (e) { "" !== e.text && (this.trigger("data", { startPts: e.startPts, endPts: e.endPts, text: e.text, stream: "cc708_" + e.serviceNum }), e.text = "", e.startPts = e.endPts) }, be.prototype.displayWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var s = 0; s < 8; s++)i & 1 << s && (t.windows[s].visible = 1); return e }, be.prototype.hideWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var s = 0; s < 8; s++)i & 1 << s && (t.windows[s].visible = 0); return e }, be.prototype.toggleWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var s = 0; s < 8; s++)i & 1 << s && (t.windows[s].visible ^= 1); return e }, be.prototype.clearWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var s = 0; s < 8; s++)i & 1 << s && t.windows[s].clearText(); return e }, be.prototype.deleteWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var s = 0; s < 8; s++)i & 1 << s && t.windows[s].reset(); return e }, be.prototype.setPenAttributes = function (e, t) { var i = this.current708Packet.data, n = i[e], s = t.currentWindow.penAttr; return n = i[++e], s.textTag = (240 & n) >> 4, s.offset = (12 & n) >> 2, s.penSize = 3 & n, n = i[++e], s.italics = (128 & n) >> 7, s.underline = (64 & n) >> 6, s.edgeType = (56 & n) >> 3, s.fontStyle = 7 & n, e }, be.prototype.setPenColor = function (e, t) { var i = this.current708Packet.data, n = i[e], s = t.currentWindow.penColor; return n = i[++e], s.fgOpacity = (192 & n) >> 6, s.fgRed = (48 & n) >> 4, s.fgGreen = (12 & n) >> 2, s.fgBlue = 3 & n, n = i[++e], s.bgOpacity = (192 & n) >> 6, s.bgRed = (48 & n) >> 4, s.bgGreen = (12 & n) >> 2, s.bgBlue = 3 & n, n = i[++e], s.edgeRed = (48 & n) >> 4, s.edgeGreen = (12 & n) >> 2, s.edgeBlue = 3 & n, e }, be.prototype.setPenLocation = function (e, t) { var i = this.current708Packet.data, n = i[e], s = t.currentWindow.penLoc; return t.currentWindow.pendingNewLine = !0, n = i[++e], s.row = 15 & n, n = i[++e], s.column = 63 & n, e }, be.prototype.reset = function (e, t) { var i = this.getPts(e); return this.flushDisplayed(i, t), this.initService(t.serviceNum, e) }; var Se = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 304: 174, 305: 176, 306: 189, 307: 191, 308: 8482, 309: 162, 310: 163, 311: 9834, 312: 224, 313: 160, 314: 232, 315: 226, 316: 234, 317: 238, 318: 244, 319: 251, 544: 193, 545: 201, 546: 211, 547: 218, 548: 220, 549: 252, 550: 8216, 551: 161, 552: 42, 553: 39, 554: 8212, 555: 169, 556: 8480, 557: 8226, 558: 8220, 559: 8221, 560: 192, 561: 194, 562: 199, 563: 200, 564: 202, 565: 203, 566: 235, 567: 206, 568: 207, 569: 239, 570: 212, 571: 217, 572: 249, 573: 219, 574: 171, 575: 187, 800: 195, 801: 227, 802: 205, 803: 204, 804: 236, 805: 210, 806: 242, 807: 213, 808: 245, 809: 123, 810: 125, 811: 92, 812: 94, 813: 95, 814: 124, 815: 126, 816: 196, 817: 228, 818: 214, 819: 246, 820: 223, 821: 165, 822: 164, 823: 9474, 824: 197, 825: 229, 826: 216, 827: 248, 828: 9484, 829: 9488, 830: 9492, 831: 9496 }, ve = function (e) { return null === e ? "" : (e = Se[e] || e, String.fromCharCode(e)) }, we = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152], Ie = function () { for (var e = [], t = 15; t--;)e.push(""); return e }, Ee = function (e, t) { Ee.prototype.init.call(this), this.field_ = e || 0, this.dataChannel_ = t || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function (e) { var t, i, n, s, a; if ((t = 32639 & e.ccData) !== this.lastControlCode_) { if (4096 == (61440 & t) ? this.lastControlCode_ = t : t !== this.PADDING_ && (this.lastControlCode_ = null), n = t >>> 8, s = 255 & t, t !== this.PADDING_) if (t === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn"; else if (t === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(e.pts), this.flushDisplayed(e.pts), i = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = i, this.startPts_ = e.pts; else if (t === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(e.pts); else if (t === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(e.pts); else if (t === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(e.pts); else if (t === this.CARRIAGE_RETURN_) this.clearFormatting(e.pts), this.flushDisplayed(e.pts), this.shiftRowsUp_(), this.startPts_ = e.pts; else if (t === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1); else if (t === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(e.pts), this.displayed_ = Ie(); else if (t === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = Ie(); else if (t === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(e.pts), this.displayed_ = Ie()), this.mode_ = "paintOn", this.startPts_ = e.pts; else if (this.isSpecialCharacter(n, s)) a = ve((n = (3 & n) << 8) | s), this[this.mode_](e.pts, a), this.column_++; else if (this.isExtCharacter(n, s)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), a = ve((n = (3 & n) << 8) | s), this[this.mode_](e.pts, a), this.column_++; else if (this.isMidRowCode(n, s)) this.clearFormatting(e.pts), this[this.mode_](e.pts, " "), this.column_++, 14 == (14 & s) && this.addFormatting(e.pts, ["i"]), 1 == (1 & s) && this.addFormatting(e.pts, ["u"]); else if (this.isOffsetControlCode(n, s)) this.column_ += 3 & s; else if (this.isPAC(n, s)) { var r = we.indexOf(7968 & t); "rollUp" === this.mode_ && (r - this.rollUpRows_ + 1 < 0 && (r = this.rollUpRows_ - 1), this.setRollUp(e.pts, r)), r !== this.row_ && (this.clearFormatting(e.pts), this.row_ = r), 1 & s && -1 === this.formatting_.indexOf("u") && this.addFormatting(e.pts, ["u"]), 16 == (16 & t) && (this.column_ = 4 * ((14 & t) >> 1)), this.isColorPAC(s) && 14 == (14 & s) && this.addFormatting(e.pts, ["i"]) } else this.isNormalChar(n) && (0 === s && (s = null), a = ve(n), a += ve(s), this[this.mode_](e.pts, a), this.column_ += a.length) } else this.lastControlCode_ = null } }; Ee.prototype = new pe, Ee.prototype.flushDisplayed = function (e) { var t = this.displayed_.map((function (e, t) { try { return e.trim() } catch (e) { return this.trigger("log", { level: "warn", message: "Skipping a malformed 608 caption at index " + t + "." }), "" } }), this).join("\n").replace(/^\n+|\n+$/g, ""); t.length && this.trigger("data", { startPts: this.startPts_, endPts: e, text: t, stream: this.name_ }) }, Ee.prototype.reset = function () { this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Ie(), this.nonDisplayed_ = Ie(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = [] }, Ee.prototype.setConstants = function () { 0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_ }, Ee.prototype.isSpecialCharacter = function (e, t) { return e === this.EXT_ && t >= 48 && t <= 63 }, Ee.prototype.isExtCharacter = function (e, t) { return (e === this.EXT_ + 1 || e === this.EXT_ + 2) && t >= 32 && t <= 63 }, Ee.prototype.isMidRowCode = function (e, t) { return e === this.EXT_ && t >= 32 && t <= 47 }, Ee.prototype.isOffsetControlCode = function (e, t) { return e === this.OFFSET_ && t >= 33 && t <= 35 }, Ee.prototype.isPAC = function (e, t) { return e >= this.BASE_ && e < this.BASE_ + 8 && t >= 64 && t <= 127 }, Ee.prototype.isColorPAC = function (e) { return e >= 64 && e <= 79 || e >= 96 && e <= 127 }, Ee.prototype.isNormalChar = function (e) { return e >= 32 && e <= 127 }, Ee.prototype.setRollUp = function (e, t) { if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(e), this.nonDisplayed_ = Ie(), this.displayed_ = Ie()), void 0 !== t && t !== this.row_) for (var i = 0; i < this.rollUpRows_; i++)this.displayed_[t - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = ""; void 0 === t && (t = this.row_), this.topRow_ = t - this.rollUpRows_ + 1 }, Ee.prototype.addFormatting = function (e, t) { this.formatting_ = this.formatting_.concat(t); var i = t.reduce((function (e, t) { return e + "<" + t + ">" }), ""); this[this.mode_](e, i) }, Ee.prototype.clearFormatting = function (e) { if (this.formatting_.length) { var t = this.formatting_.reverse().reduce((function (e, t) { return e + "</" + t + ">" }), ""); this.formatting_ = [], this[this.mode_](e, t) } }, Ee.prototype.popOn = function (e, t) { var i = this.nonDisplayed_[this.row_]; i += t, this.nonDisplayed_[this.row_] = i }, Ee.prototype.rollUp = function (e, t) { var i = this.displayed_[this.row_]; i += t, this.displayed_[this.row_] = i }, Ee.prototype.shiftRowsUp_ = function () { var e; for (e = 0; e < this.topRow_; e++)this.displayed_[e] = ""; for (e = this.row_ + 1; e < 15; e++)this.displayed_[e] = ""; for (e = this.topRow_; e < this.row_; e++)this.displayed_[e] = this.displayed_[e + 1]; this.displayed_[this.row_] = "" }, Ee.prototype.paintOn = function (e, t) { var i = this.displayed_[this.row_]; i += t, this.displayed_[this.row_] = i }; var Ae = { CaptionStream: fe, Cea608Stream: Ee, Cea708Stream: be }, Le = { H264_STREAM_TYPE: 27, ADTS_STREAM_TYPE: 15, METADATA_STREAM_TYPE: 21 }, De = G, xe = "shared", ke = function (e, t) { var i = 1; for (e > t && (i = -1); Math.abs(t - e) > 4294967296;)e += 8589934592 * i; return e }, Oe = function (e) { var t, i; Oe.prototype.init.call(this), this.type_ = e || xe, this.push = function (e) { this.type_ !== xe && e.type !== this.type_ || (void 0 === i && (i = e.dts), e.dts = ke(e.dts, i), e.pts = ke(e.pts, i), t = e.dts, this.trigger("data", e)) }, this.flush = function () { i = t, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.discontinuity = function () { i = void 0, t = void 0 }, this.reset = function () { this.discontinuity(), this.trigger("reset") } }; Oe.prototype = new De; var Pe, Ce = { TimestampRolloverStream: Oe, handleRollover: ke }, Ue = (e, t, i) => { if (!e) return -1; for (var n = i; n < e.length; n++)if (e[n] === t) return n; return -1 }, Re = function (e, t, i) { var n, s = ""; for (n = t; n < i; n++)s += "%" + ("00" + e[n].toString(16)).slice(-2); return s }, Me = function (e, t, i) { return decodeURIComponent(Re(e, t, i)) }, Be = function (e, t, i) { return unescape(Re(e, t, i)) }, Ne = function (e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] }, Fe = { APIC: function (e) { var t, i, n = 1; 3 === e.data[0] && ((t = Ue(e.data, 0, n)) < 0 || (e.mimeType = Be(e.data, n, t), n = t + 1, e.pictureType = e.data[n], n++, (i = Ue(e.data, 0, n)) < 0 || (e.description = Me(e.data, n, i), n = i + 1, "--\x3e" === e.mimeType ? e.url = Be(e.data, n, e.data.length) : e.pictureData = e.data.subarray(n, e.data.length)))) }, "T*": function (e) { 3 === e.data[0] && (e.value = Me(e.data, 1, e.data.length).replace(/\0*$/, ""), e.values = e.value.split("\0")) }, TXXX: function (e) { var t; 3 === e.data[0] && -1 !== (t = Ue(e.data, 0, 1)) && (e.description = Me(e.data, 1, t), e.value = Me(e.data, t + 1, e.data.length).replace(/\0*$/, ""), e.data = e.value) }, "W*": function (e) { e.url = Be(e.data, 0, e.data.length).replace(/\0.*$/, "") }, WXXX: function (e) { var t; 3 === e.data[0] && -1 !== (t = Ue(e.data, 0, 1)) && (e.description = Me(e.data, 1, t), e.url = Be(e.data, t + 1, e.data.length).replace(/\0.*$/, "")) }, PRIV: function (e) { var t; for (t = 0; t < e.data.length; t++)if (0 === e.data[t]) { e.owner = Be(e.data, 0, t); break } e.privateData = e.data.subarray(t + 1), e.data = e.privateData } }, $e = { parseId3Frames: function (e) { var t, i = 10, n = 0, s = []; if (!(e.length < 10 || e[0] !== "I".charCodeAt(0) || e[1] !== "D".charCodeAt(0) || e[2] !== "3".charCodeAt(0))) { n = Ne(e.subarray(6, 10)), n += 10, 64 & e[5] && (i += 4, i += Ne(e.subarray(10, 14)), n -= Ne(e.subarray(16, 20))); do { if ((t = Ne(e.subarray(i + 4, i + 8))) < 1) break; var a = { id: String.fromCharCode(e[i], e[i + 1], e[i + 2], e[i + 3]), data: e.subarray(i + 10, i + t + 10) }; a.key = a.id, Fe[a.id] ? Fe[a.id](a) : "T" === a.id[0] ? Fe["T*"](a) : "W" === a.id[0] && Fe["W*"](a), s.push(a), i += 10, i += t } while (i < n); return s } }, parseSyncSafeInteger: Ne, frameParsers: Fe }, qe = Le, Ge = $e; (Pe = function (e) { var t, i = { descriptor: e && e.descriptor }, n = 0, s = [], a = 0; if (Pe.prototype.init.call(this), this.dispatchType = qe.METADATA_STREAM_TYPE.toString(16), i.descriptor) for (t = 0; t < i.descriptor.length; t++)this.dispatchType += ("00" + i.descriptor[t].toString(16)).slice(-2); this.push = function (e) { var t, i, r, o, d; if ("timed-metadata" === e.type) if (e.dataAlignmentIndicator && (a = 0, s.length = 0), 0 === s.length && (e.data.length < 10 || e.data[0] !== "I".charCodeAt(0) || e.data[1] !== "D".charCodeAt(0) || e.data[2] !== "3".charCodeAt(0))) this.trigger("log", { level: "warn", message: "Skipping unrecognized metadata packet" }); else if (s.push(e), a += e.data.byteLength, 1 === s.length && (n = Ge.parseSyncSafeInteger(e.data.subarray(6, 10)), n += 10), !(a < n)) { for (t = { data: new Uint8Array(n), frames: [], pts: s[0].pts, dts: s[0].dts }, d = 0; d < n;)t.data.set(s[0].data.subarray(0, n - d), d), d += s[0].data.byteLength, a -= s[0].data.byteLength, s.shift(); i = 10, 64 & t.data[5] && (i += 4, i += Ge.parseSyncSafeInteger(t.data.subarray(10, 14)), n -= Ge.parseSyncSafeInteger(t.data.subarray(16, 20))); do { if ((r = Ge.parseSyncSafeInteger(t.data.subarray(i + 4, i + 8))) < 1) { this.trigger("log", { level: "warn", message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing." }); break } if ((o = { id: String.fromCharCode(t.data[i], t.data[i + 1], t.data[i + 2], t.data[i + 3]), data: t.data.subarray(i + 10, i + r + 10) }).key = o.id, Ge.frameParsers[o.id] ? Ge.frameParsers[o.id](o) : "T" === o.id[0] ? Ge.frameParsers["T*"](o) : "W" === o.id[0] && Ge.frameParsers["W*"](o), "com.apple.streaming.transportStreamTimestamp" === o.owner) { var u = o.data, l = (1 & u[3]) << 30 | u[4] << 22 | u[5] << 14 | u[6] << 6 | u[7] >>> 2; l *= 4, l += 3 & u[7], o.timeStamp = l, void 0 === t.pts && void 0 === t.dts && (t.pts = o.timeStamp, t.dts = o.timeStamp), this.trigger("timestamp", o) } t.frames.push(o), i += 10, i += r } while (i < n); this.trigger("data", t) } } }).prototype = new G; var We, Ve, He, Xe = Pe, je = G, ze = Ae, Ye = Le, Qe = Ce.TimestampRolloverStream, Ke = 188; (We = function () { var e = new Uint8Array(Ke), t = 0; We.prototype.init.call(this), this.push = function (i) { var n, s = 0, a = Ke; for (t ? ((n = new Uint8Array(i.byteLength + t)).set(e.subarray(0, t)), n.set(i, t), t = 0) : n = i; a < n.byteLength;)71 !== n[s] || 71 !== n[a] ? (s++, a++) : (this.trigger("data", n.subarray(s, a)), s += Ke, a += Ke); s < n.byteLength && (e.set(n.subarray(s), 0), t = n.byteLength - s) }, this.flush = function () { t === Ke && 71 === e[0] && (this.trigger("data", e), t = 0), this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.reset = function () { t = 0, this.trigger("reset") } }).prototype = new je, (Ve = function () { var e, t, i, n; Ve.prototype.init.call(this), n = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, e = function (e, n) { var s = 0; n.payloadUnitStartIndicator && (s += e[s] + 1), "pat" === n.type ? t(e.subarray(s), n) : i(e.subarray(s), n) }, t = function (e, t) { t.section_number = e[7], t.last_section_number = e[8], n.pmtPid = (31 & e[10]) << 8 | e[11], t.pmtPid = n.pmtPid }, i = function (e, t) { var i, s; if (1 & e[5]) { for (n.programMapTable = { video: null, audio: null, "timed-metadata": {} }, i = 3 + ((15 & e[1]) << 8 | e[2]) - 4, s = 12 + ((15 & e[10]) << 8 | e[11]); s < i;) { var a = e[s], r = (31 & e[s + 1]) << 8 | e[s + 2]; a === Ye.H264_STREAM_TYPE && null === n.programMapTable.video ? n.programMapTable.video = r : a === Ye.ADTS_STREAM_TYPE && null === n.programMapTable.audio ? n.programMapTable.audio = r : a === Ye.METADATA_STREAM_TYPE && (n.programMapTable["timed-metadata"][r] = a), s += 5 + ((15 & e[s + 3]) << 8 | e[s + 4]) } t.programMapTable = n.programMapTable } }, this.push = function (t) { var i = {}, n = 4; if (i.payloadUnitStartIndicator = !!(64 & t[1]), i.pid = 31 & t[1], i.pid <<= 8, i.pid |= t[2], (48 & t[3]) >>> 4 > 1 && (n += t[n] + 1), 0 === i.pid) i.type = "pat", e(t.subarray(n), i), this.trigger("data", i); else if (i.pid === this.pmtPid) for (i.type = "pmt", e(t.subarray(n), i), this.trigger("data", i); this.packetsWaitingForPmt.length;)this.processPes_.apply(this, this.packetsWaitingForPmt.shift()); else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([t, n, i]) : this.processPes_(t, n, i) }, this.processPes_ = function (e, t, i) { i.pid === this.programMapTable.video ? i.streamType = Ye.H264_STREAM_TYPE : i.pid === this.programMapTable.audio ? i.streamType = Ye.ADTS_STREAM_TYPE : i.streamType = this.programMapTable["timed-metadata"][i.pid], i.type = "pes", i.data = e.subarray(t), this.trigger("data", i) } }).prototype = new je, Ve.STREAM_TYPES = { h264: 27, adts: 15 }, He = function () { var e, t = this, i = !1, n = { data: [], size: 0 }, s = { data: [], size: 0 }, a = { data: [], size: 0 }, r = function (e, i, n) { var s, a, r = new Uint8Array(e.size), o = { type: i }, d = 0, u = 0; if (e.data.length && !(e.size < 9)) { for (o.trackId = e.data[0].pid, d = 0; d < e.data.length; d++)a = e.data[d], r.set(a.data, u), u += a.data.byteLength; !function (e, t) { var i; const n = e[0] << 16 | e[1] << 8 | e[2]; t.data = new Uint8Array, 1 === n && (t.packetLength = 6 + (e[4] << 8 | e[5]), t.dataAlignmentIndicator = 0 != (4 & e[6]), 192 & (i = e[7]) && (t.pts = (14 & e[9]) << 27 | (255 & e[10]) << 20 | (254 & e[11]) << 12 | (255 & e[12]) << 5 | (254 & e[13]) >>> 3, t.pts *= 4, t.pts += (6 & e[13]) >>> 1, t.dts = t.pts, 64 & i && (t.dts = (14 & e[14]) << 27 | (255 & e[15]) << 20 | (254 & e[16]) << 12 | (255 & e[17]) << 5 | (254 & e[18]) >>> 3, t.dts *= 4, t.dts += (6 & e[18]) >>> 1)), t.data = e.subarray(9 + e[8])) }(r, o), s = "video" === i || o.packetLength <= e.size, (n || s) && (e.size = 0, e.data.length = 0), s && t.trigger("data", o) } }; He.prototype.init.call(this), this.push = function (o) { ({ pat: function () { }, pes: function () { var e, t; switch (o.streamType) { case Ye.H264_STREAM_TYPE: e = n, t = "video"; break; case Ye.ADTS_STREAM_TYPE: e = s, t = "audio"; break; case Ye.METADATA_STREAM_TYPE: e = a, t = "timed-metadata"; break; default: return }o.payloadUnitStartIndicator && r(e, t, !0), e.data.push(o), e.size += o.data.byteLength }, pmt: function () { var n = { type: "metadata", tracks: [] }; null !== (e = o.programMapTable).video && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.video, codec: "avc", type: "video" }), null !== e.audio && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.audio, codec: "adts", type: "audio" }), i = !0, t.trigger("data", n) } })[o.type]() }, this.reset = function () { n.size = 0, n.data.length = 0, s.size = 0, s.data.length = 0, this.trigger("reset") }, this.flushStreams_ = function () { r(n, "video"), r(s, "audio"), r(a, "timed-metadata") }, this.flush = function () { if (!i && e) { var n = { type: "metadata", tracks: [] }; null !== e.video && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.video, codec: "avc", type: "video" }), null !== e.audio && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.audio, codec: "adts", type: "audio" }), t.trigger("data", n) } i = !1, this.flushStreams_(), this.trigger("done") } }, He.prototype = new je; var Je = { PAT_PID: 0, MP2T_PACKET_LENGTH: Ke, TransportPacketStream: We, TransportParseStream: Ve, ElementaryStream: He, TimestampRolloverStream: Qe, CaptionStream: ze.CaptionStream, Cea608Stream: ze.Cea608Stream, Cea708Stream: ze.Cea708Stream, MetadataStream: Xe }; for (var Ze in Ye) Ye.hasOwnProperty(Ze) && (Je[Ze] = Ye[Ze]); var et, tt = Je, it = oe.ONE_SECOND_IN_TS, nt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; (et = function (e) { var t, i = 0; et.prototype.init.call(this), this.skipWarn_ = function (e, t) { this.trigger("log", { level: "warn", message: `adts skiping bytes ${e} to ${t} in frame ${i} outside syncword` }) }, this.push = function (n) { var s, a, r, o, d, u = 0; if (e || (i = 0), "audio" === n.type) { var l; for (t && t.length ? (r = t, (t = new Uint8Array(r.byteLength + n.data.byteLength)).set(r), t.set(n.data, r.byteLength)) : t = n.data; u + 7 < t.length;)if (255 === t[u] && 240 == (246 & t[u + 1])) { if ("number" == typeof l && (this.skipWarn_(l, u), l = null), a = 2 * (1 & ~t[u + 1]), s = (3 & t[u + 3]) << 11 | t[u + 4] << 3 | (224 & t[u + 5]) >> 5, d = (o = 1024 * (1 + (3 & t[u + 6]))) * it / nt[(60 & t[u + 2]) >>> 2], t.byteLength - u < s) break; this.trigger("data", { pts: n.pts + i * d, dts: n.dts + i * d, sampleCount: o, audioobjecttype: 1 + (t[u + 2] >>> 6 & 3), channelcount: (1 & t[u + 2]) << 2 | (192 & t[u + 3]) >>> 6, samplerate: nt[(60 & t[u + 2]) >>> 2], samplingfrequencyindex: (60 & t[u + 2]) >>> 2, samplesize: 16, data: t.subarray(u + 7 + a, u + s) }), i++, u += s } else "number" != typeof l && (l = u), u++; "number" == typeof l && (this.skipWarn_(l, u), l = null), t = t.subarray(u) } }, this.flush = function () { i = 0, this.trigger("done") }, this.reset = function () { t = void 0, this.trigger("reset") }, this.endTimeline = function () { t = void 0, this.trigger("endedtimeline") } }).prototype = new G; var st, at, rt, ot = et, dt = G, ut = function (e) { var t = e.byteLength, i = 0, n = 0; this.length = function () { return 8 * t }, this.bitsAvailable = function () { return 8 * t + n }, this.loadWord = function () { var s = e.byteLength - t, a = new Uint8Array(4), r = Math.min(4, t); if (0 === r) throw new Error("no bytes available"); a.set(e.subarray(s, s + r)), i = new DataView(a.buffer).getUint32(0), n = 8 * r, t -= r }, this.skipBits = function (e) { var s; n > e ? (i <<= e, n -= e) : (e -= n, e -= 8 * (s = Math.floor(e / 8)), t -= s, this.loadWord(), i <<= e, n -= e) }, this.readBits = function (e) { var s = Math.min(n, e), a = i >>> 32 - s; return (n -= s) > 0 ? i <<= s : t > 0 && this.loadWord(), (s = e - s) > 0 ? a << s | this.readBits(s) : a }, this.skipLeadingZeros = function () { var e; for (e = 0; e < n; ++e)if (0 != (i & 2147483648 >>> e)) return i <<= e, n -= e, e; return this.loadWord(), e + this.skipLeadingZeros() }, this.skipUnsignedExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.skipExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.readUnsignedExpGolomb = function () { var e = this.skipLeadingZeros(); return this.readBits(e + 1) - 1 }, this.readExpGolomb = function () { var e = this.readUnsignedExpGolomb(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) }, this.readBoolean = function () { return 1 === this.readBits(1) }, this.readUnsignedByte = function () { return this.readBits(8) }, this.loadWord() }; (at = function () { var e, t, i = 0; at.prototype.init.call(this), this.push = function (n) { var s; t ? ((s = new Uint8Array(t.byteLength + n.data.byteLength)).set(t), s.set(n.data, t.byteLength), t = s) : t = n.data; for (var a = t.byteLength; i < a - 3; i++)if (1 === t[i + 2]) { e = i + 5; break } for (; e < a;)switch (t[e]) { case 0: if (0 !== t[e - 1]) { e += 2; break } if (0 !== t[e - 2]) { e++; break } i + 3 !== e - 2 && this.trigger("data", t.subarray(i + 3, e - 2)); do { e++ } while (1 !== t[e] && e < a); i = e - 2, e += 3; break; case 1: if (0 !== t[e - 1] || 0 !== t[e - 2]) { e += 3; break } this.trigger("data", t.subarray(i + 3, e - 2)), i = e - 2, e += 3; break; default: e += 3 }t = t.subarray(i), e -= i, i = 0 }, this.reset = function () { t = null, i = 0, this.trigger("reset") }, this.flush = function () { t && t.byteLength > 3 && this.trigger("data", t.subarray(i + 3)), t = null, i = 0, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") } }).prototype = new dt, rt = { 100: !0, 110: !0, 122: !0, 244: !0, 44: !0, 83: !0, 86: !0, 118: !0, 128: !0, 138: !0, 139: !0, 134: !0 }, st = function () { var e, t, i, n, s, a, r, o = new at; st.prototype.init.call(this), e = this, this.push = function (e) { "video" === e.type && (t = e.trackId, i = e.pts, n = e.dts, o.push(e)) }, o.on("data", (function (r) { var o = { trackId: t, pts: i, dts: n, data: r, nalUnitTypeCode: 31 & r[0] }; switch (o.nalUnitTypeCode) { case 5: o.nalUnitType = "slice_layer_without_partitioning_rbsp_idr"; break; case 6: o.nalUnitType = "sei_rbsp", o.escapedRBSP = s(r.subarray(1)); break; case 7: o.nalUnitType = "seq_parameter_set_rbsp", o.escapedRBSP = s(r.subarray(1)), o.config = a(o.escapedRBSP); break; case 8: o.nalUnitType = "pic_parameter_set_rbsp"; break; case 9: o.nalUnitType = "access_unit_delimiter_rbsp" }e.trigger("data", o) })), o.on("done", (function () { e.trigger("done") })), o.on("partialdone", (function () { e.trigger("partialdone") })), o.on("reset", (function () { e.trigger("reset") })), o.on("endedtimeline", (function () { e.trigger("endedtimeline") })), this.flush = function () { o.flush() }, this.partialFlush = function () { o.partialFlush() }, this.reset = function () { o.reset() }, this.endTimeline = function () { o.endTimeline() }, r = function (e, t) { var i, n = 8, s = 8; for (i = 0; i < e; i++)0 !== s && (s = (n + t.readExpGolomb() + 256) % 256), n = 0 === s ? n : s }, s = function (e) { for (var t, i, n = e.byteLength, s = [], a = 1; a < n - 2;)0 === e[a] && 0 === e[a + 1] && 3 === e[a + 2] ? (s.push(a + 2), a += 2) : a++; if (0 === s.length) return e; t = n - s.length, i = new Uint8Array(t); var r = 0; for (a = 0; a < t; r++, a++)r === s[0] && (r++, s.shift()), i[a] = e[r]; return i }, a = function (e) { var t, i, n, s, a, o, d, u, l, h, c, p, m = 0, f = 0, g = 0, y = 0, _ = [1, 1]; if (i = (t = new ut(e)).readUnsignedByte(), s = t.readUnsignedByte(), n = t.readUnsignedByte(), t.skipUnsignedExpGolomb(), rt[i] && (3 === (a = t.readUnsignedExpGolomb()) && t.skipBits(1), t.skipUnsignedExpGolomb(), t.skipUnsignedExpGolomb(), t.skipBits(1), t.readBoolean())) for (c = 3 !== a ? 8 : 12, p = 0; p < c; p++)t.readBoolean() && r(p < 6 ? 16 : 64, t); if (t.skipUnsignedExpGolomb(), 0 === (o = t.readUnsignedExpGolomb())) t.readUnsignedExpGolomb(); else if (1 === o) for (t.skipBits(1), t.skipExpGolomb(), t.skipExpGolomb(), d = t.readUnsignedExpGolomb(), p = 0; p < d; p++)t.skipExpGolomb(); if (t.skipUnsignedExpGolomb(), t.skipBits(1), u = t.readUnsignedExpGolomb(), l = t.readUnsignedExpGolomb(), 0 === (h = t.readBits(1)) && t.skipBits(1), t.skipBits(1), t.readBoolean() && (m = t.readUnsignedExpGolomb(), f = t.readUnsignedExpGolomb(), g = t.readUnsignedExpGolomb(), y = t.readUnsignedExpGolomb()), t.readBoolean() && t.readBoolean()) { switch (t.readUnsignedByte()) { case 1: _ = [1, 1]; break; case 2: _ = [12, 11]; break; case 3: _ = [10, 11]; break; case 4: _ = [16, 11]; break; case 5: _ = [40, 33]; break; case 6: _ = [24, 11]; break; case 7: _ = [20, 11]; break; case 8: _ = [32, 11]; break; case 9: _ = [80, 33]; break; case 10: _ = [18, 11]; break; case 11: _ = [15, 11]; break; case 12: _ = [64, 33]; break; case 13: _ = [160, 99]; break; case 14: _ = [4, 3]; break; case 15: _ = [3, 2]; break; case 16: _ = [2, 1]; break; case 255: _ = [t.readUnsignedByte() << 8 | t.readUnsignedByte(), t.readUnsignedByte() << 8 | t.readUnsignedByte()] }_ && (_[0], _[1]) } return { profileIdc: i, levelIdc: n, profileCompatibility: s, width: 16 * (u + 1) - 2 * m - 2 * f, height: (2 - h) * (l + 1) * 16 - 2 * g - 2 * y, sarRatio: _ } } }, st.prototype = new dt; var lt, ht = { H264Stream: st, NalByteStream: at }, ct = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], pt = function (e, t) { var i = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]; return i = i >= 0 ? i : 0, (16 & e[t + 5]) >> 4 ? i + 20 : i + 10 }, mt = function (e, t) { return e.length - t < 10 || e[t] !== "I".charCodeAt(0) || e[t + 1] !== "D".charCodeAt(0) || e[t + 2] !== "3".charCodeAt(0) ? t : (t += pt(e, t), mt(e, t)) }, ft = function (e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] }, gt = { isLikelyAacData: function (e) { var t = mt(e, 0); return e.length >= t + 2 && 255 == (255 & e[t]) && 240 == (240 & e[t + 1]) && 16 == (22 & e[t + 1]) }, parseId3TagSize: pt, parseAdtsSize: function (e, t) { var i = (224 & e[t + 5]) >> 5, n = e[t + 4] << 3; return 6144 & e[t + 3] | n | i }, parseType: function (e, t) { return e[t] === "I".charCodeAt(0) && e[t + 1] === "D".charCodeAt(0) && e[t + 2] === "3".charCodeAt(0) ? "timed-metadata" : !0 & e[t] && 240 == (240 & e[t + 1]) ? "audio" : null }, parseSampleRate: function (e) { for (var t = 0; t + 5 < e.length;) { if (255 === e[t] && 240 == (246 & e[t + 1])) return ct[(60 & e[t + 2]) >>> 2]; t++ } return null }, parseAacTimestamp: function (e) { var t, i, n; t = 10, 64 & e[5] && (t += 4, t += ft(e.subarray(10, 14))); do { if ((i = ft(e.subarray(t + 4, t + 8))) < 1) return null; if ("PRIV" === String.fromCharCode(e[t], e[t + 1], e[t + 2], e[t + 3])) { n = e.subarray(t + 10, t + i + 10); for (var s = 0; s < n.byteLength; s++)if (0 === n[s]) { var a = unescape(function (e, t, i) { var n, s = ""; for (n = 0; n < i; n++)s += "%" + ("00" + e[n].toString(16)).slice(-2); return s }(n, 0, s)); if ("com.apple.streaming.transportStreamTimestamp" === a) { var r = n.subarray(s + 1), o = (1 & r[3]) << 30 | r[4] << 22 | r[5] << 14 | r[6] << 6 | r[7] >>> 2; return (o *= 4) + (3 & r[7]) } break } } t += 10, t += i } while (t < e.byteLength); return null } }, yt = gt; (lt = function () { var e = new Uint8Array, t = 0; lt.prototype.init.call(this), this.setTimestamp = function (e) { t = e }, this.push = function (i) { var n, s, a, r, o = 0, d = 0; for (e.length ? (r = e.length, (e = new Uint8Array(i.byteLength + r)).set(e.subarray(0, r)), e.set(i, r)) : e = i; e.length - d >= 3;)if (e[d] !== "I".charCodeAt(0) || e[d + 1] !== "D".charCodeAt(0) || e[d + 2] !== "3".charCodeAt(0)) if (255 != (255 & e[d]) || 240 != (240 & e[d + 1])) d++; else { if (e.length - d < 7) break; if (d + (o = yt.parseAdtsSize(e, d)) > e.length) break; a = { type: "audio", data: e.subarray(d, d + o), pts: t, dts: t }, this.trigger("data", a), d += o } else { if (e.length - d < 10) break; if (d + (o = yt.parseId3TagSize(e, d)) > e.length) break; s = { type: "timed-metadata", data: e.subarray(d, d + o) }, this.trigger("data", s), d += o } n = e.length - d, e = n > 0 ? e.subarray(d) : new Uint8Array }, this.reset = function () { e = new Uint8Array, this.trigger("reset") }, this.endTimeline = function () { e = new Uint8Array, this.trigger("endedtimeline") } }).prototype = new G; var _t, Tt, bt, St, vt = G, wt = ee, It = ie, Et = ue, At = he, Lt = tt, Dt = oe, xt = ot, kt = ht.H264Stream, Ot = lt, Pt = gt.isLikelyAacData, Ct = oe.ONE_SECOND_IN_TS, Ut = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], Rt = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], Mt = function (e, t) { t.stream = e, this.trigger("log", t) }, Bt = function (e, t) { for (var i = Object.keys(t), n = 0; n < i.length; n++) { var s = i[n]; "headOfPipeline" !== s && t[s].on && t[s].on("log", Mt.bind(e, s)) } }, Nt = function (e, t) { var i; if (e.length !== t.length) return !1; for (i = 0; i < e.length; i++)if (e[i] !== t[i]) return !1; return !0 }, Ft = function (e, t, i, n, s, a) { return { start: { dts: e, pts: e + (i - t) }, end: { dts: e + (n - t), pts: e + (s - i) }, prependedContentDuration: a, baseMediaDecodeTime: e } }; Tt = function (e, t) { var i, n = [], s = 0, a = 0, r = 1 / 0; i = (t = t || {}).firstSequenceNumber || 0, Tt.prototype.init.call(this), this.push = function (t) { At.collectDtsInfo(e, t), e && Ut.forEach((function (i) { e[i] = t[i] })), n.push(t) }, this.setEarliestDts = function (e) { s = e }, this.setVideoBaseMediaDecodeTime = function (e) { r = e }, this.setAudioAppendStart = function (e) { a = e }, this.flush = function () { var o, d, u, l, h, c, p; 0 !== n.length ? (o = Et.trimAdtsFramesByEarliestDts(n, e, s), e.baseMediaDecodeTime = At.calculateTrackBaseMediaDecodeTime(e, t.keepOriginalTimestamps), p = Et.prefixWithSilence(e, o, a, r), e.samples = Et.generateSampleTable(o), u = wt.mdat(Et.concatenateFrameData(o)), n = [], d = wt.moof(i, [e]), l = new Uint8Array(d.byteLength + u.byteLength), i++, l.set(d), l.set(u, d.byteLength), At.clearDtsInfo(e), h = Math.ceil(1024 * Ct / e.samplerate), o.length && (c = o.length * h, this.trigger("segmentTimingInfo", Ft(Dt.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), o[0].dts, o[0].pts, o[0].dts + c, o[0].pts + c, p || 0)), this.trigger("timingInfo", { start: o[0].pts, end: o[0].pts + c })), this.trigger("data", { track: e, boxes: l }), this.trigger("done", "AudioSegmentStream")) : this.trigger("done", "AudioSegmentStream") }, this.reset = function () { At.clearDtsInfo(e), n = [], this.trigger("reset") } }, Tt.prototype = new vt, _t = function (e, t) { var i, n, s, a = [], r = []; i = (t = t || {}).firstSequenceNumber || 0, _t.prototype.init.call(this), delete e.minPTS, this.gopCache_ = [], this.push = function (t) { At.collectDtsInfo(e, t), "seq_parameter_set_rbsp" !== t.nalUnitType || n || (n = t.config, e.sps = [t.data], Rt.forEach((function (t) { e[t] = n[t] }), this)), "pic_parameter_set_rbsp" !== t.nalUnitType || s || (s = t.data, e.pps = [t.data]), a.push(t) }, this.flush = function () { for (var n, s, o, d, u, l, h, c, p = 0; a.length && "access_unit_delimiter_rbsp" !== a[0].nalUnitType;)a.shift(); if (0 === a.length) return this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); if (n = It.groupNalsIntoFrames(a), (o = It.groupFramesIntoGops(n))[0][0].keyFrame || ((s = this.getGopForFusion_(a[0], e)) ? (p = s.duration, o.unshift(s), o.byteLength += s.byteLength, o.nalCount += s.nalCount, o.pts = s.pts, o.dts = s.dts, o.duration += s.duration) : o = It.extendFirstKeyFrame(o)), r.length) { var m; if (!(m = t.alignGopsAtEnd ? this.alignGopsAtEnd_(o) : this.alignGopsAtStart_(o))) return this.gopCache_.unshift({ gop: o.pop(), pps: e.pps, sps: e.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), a = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); At.clearDtsInfo(e), o = m } At.collectDtsInfo(e, o), e.samples = It.generateSampleTable(o), u = wt.mdat(It.concatenateNalData(o)), e.baseMediaDecodeTime = At.calculateTrackBaseMediaDecodeTime(e, t.keepOriginalTimestamps), this.trigger("processedGopsInfo", o.map((function (e) { return { pts: e.pts, dts: e.dts, byteLength: e.byteLength } }))), h = o[0], c = o[o.length - 1], this.trigger("segmentTimingInfo", Ft(e.baseMediaDecodeTime, h.dts, h.pts, c.dts + c.duration, c.pts + c.duration, p)), this.trigger("timingInfo", { start: o[0].pts, end: o[o.length - 1].pts + o[o.length - 1].duration }), this.gopCache_.unshift({ gop: o.pop(), pps: e.pps, sps: e.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), a = [], this.trigger("baseMediaDecodeTime", e.baseMediaDecodeTime), this.trigger("timelineStartInfo", e.timelineStartInfo), d = wt.moof(i, [e]), l = new Uint8Array(d.byteLength + u.byteLength), i++, l.set(d), l.set(u, d.byteLength), this.trigger("data", { track: e, boxes: l }), this.resetStream_(), this.trigger("done", "VideoSegmentStream") }, this.reset = function () { this.resetStream_(), a = [], this.gopCache_.length = 0, r.length = 0, this.trigger("reset") }, this.resetStream_ = function () { At.clearDtsInfo(e), n = void 0, s = void 0 }, this.getGopForFusion_ = function (t) { var i, n, s, a, r, o = 1 / 0; for (r = 0; r < this.gopCache_.length; r++)s = (a = this.gopCache_[r]).gop, e.pps && Nt(e.pps[0], a.pps[0]) && e.sps && Nt(e.sps[0], a.sps[0]) && (s.dts < e.timelineStartInfo.dts || (i = t.dts - s.dts - s.duration) >= -1e4 && i <= 45e3 && (!n || o > i) && (n = a, o = i)); return n ? n.gop : null }, this.alignGopsAtStart_ = function (e) { var t, i, n, s, a, o, d, u; for (a = e.byteLength, o = e.nalCount, d = e.duration, t = i = 0; t < r.length && i < e.length && (n = r[t], s = e[i], n.pts !== s.pts);)s.pts > n.pts ? t++ : (i++, a -= s.byteLength, o -= s.nalCount, d -= s.duration); return 0 === i ? e : i === e.length ? null : ((u = e.slice(i)).byteLength = a, u.duration = d, u.nalCount = o, u.pts = u[0].pts, u.dts = u[0].dts, u) }, this.alignGopsAtEnd_ = function (e) { var t, i, n, s, a, o, d; for (t = r.length - 1, i = e.length - 1, a = null, o = !1; t >= 0 && i >= 0;) { if (n = r[t], s = e[i], n.pts === s.pts) { o = !0; break } n.pts > s.pts ? t-- : (t === r.length - 1 && (a = i), i--) } if (!o && null === a) return null; if (0 === (d = o ? i : a)) return e; var u = e.slice(d), l = u.reduce((function (e, t) { return e.byteLength += t.byteLength, e.duration += t.duration, e.nalCount += t.nalCount, e }), { byteLength: 0, duration: 0, nalCount: 0 }); return u.byteLength = l.byteLength, u.duration = l.duration, u.nalCount = l.nalCount, u.pts = u[0].pts, u.dts = u[0].dts, u }, this.alignGopsWith = function (e) { r = e } }, _t.prototype = new vt, St = function (e, t) { this.numberOfTracks = 0, this.metadataStream = t, void 0 !== (e = e || {}).remux ? this.remuxTracks = !!e.remux : this.remuxTracks = !0, "boolean" == typeof e.keepOriginalTimestamps ? this.keepOriginalTimestamps = e.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, St.prototype.init.call(this), this.push = function (e) { return e.text ? this.pendingCaptions.push(e) : e.frames ? this.pendingMetadata.push(e) : (this.pendingTracks.push(e.track), this.pendingBytes += e.boxes.byteLength, "video" === e.track.type && (this.videoTrack = e.track, this.pendingBoxes.push(e.boxes)), void ("audio" === e.track.type && (this.audioTrack = e.track, this.pendingBoxes.unshift(e.boxes)))) } }, St.prototype = new vt, St.prototype.flush = function (e) { var t, i, n, s, a = 0, r = { captions: [], captionStreams: {}, metadata: [], info: {} }, o = 0; if (this.pendingTracks.length < this.numberOfTracks) { if ("VideoSegmentStream" !== e && "AudioSegmentStream" !== e) return; if (this.remuxTracks) return; if (0 === this.pendingTracks.length) return this.emittedTracks++, void (this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)) } if (this.videoTrack ? (o = this.videoTrack.timelineStartInfo.pts, Rt.forEach((function (e) { r.info[e] = this.videoTrack[e] }), this)) : this.audioTrack && (o = this.audioTrack.timelineStartInfo.pts, Ut.forEach((function (e) { r.info[e] = this.audioTrack[e] }), this)), this.videoTrack || this.audioTrack) { for (1 === this.pendingTracks.length ? r.type = this.pendingTracks[0].type : r.type = "combined", this.emittedTracks += this.pendingTracks.length, n = wt.initSegment(this.pendingTracks), r.initSegment = new Uint8Array(n.byteLength), r.initSegment.set(n), r.data = new Uint8Array(this.pendingBytes), s = 0; s < this.pendingBoxes.length; s++)r.data.set(this.pendingBoxes[s], a), a += this.pendingBoxes[s].byteLength; for (s = 0; s < this.pendingCaptions.length; s++)(t = this.pendingCaptions[s]).startTime = Dt.metadataTsToSeconds(t.startPts, o, this.keepOriginalTimestamps), t.endTime = Dt.metadataTsToSeconds(t.endPts, o, this.keepOriginalTimestamps), r.captionStreams[t.stream] = !0, r.captions.push(t); for (s = 0; s < this.pendingMetadata.length; s++)(i = this.pendingMetadata[s]).cueTime = Dt.metadataTsToSeconds(i.pts, o, this.keepOriginalTimestamps), r.metadata.push(i); for (r.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", r), s = 0; s < r.captions.length; s++)t = r.captions[s], this.trigger("caption", t); for (s = 0; s < r.metadata.length; s++)i = r.metadata[s], this.trigger("id3Frame", i) } this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0) }, St.prototype.setRemux = function (e) { this.remuxTracks = e }, (bt = function (e) { var t, i, n = this, s = !0; bt.prototype.init.call(this), e = e || {}, this.baseMediaDecodeTime = e.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function () { var s = {}; this.transmuxPipeline_ = s, s.type = "aac", s.metadataStream = new Lt.MetadataStream, s.aacStream = new Ot, s.audioTimestampRolloverStream = new Lt.TimestampRolloverStream("audio"), s.timedMetadataTimestampRolloverStream = new Lt.TimestampRolloverStream("timed-metadata"), s.adtsStream = new xt, s.coalesceStream = new St(e, s.metadataStream), s.headOfPipeline = s.aacStream, s.aacStream.pipe(s.audioTimestampRolloverStream).pipe(s.adtsStream), s.aacStream.pipe(s.timedMetadataTimestampRolloverStream).pipe(s.metadataStream).pipe(s.coalesceStream), s.metadataStream.on("timestamp", (function (e) { s.aacStream.setTimestamp(e.timeStamp) })), s.aacStream.on("data", (function (a) { "timed-metadata" !== a.type && "audio" !== a.type || s.audioSegmentStream || (i = i || { timelineStartInfo: { baseMediaDecodeTime: n.baseMediaDecodeTime }, codec: "adts", type: "audio" }, s.coalesceStream.numberOfTracks++, s.audioSegmentStream = new Tt(i, e), s.audioSegmentStream.on("log", n.getLogTrigger_("audioSegmentStream")), s.audioSegmentStream.on("timingInfo", n.trigger.bind(n, "audioTimingInfo")), s.adtsStream.pipe(s.audioSegmentStream).pipe(s.coalesceStream), n.trigger("trackinfo", { hasAudio: !!i, hasVideo: !!t })) })), s.coalesceStream.on("data", this.trigger.bind(this, "data")), s.coalesceStream.on("done", this.trigger.bind(this, "done")), Bt(this, s) }, this.setupTsPipeline = function () { var s = {}; this.transmuxPipeline_ = s, s.type = "ts", s.metadataStream = new Lt.MetadataStream, s.packetStream = new Lt.TransportPacketStream, s.parseStream = new Lt.TransportParseStream, s.elementaryStream = new Lt.ElementaryStream, s.timestampRolloverStream = new Lt.TimestampRolloverStream, s.adtsStream = new xt, s.h264Stream = new kt, s.captionStream = new Lt.CaptionStream(e), s.coalesceStream = new St(e, s.metadataStream), s.headOfPipeline = s.packetStream, s.packetStream.pipe(s.parseStream).pipe(s.elementaryStream).pipe(s.timestampRolloverStream), s.timestampRolloverStream.pipe(s.h264Stream), s.timestampRolloverStream.pipe(s.adtsStream), s.timestampRolloverStream.pipe(s.metadataStream).pipe(s.coalesceStream), s.h264Stream.pipe(s.captionStream).pipe(s.coalesceStream), s.elementaryStream.on("data", (function (a) { var r; if ("metadata" === a.type) { for (r = a.tracks.length; r--;)t || "video" !== a.tracks[r].type ? i || "audio" !== a.tracks[r].type || ((i = a.tracks[r]).timelineStartInfo.baseMediaDecodeTime = n.baseMediaDecodeTime) : (t = a.tracks[r]).timelineStartInfo.baseMediaDecodeTime = n.baseMediaDecodeTime; t && !s.videoSegmentStream && (s.coalesceStream.numberOfTracks++, s.videoSegmentStream = new _t(t, e), s.videoSegmentStream.on("log", n.getLogTrigger_("videoSegmentStream")), s.videoSegmentStream.on("timelineStartInfo", (function (t) { i && !e.keepOriginalTimestamps && (i.timelineStartInfo = t, s.audioSegmentStream.setEarliestDts(t.dts - n.baseMediaDecodeTime)) })), s.videoSegmentStream.on("processedGopsInfo", n.trigger.bind(n, "gopInfo")), s.videoSegmentStream.on("segmentTimingInfo", n.trigger.bind(n, "videoSegmentTimingInfo")), s.videoSegmentStream.on("baseMediaDecodeTime", (function (e) { i && s.audioSegmentStream.setVideoBaseMediaDecodeTime(e) })), s.videoSegmentStream.on("timingInfo", n.trigger.bind(n, "videoTimingInfo")), s.h264Stream.pipe(s.videoSegmentStream).pipe(s.coalesceStream)), i && !s.audioSegmentStream && (s.coalesceStream.numberOfTracks++, s.audioSegmentStream = new Tt(i, e), s.audioSegmentStream.on("log", n.getLogTrigger_("audioSegmentStream")), s.audioSegmentStream.on("timingInfo", n.trigger.bind(n, "audioTimingInfo")), s.audioSegmentStream.on("segmentTimingInfo", n.trigger.bind(n, "audioSegmentTimingInfo")), s.adtsStream.pipe(s.audioSegmentStream).pipe(s.coalesceStream)), n.trigger("trackinfo", { hasAudio: !!i, hasVideo: !!t }) } })), s.coalesceStream.on("data", this.trigger.bind(this, "data")), s.coalesceStream.on("id3Frame", (function (e) { e.dispatchType = s.metadataStream.dispatchType, n.trigger("id3Frame", e) })), s.coalesceStream.on("caption", this.trigger.bind(this, "caption")), s.coalesceStream.on("done", this.trigger.bind(this, "done")), Bt(this, s) }, this.setBaseMediaDecodeTime = function (n) { var s = this.transmuxPipeline_; e.keepOriginalTimestamps || (this.baseMediaDecodeTime = n), i && (i.timelineStartInfo.dts = void 0, i.timelineStartInfo.pts = void 0, At.clearDtsInfo(i), s.audioTimestampRolloverStream && s.audioTimestampRolloverStream.discontinuity()), t && (s.videoSegmentStream && (s.videoSegmentStream.gopCache_ = []), t.timelineStartInfo.dts = void 0, t.timelineStartInfo.pts = void 0, At.clearDtsInfo(t), s.captionStream.reset()), s.timestampRolloverStream && s.timestampRolloverStream.discontinuity() }, this.setAudioAppendStart = function (e) { i && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(e) }, this.setRemux = function (t) { var i = this.transmuxPipeline_; e.remux = t, i && i.coalesceStream && i.coalesceStream.setRemux(t) }, this.alignGopsWith = function (e) { t && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(e) }, this.getLogTrigger_ = function (e) { var t = this; return function (i) { i.stream = e, t.trigger("log", i) } }, this.push = function (e) { if (s) { var t = Pt(e); t && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : t || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), s = !1 } this.transmuxPipeline_.headOfPipeline.push(e) }, this.flush = function () { s = !0, this.transmuxPipeline_.headOfPipeline.flush() }, this.endTimeline = function () { this.transmuxPipeline_.headOfPipeline.endTimeline() }, this.reset = function () { this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset() }, this.resetCaptions = function () { this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset() } }).prototype = new vt; var $t, qt, Gt, Wt, Vt = { Transmuxer: bt, VideoSegmentStream: _t, AudioSegmentStream: Tt, AUDIO_PROPERTIES: Ut, VIDEO_PROPERTIES: Rt, generateSegmentTimingInfo: Ft }, Ht = function (e) { return e >>> 0 }, Xt = function (e) { var t = ""; return t += String.fromCharCode(e[0]), t += String.fromCharCode(e[1]), (t += String.fromCharCode(e[2])) + String.fromCharCode(e[3]) }, jt = Ht, zt = Xt, Yt = function (e, t) { var i, n, s, a, r, o = []; if (!t.length) return null; for (i = 0; i < e.byteLength;)n = jt(e[i] << 24 | e[i + 1] << 16 | e[i + 2] << 8 | e[i + 3]), s = zt(e.subarray(i + 4, i + 8)), a = n > 1 ? i + n : e.byteLength, s === t[0] && (1 === t.length ? o.push(e.subarray(i + 8, a)) : (r = Yt(e.subarray(i + 8, a), t.slice(1))).length && (o = o.concat(r))), i = a; return o }, Qt = Ht, Kt = V.getUint64, Jt = function (e) { var t = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)) }; return 1 === t.version ? t.baseMediaDecodeTime = Kt(e.subarray(4)) : t.baseMediaDecodeTime = Qt(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7]), t }, Zt = function (e) { return { isLeading: (12 & e[0]) >>> 2, dependsOn: 3 & e[0], isDependedOn: (192 & e[1]) >>> 6, hasRedundancy: (48 & e[1]) >>> 4, paddingValue: (14 & e[1]) >>> 1, isNonSyncSample: 1 & e[1], degradationPriority: e[2] << 8 | e[3] } }, ei = function (e) { var t, i = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), samples: [] }, n = new DataView(e.buffer, e.byteOffset, e.byteLength), s = 1 & i.flags[2], a = 4 & i.flags[2], r = 1 & i.flags[1], o = 2 & i.flags[1], d = 4 & i.flags[1], u = 8 & i.flags[1], l = n.getUint32(4), h = 8; for (s && (i.dataOffset = n.getInt32(h), h += 4), a && l && (t = { flags: Zt(e.subarray(h, h + 4)) }, h += 4, r && (t.duration = n.getUint32(h), h += 4), o && (t.size = n.getUint32(h), h += 4), u && (1 === i.version ? t.compositionTimeOffset = n.getInt32(h) : t.compositionTimeOffset = n.getUint32(h), h += 4), i.samples.push(t), l--); l--;)t = {}, r && (t.duration = n.getUint32(h), h += 4), o && (t.size = n.getUint32(h), h += 4), d && (t.flags = Zt(e.subarray(h, h + 4)), h += 4), u && (1 === i.version ? t.compositionTimeOffset = n.getInt32(h) : t.compositionTimeOffset = n.getUint32(h), h += 4), i.samples.push(t); return i }, ti = function (e) { var t, i = new DataView(e.buffer, e.byteOffset, e.byteLength), n = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), trackId: i.getUint32(4) }, s = 1 & n.flags[2], a = 2 & n.flags[2], r = 8 & n.flags[2], o = 16 & n.flags[2], d = 32 & n.flags[2], u = 65536 & n.flags[0], l = 131072 & n.flags[0]; return t = 8, s && (t += 4, n.baseDataOffset = i.getUint32(12), t += 4), a && (n.sampleDescriptionIndex = i.getUint32(t), t += 4), r && (n.defaultSampleDuration = i.getUint32(t), t += 4), o && (n.defaultSampleSize = i.getUint32(t), t += 4), d && (n.defaultSampleFlags = i.getUint32(t)), u && (n.durationIsEmpty = !0), !s && l && (n.baseDataOffsetIsMoof = !0), n }, ii = ($t = "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}, ce.discardEmulationPreventionBytes), ni = Ae.CaptionStream, si = Yt, ai = Jt, ri = ei, oi = ti, di = $t, ui = function (e, t) { for (var i = e, n = 0; n < t.length; n++) { var s = t[n]; if (i < s.size) return s; i -= s.size } return null }, li = function () { var e, t, i, n, s, a, r = !1; this.isInitialized = function () { return r }, this.init = function (t) { e = new ni, r = !0, a = !!t && t.isPartial, e.on("data", (function (e) { e.startTime = e.startPts / n, e.endTime = e.endPts / n, s.captions.push(e), s.captionStreams[e.stream] = !0 })), e.on("log", (function (e) { s.logs.push(e) })) }, this.isNewInit = function (e, t) { return !(e && 0 === e.length || t && "object" == typeof t && 0 === Object.keys(t).length || i === e[0] && n === t[i]) }, this.parse = function (e, a, r) { var o; if (!this.isInitialized()) return null; if (!a || !r) return null; if (this.isNewInit(a, r)) i = a[0], n = r[i]; else if (null === i || !n) return t.push(e), null; for (; t.length > 0;) { var d = t.shift(); this.parse(d, a, r) } return o = function (e, t, i) { if (null === t) return null; var n = function (e, t) { var i = si(e, ["moof", "traf"]), n = si(e, ["mdat"]), s = {}, a = []; return n.forEach((function (e, t) { var n = i[t]; a.push({ mdat: e, traf: n }) })), a.forEach((function (e) { var i, n, a = e.mdat, r = e.traf, o = si(r, ["tfhd"]), d = oi(o[0]), u = d.trackId, l = si(r, ["tfdt"]), h = l.length > 0 ? ai(l[0]).baseMediaDecodeTime : 0, c = si(r, ["trun"]); t === u && c.length > 0 && (i = function (e, t, i) { var n = t, s = i.defaultSampleDuration || 0, a = i.defaultSampleSize || 0, r = i.trackId, o = []; return e.forEach((function (e) { var t = ri(e).samples; t.forEach((function (e) { void 0 === e.duration && (e.duration = s), void 0 === e.size && (e.size = a), e.trackId = r, e.dts = n, void 0 === e.compositionTimeOffset && (e.compositionTimeOffset = 0), "bigint" == typeof n ? (e.pts = n + di.BigInt(e.compositionTimeOffset), n += di.BigInt(e.duration)) : (e.pts = n + e.compositionTimeOffset, n += e.duration) })), o = o.concat(t) })), o }(c, h, d), n = function (e, t, i) { var n, s, a, r, o = new DataView(e.buffer, e.byteOffset, e.byteLength), d = { logs: [], seiNals: [] }; for (s = 0; s + 4 < e.length; s += a)if (a = o.getUint32(s), s += 4, !(a <= 0)) switch (31 & e[s]) { case 6: var u = e.subarray(s + 1, s + 1 + a), l = ui(s, t); if (n = { nalUnitType: "sei_rbsp", size: a, data: u, escapedRBSP: ii(u), trackId: i }, l) n.pts = l.pts, n.dts = l.dts, r = l; else { if (!r) { d.logs.push({ level: "warn", message: "We've encountered a nal unit without data at " + s + " for trackId " + i + ". See mux.js#223." }); break } n.pts = r.pts, n.dts = r.dts } d.seiNals.push(n) }return d }(a, i, u), s[u] || (s[u] = { seiNals: [], logs: [] }), s[u].seiNals = s[u].seiNals.concat(n.seiNals), s[u].logs = s[u].logs.concat(n.logs)) })), s }(e, t)[t] || {}; return { seiNals: n.seiNals, logs: n.logs, timescale: i } }(e, i, n), o && o.logs && (s.logs = s.logs.concat(o.logs)), null !== o && o.seiNals ? (this.pushNals(o.seiNals), this.flushStream(), s) : s.logs.length ? { logs: s.logs, captions: [], captionStreams: [] } : null }, this.pushNals = function (t) { if (!this.isInitialized() || !t || 0 === t.length) return null; t.forEach((function (t) { e.push(t) })) }, this.flushStream = function () { if (!this.isInitialized()) return null; a ? e.partialFlush() : e.flush() }, this.clearParsedCaptions = function () { s.captions = [], s.captionStreams = {}, s.logs = [] }, this.resetCaptionStream = function () { if (!this.isInitialized()) return null; e.reset() }, this.clearAllCaptions = function () { this.clearParsedCaptions(), this.resetCaptionStream() }, this.reset = function () { t = [], i = null, n = null, s ? this.clearParsedCaptions() : s = { captions: [], captionStreams: {}, logs: [] }, this.resetCaptionStream() }, this.reset() }, hi = function (e) { for (var t = 0, i = String.fromCharCode(e[t]), n = ""; "\0" !== i;)n += i, t++, i = String.fromCharCode(e[t]); return n + i }, ci = V.getUint64, pi = function (e) { return void 0 !== e || null !== e }, mi = { parseEmsgBox: function (e) { var t, i, n, s, a, r, o, d = 4, u = e[0]; if (0 === u) d += (t = hi(e.subarray(d))).length, d += (i = hi(e.subarray(d))).length, n = (l = new DataView(e.buffer)).getUint32(d), d += 4, a = l.getUint32(d), d += 4, r = l.getUint32(d), d += 4, o = l.getUint32(d), d += 4; else if (1 === u) { var l; n = (l = new DataView(e.buffer)).getUint32(d), d += 4, s = ci(e.subarray(d)), d += 8, r = l.getUint32(d), d += 4, o = l.getUint32(d), d += 4, d += (t = hi(e.subarray(d))).length, d += (i = hi(e.subarray(d))).length } var h = { scheme_id_uri: t, value: i, timescale: n || 1, presentation_time: s, presentation_time_delta: a, event_duration: r, id: o, message_data: new Uint8Array(e.subarray(d, e.byteLength)) }; return function (e, t) { var i = "\0" !== t.scheme_id_uri, n = 0 === e && pi(t.presentation_time_delta) && i, s = 1 === e && pi(t.presentation_time) && i; return !(e > 1) && n || s }(u, h) ? h : void 0 }, scaleTime: function (e, t, i, n) { return e || 0 === e ? e / t : n + i / t } }, fi = Ht, gi = function (e) { return ("00" + e.toString(16)).slice(-2) }, yi = Yt, _i = Xt, Ti = mi, bi = V.getUint64, Si = $t, vi = $e.parseId3Frames; qt = function (e, t) { var i = yi(t, ["moof", "traf"]).reduce((function (t, i) { var n, s = yi(i, ["tfhd"])[0], a = fi(s[4] << 24 | s[5] << 16 | s[6] << 8 | s[7]), r = e[a] || 9e4, o = yi(i, ["tfdt"])[0], d = new DataView(o.buffer, o.byteOffset, o.byteLength); let u; return "bigint" == typeof (n = 1 === o[0] ? bi(o.subarray(4, 12)) : d.getUint32(4)) ? u = n / Si.BigInt(r) : "number" != typeof n || isNaN(n) || (u = n / r), u < Number.MAX_SAFE_INTEGER && (u = Number(u)), u < t && (t = u), t }), 1 / 0); return "bigint" == typeof i || isFinite(i) ? i : 0 }, Wt = function (e) { var t = 0 === e[0] ? 12 : 20; return fi(e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) }, Gt = function (e) { var t = yi(e, ["moov", "trak"]), i = []; return t.forEach((function (e) { var t, n, s = {}, a = yi(e, ["tkhd"])[0]; a && (n = (t = new DataView(a.buffer, a.byteOffset, a.byteLength)).getUint8(0), s.id = 0 === n ? t.getUint32(12) : t.getUint32(20)); var r = yi(e, ["mdia", "hdlr"])[0]; if (r) { var o = _i(r.subarray(8, 12)); s.type = "vide" === o ? "video" : "soun" === o ? "audio" : o } var d = yi(e, ["mdia", "minf", "stbl", "stsd"])[0]; if (d) { var u = d.subarray(8); s.codec = _i(u.subarray(4, 8)); var l, h = yi(u, [s.codec])[0]; h && (/^[asm]vc[1-9]$/i.test(s.codec) ? (l = h.subarray(78), "avcC" === _i(l.subarray(4, 8)) && l.length > 11 ? (s.codec += ".", s.codec += gi(l[9]), s.codec += gi(l[10]), s.codec += gi(l[11])) : s.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(s.codec) ? (l = h.subarray(28), "esds" === _i(l.subarray(4, 8)) && l.length > 20 && 0 !== l[19] ? (s.codec += "." + gi(l[19]), s.codec += "." + gi(l[20] >>> 2 & 63).replace(/^0/, "")) : s.codec = "mp4a.40.2") : s.codec = s.codec.toLowerCase()) } var c = yi(e, ["mdia", "mdhd"])[0]; c && (s.timescale = Wt(c)), i.push(s) })), i }; var wi = qt, Ii = Gt, Ei = function (e, t = 0) { return yi(e, ["emsg"]).map((e => { var i = Ti.parseEmsgBox(new Uint8Array(e)), n = vi(i.message_data); return { cueTime: Ti.scaleTime(i.presentation_time, i.timescale, i.presentation_time_delta, t), duration: Ti.scaleTime(i.event_duration, i.timescale), frames: n } })) }, Ai = Le, Li = function (e) { var t = 31 & e[1]; return (t <<= 8) | e[2] }, Di = function (e) { return !!(64 & e[1]) }, xi = function (e) { var t = 0; return (48 & e[3]) >>> 4 > 1 && (t += e[4] + 1), t }, ki = function (e) { switch (e) { case 5: return "slice_layer_without_partitioning_rbsp_idr"; case 6: return "sei_rbsp"; case 7: return "seq_parameter_set_rbsp"; case 8: return "pic_parameter_set_rbsp"; case 9: return "access_unit_delimiter_rbsp"; default: return null } }, Oi = { parseType: function (e, t) { var i = Li(e); return 0 === i ? "pat" : i === t ? "pmt" : t ? "pes" : null }, parsePat: function (e) { var t = Di(e), i = 4 + xi(e); return t && (i += e[i] + 1), (31 & e[i + 10]) << 8 | e[i + 11] }, parsePmt: function (e) { var t = {}, i = Di(e), n = 4 + xi(e); if (i && (n += e[n] + 1), 1 & e[n + 5]) { var s; s = 3 + ((15 & e[n + 1]) << 8 | e[n + 2]) - 4; for (var a = 12 + ((15 & e[n + 10]) << 8 | e[n + 11]); a < s;) { var r = n + a; t[(31 & e[r + 1]) << 8 | e[r + 2]] = e[r], a += 5 + ((15 & e[r + 3]) << 8 | e[r + 4]) } return t } }, parsePayloadUnitStartIndicator: Di, parsePesType: function (e, t) { switch (t[Li(e)]) { case Ai.H264_STREAM_TYPE: return "video"; case Ai.ADTS_STREAM_TYPE: return "audio"; case Ai.METADATA_STREAM_TYPE: return "timed-metadata"; default: return null } }, parsePesTime: function (e) { if (!Di(e)) return null; var t = 4 + xi(e); if (t >= e.byteLength) return null; var i, n = null; return 192 & (i = e[t + 7]) && ((n = {}).pts = (14 & e[t + 9]) << 27 | (255 & e[t + 10]) << 20 | (254 & e[t + 11]) << 12 | (255 & e[t + 12]) << 5 | (254 & e[t + 13]) >>> 3, n.pts *= 4, n.pts += (6 & e[t + 13]) >>> 1, n.dts = n.pts, 64 & i && (n.dts = (14 & e[t + 14]) << 27 | (255 & e[t + 15]) << 20 | (254 & e[t + 16]) << 12 | (255 & e[t + 17]) << 5 | (254 & e[t + 18]) >>> 3, n.dts *= 4, n.dts += (6 & e[t + 18]) >>> 1)), n }, videoPacketContainsKeyFrame: function (e) { for (var t = 4 + xi(e), i = e.subarray(t), n = 0, s = 0, a = !1; s < i.byteLength - 3; s++)if (1 === i[s + 2]) { n = s + 5; break } for (; n < i.byteLength;)switch (i[n]) { case 0: if (0 !== i[n - 1]) { n += 2; break } if (0 !== i[n - 2]) { n++; break } s + 3 !== n - 2 && "slice_layer_without_partitioning_rbsp_idr" === ki(31 & i[s + 3]) && (a = !0); do { n++ } while (1 !== i[n] && n < i.length); s = n - 2, n += 3; break; case 1: if (0 !== i[n - 1] || 0 !== i[n - 2]) { n += 3; break } "slice_layer_without_partitioning_rbsp_idr" === ki(31 & i[s + 3]) && (a = !0), s = n - 2, n += 3; break; default: n += 3 }return i = i.subarray(s), n -= s, s = 0, i && i.byteLength > 3 && "slice_layer_without_partitioning_rbsp_idr" === ki(31 & i[s + 3]) && (a = !0), a } }, Pi = Le, Ci = Ce.handleRollover, Ui = {}; Ui.ts = Oi, Ui.aac = gt; var Ri = oe.ONE_SECOND_IN_TS, Mi = 188, Bi = 71, Ni = function (e, t, i) { for (var n, s, a, r, o = 0, d = Mi, u = !1; d <= e.byteLength;)if (e[o] !== Bi || e[d] !== Bi && d !== e.byteLength) o++, d++; else { if (n = e.subarray(o, d), "pes" === Ui.ts.parseType(n, t.pid) && (s = Ui.ts.parsePesType(n, t.table), a = Ui.ts.parsePayloadUnitStartIndicator(n), "audio" === s && a && (r = Ui.ts.parsePesTime(n)) && (r.type = "audio", i.audio.push(r), u = !0)), u) break; o += Mi, d += Mi } for (o = (d = e.byteLength) - Mi, u = !1; o >= 0;)if (e[o] !== Bi || e[d] !== Bi && d !== e.byteLength) o--, d--; else { if (n = e.subarray(o, d), "pes" === Ui.ts.parseType(n, t.pid) && (s = Ui.ts.parsePesType(n, t.table), a = Ui.ts.parsePayloadUnitStartIndicator(n), "audio" === s && a && (r = Ui.ts.parsePesTime(n)) && (r.type = "audio", i.audio.push(r), u = !0)), u) break; o -= Mi, d -= Mi } }, Fi = function (e, t, i) { for (var n, s, a, r, o, d, u, l = 0, h = Mi, c = !1, p = { data: [], size: 0 }; h < e.byteLength;)if (e[l] !== Bi || e[h] !== Bi) l++, h++; else { if (n = e.subarray(l, h), "pes" === Ui.ts.parseType(n, t.pid) && (s = Ui.ts.parsePesType(n, t.table), a = Ui.ts.parsePayloadUnitStartIndicator(n), "video" === s && (a && !c && (r = Ui.ts.parsePesTime(n)) && (r.type = "video", i.video.push(r), c = !0), !i.firstKeyFrame))) { if (a && 0 !== p.size) { for (o = new Uint8Array(p.size), d = 0; p.data.length;)u = p.data.shift(), o.set(u, d), d += u.byteLength; if (Ui.ts.videoPacketContainsKeyFrame(o)) { var m = Ui.ts.parsePesTime(o); m ? (i.firstKeyFrame = m, i.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.") } p.size = 0 } p.data.push(n), p.size += n.byteLength } if (c && i.firstKeyFrame) break; l += Mi, h += Mi } for (l = (h = e.byteLength) - Mi, c = !1; l >= 0;)if (e[l] !== Bi || e[h] !== Bi) l--, h--; else { if (n = e.subarray(l, h), "pes" === Ui.ts.parseType(n, t.pid) && (s = Ui.ts.parsePesType(n, t.table), a = Ui.ts.parsePayloadUnitStartIndicator(n), "video" === s && a && (r = Ui.ts.parsePesTime(n)) && (r.type = "video", i.video.push(r), c = !0)), c) break; l -= Mi, h -= Mi } }, $i = function (e, t) { var i; return i = Ui.aac.isLikelyAacData(e) ? function (e) { for (var t, i = !1, n = 0, s = null, a = null, r = 0, o = 0; e.length - o >= 3;) { switch (Ui.aac.parseType(e, o)) { case "timed-metadata": if (e.length - o < 10) { i = !0; break } if ((r = Ui.aac.parseId3TagSize(e, o)) > e.length) { i = !0; break } null === a && (t = e.subarray(o, o + r), a = Ui.aac.parseAacTimestamp(t)), o += r; break; case "audio": if (e.length - o < 7) { i = !0; break } if ((r = Ui.aac.parseAdtsSize(e, o)) > e.length) { i = !0; break } null === s && (t = e.subarray(o, o + r), s = Ui.aac.parseSampleRate(t)), n++, o += r; break; default: o++ }if (i) return null } if (null === s || null === a) return null; var d = Ri / s; return { audio: [{ type: "audio", dts: a, pts: a }, { type: "audio", dts: a + 1024 * n * d, pts: a + 1024 * n * d }] } }(e) : function (e) { var t = { pid: null, table: null }, i = {}; for (var n in function (e, t) { for (var i, n = 0, s = Mi; s < e.byteLength;)if (e[n] !== Bi || e[s] !== Bi) n++, s++; else { switch (i = e.subarray(n, s), Ui.ts.parseType(i, t.pid)) { case "pat": t.pid = Ui.ts.parsePat(i); break; case "pmt": var a = Ui.ts.parsePmt(i); t.table = t.table || {}, Object.keys(a).forEach((function (e) { t.table[e] = a[e] })) }n += Mi, s += Mi } }(e, t), t.table) if (t.table.hasOwnProperty(n)) switch (t.table[n]) { case Pi.H264_STREAM_TYPE: i.video = [], Fi(e, t, i), 0 === i.video.length && delete i.video; break; case Pi.ADTS_STREAM_TYPE: i.audio = [], Ni(e, t, i), 0 === i.audio.length && delete i.audio }return i }(e), i && (i.audio || i.video) ? (function (e, t) { if (e.audio && e.audio.length) { var i = t; (void 0 === i || isNaN(i)) && (i = e.audio[0].dts), e.audio.forEach((function (e) { e.dts = Ci(e.dts, i), e.pts = Ci(e.pts, i), e.dtsTime = e.dts / Ri, e.ptsTime = e.pts / Ri })) } if (e.video && e.video.length) { var n = t; if ((void 0 === n || isNaN(n)) && (n = e.video[0].dts), e.video.forEach((function (e) { e.dts = Ci(e.dts, n), e.pts = Ci(e.pts, n), e.dtsTime = e.dts / Ri, e.ptsTime = e.pts / Ri })), e.firstKeyFrame) { var s = e.firstKeyFrame; s.dts = Ci(s.dts, n), s.pts = Ci(s.pts, n), s.dtsTime = s.dts / Ri, s.ptsTime = s.pts / Ri } } }(i, t), i) : null }; class qi { constructor(e, t) { this.options = t || {}, this.self = e, this.init() } init() { this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new Vt.Transmuxer(this.options), function (e, t) { t.on("data", (function (t) { const i = t.initSegment; t.initSegment = { data: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength }; const n = t.data; t.data = n.buffer, e.postMessage({ action: "data", segment: t, byteOffset: n.byteOffset, byteLength: n.byteLength }, [t.data]) })), t.on("done", (function (t) { e.postMessage({ action: "done" }) })), t.on("gopInfo", (function (t) { e.postMessage({ action: "gopInfo", gopInfo: t }) })), t.on("videoSegmentTimingInfo", (function (t) { const i = { start: { decode: oe.videoTsToSeconds(t.start.dts), presentation: oe.videoTsToSeconds(t.start.pts) }, end: { decode: oe.videoTsToSeconds(t.end.dts), presentation: oe.videoTsToSeconds(t.end.pts) }, baseMediaDecodeTime: oe.videoTsToSeconds(t.baseMediaDecodeTime) }; t.prependedContentDuration && (i.prependedContentDuration = oe.videoTsToSeconds(t.prependedContentDuration)), e.postMessage({ action: "videoSegmentTimingInfo", videoSegmentTimingInfo: i }) })), t.on("audioSegmentTimingInfo", (function (t) { const i = { start: { decode: oe.videoTsToSeconds(t.start.dts), presentation: oe.videoTsToSeconds(t.start.pts) }, end: { decode: oe.videoTsToSeconds(t.end.dts), presentation: oe.videoTsToSeconds(t.end.pts) }, baseMediaDecodeTime: oe.videoTsToSeconds(t.baseMediaDecodeTime) }; t.prependedContentDuration && (i.prependedContentDuration = oe.videoTsToSeconds(t.prependedContentDuration)), e.postMessage({ action: "audioSegmentTimingInfo", audioSegmentTimingInfo: i }) })), t.on("id3Frame", (function (t) { e.postMessage({ action: "id3Frame", id3Frame: t }) })), t.on("caption", (function (t) { e.postMessage({ action: "caption", caption: t }) })), t.on("trackinfo", (function (t) { e.postMessage({ action: "trackinfo", trackInfo: t }) })), t.on("audioTimingInfo", (function (t) { e.postMessage({ action: "audioTimingInfo", audioTimingInfo: { start: oe.videoTsToSeconds(t.start), end: oe.videoTsToSeconds(t.end) } }) })), t.on("videoTimingInfo", (function (t) { e.postMessage({ action: "videoTimingInfo", videoTimingInfo: { start: oe.videoTsToSeconds(t.start), end: oe.videoTsToSeconds(t.end) } }) })), t.on("log", (function (t) { e.postMessage({ action: "log", log: t }) })) }(this.self, this.transmuxer) } pushMp4Captions(e) { this.captionParser || (this.captionParser = new li, this.captionParser.init()); const t = new Uint8Array(e.data, e.byteOffset, e.byteLength), i = this.captionParser.parse(t, e.trackIds, e.timescales); this.self.postMessage({ action: "mp4Captions", captions: i && i.captions || [], logs: i && i.logs || [], data: t.buffer }, [t.buffer]) } probeMp4StartTime({ timescales: e, data: t }) { const i = wi(e, t); this.self.postMessage({ action: "probeMp4StartTime", startTime: i, data: t }, [t.buffer]) } probeMp4Tracks({ data: e }) { const t = Ii(e); this.self.postMessage({ action: "probeMp4Tracks", tracks: t, data: e }, [e.buffer]) } probeEmsgID3({ data: e, offset: t }) { const i = Ei(e, t); this.self.postMessage({ action: "probeEmsgID3", id3Frames: i, emsgData: e }, [e.buffer]) } probeTs({ data: e, baseStartTime: t }) { const i = "number" != typeof t || isNaN(t) ? void 0 : t * oe.ONE_SECOND_IN_TS, n = $i(e, i); let s = null; n && (s = { hasVideo: n.video && 2 === n.video.length || !1, hasAudio: n.audio && 2 === n.audio.length || !1 }, s.hasVideo && (s.videoStart = n.video[0].ptsTime), s.hasAudio && (s.audioStart = n.audio[0].ptsTime)), this.self.postMessage({ action: "probeTs", result: s, data: e }, [e.buffer]) } clearAllMp4Captions() { this.captionParser && this.captionParser.clearAllCaptions() } clearParsedMp4Captions() { this.captionParser && this.captionParser.clearParsedCaptions() } push(e) { const t = new Uint8Array(e.data, e.byteOffset, e.byteLength); this.transmuxer.push(t) } reset() { this.transmuxer.reset() } setTimestampOffset(e) { const t = e.timestampOffset || 0; this.transmuxer.setBaseMediaDecodeTime(Math.round(oe.secondsToVideoTs(t))) } setAudioAppendStart(e) { this.transmuxer.setAudioAppendStart(Math.ceil(oe.secondsToVideoTs(e.appendStart))) } setRemux(e) { this.transmuxer.setRemux(e.remux) } flush(e) { this.transmuxer.flush(), self.postMessage({ action: "done", type: "transmuxed" }) } endTimeline() { this.transmuxer.endTimeline(), self.postMessage({ action: "endedtimeline", type: "transmuxed" }) } alignGopsWith(e) { this.transmuxer.alignGopsWith(e.gopsToAlignWith.slice()) } } self.onmessage = function (e) { "init" === e.data.action && e.data.options ? this.messageHandlers = new qi(self, e.data.options) : (this.messageHandlers || (this.messageHandlers = new qi(self)), e.data && e.data.action && "init" !== e.data.action && this.messageHandlers[e.data.action] && this.messageHandlers[e.data.action](e.data)) } }))); var yi = pi(gi); const _i = e => { const { transmuxer: t, bytes: i, audioAppendStart: n, gopsToAlignWith: s, remux: a, onData: r, onTrackInfo: o, onAudioTimingInfo: d, onVideoTimingInfo: u, onVideoSegmentTimingInfo: l, onAudioSegmentTimingInfo: h, onId3: c, onCaptions: p, onDone: m, onEndedTimeline: f, onTransmuxerLog: g, isEndOfTimeline: y } = e, _ = { buffer: [] }; let T = y; if (t.onmessage = i => { t.currentTransmux === e && ("data" === i.data.action && ((e, t, i) => { const { type: n, initSegment: s, captions: a, captionStreams: r, metadata: o, videoFrameDtsTime: d, videoFramePtsTime: u } = e.data.segment; t.buffer.push({ captions: a, captionStreams: r, metadata: o }); const l = e.data.segment.boxes || { data: e.data.segment.data }, h = { type: n, data: new Uint8Array(l.data, l.data.byteOffset, l.data.byteLength), initSegment: new Uint8Array(s.data, s.byteOffset, s.byteLength) }; void 0 !== d && (h.videoFrameDtsTime = d), void 0 !== u && (h.videoFramePtsTime = u), i(h) })(i, _, r), "trackinfo" === i.data.action && o(i.data.trackInfo), "gopInfo" === i.data.action && ((e, t) => { t.gopInfo = e.data.gopInfo })(i, _), "audioTimingInfo" === i.data.action && d(i.data.audioTimingInfo), "videoTimingInfo" === i.data.action && u(i.data.videoTimingInfo), "videoSegmentTimingInfo" === i.data.action && l(i.data.videoSegmentTimingInfo), "audioSegmentTimingInfo" === i.data.action && h(i.data.audioSegmentTimingInfo), "id3Frame" === i.data.action && c([i.data.id3Frame], i.data.id3Frame.dispatchType), "caption" === i.data.action && p(i.data.caption), "endedtimeline" === i.data.action && (T = !1, f()), "log" === i.data.action && g(i.data.log), "transmuxed" === i.data.type && (T || (t.onmessage = null, (({ transmuxedData: e, callback: t }) => { e.buffer = [], t(e) })({ transmuxedData: _, callback: m }), Ti(t)))) }, n && t.postMessage({ action: "setAudioAppendStart", appendStart: n }), Array.isArray(s) && t.postMessage({ action: "alignGopsWith", gopsToAlignWith: s }), void 0 !== a && t.postMessage({ action: "setRemux", remux: a }), i.byteLength) { const e = i instanceof ArrayBuffer ? i : i.buffer, n = i instanceof ArrayBuffer ? 0 : i.byteOffset; t.postMessage({ action: "push", data: e, byteOffset: n, byteLength: i.byteLength }, [e]) } y && t.postMessage({ action: "endTimeline" }), t.postMessage({ action: "flush" }) }, Ti = e => { e.currentTransmux = null, e.transmuxQueue.length && (e.currentTransmux = e.transmuxQueue.shift(), "function" == typeof e.currentTransmux ? e.currentTransmux() : _i(e.currentTransmux)) }, bi = (e, t) => { e.postMessage({ action: t }), Ti(e) }; var Si = e => { ((e, t) => { if (!t.currentTransmux) return t.currentTransmux = e, void bi(t, e); t.transmuxQueue.push(bi.bind(null, t, e)) })("reset", e) }; const vi = function (e) { const t = e.transmuxer, i = e.endAction || e.action, n = e.callback, s = c({}, e, { endAction: null, transmuxer: null, callback: null }), a = s => { s.data.action === i && (t.removeEventListener("message", a), s.data.data && (s.data.data = new Uint8Array(s.data.data, e.byteOffset || 0, e.byteLength || s.data.data.byteLength), e.data && (e.data = s.data.data)), n(s.data)) }; if (t.addEventListener("message", a), e.data) { const i = e.data instanceof ArrayBuffer; s.byteOffset = i ? 0 : e.data.byteOffset, s.byteLength = e.data.byteLength; const n = [i ? e.data : e.data.buffer]; t.postMessage(s, n) } else t.postMessage(s) }, wi = -101, Ii = -102, Ei = e => { e.forEach((e => { e.abort() })) }, Ai = (e, t) => t.timedout ? { status: t.status, message: "HLS request timed-out at URL: " + t.uri, code: wi, xhr: t } : t.aborted ? { status: t.status, message: "HLS request aborted at URL: " + t.uri, code: Ii, xhr: t } : e ? { status: t.status, message: "HLS request errored at URL: " + t.uri, code: 2, xhr: t } : "arraybuffer" === t.responseType && 0 === t.response.byteLength ? { status: t.status, message: "Empty HLS response at URL: " + t.uri, code: 2, xhr: t } : null, Li = (e, t, i) => (n, s) => { const a = s.response, r = Ai(n, s); if (r) return i(r, e); if (16 !== a.byteLength) return i({ status: s.status, message: "Invalid HLS key at URL: " + s.uri, code: 2, xhr: s }, e); const o = new DataView(a), d = new Uint32Array([o.getUint32(0), o.getUint32(4), o.getUint32(8), o.getUint32(12)]); for (let e = 0; e < t.length; e++)t[e].bytes = d; return i(null, e) }, Di = (e, t) => { const i = ni(e.map.bytes); if ("mp4" !== i) { const n = e.map.resolvedUri || e.map.uri; return t({ internal: !0, message: `Found unsupported ${i || "unknown"} container for initialization segment at URL: ${n}`, code: 2 }) } vi({ action: "probeMp4Tracks", data: e.map.bytes, transmuxer: e.transmuxer, callback: ({ tracks: i, data: n }) => (e.map.bytes = n, i.forEach((function (t) { e.map.tracks = e.map.tracks || {}, e.map.tracks[t.type] || (e.map.tracks[t.type] = t, "number" == typeof t.id && t.timescale && (e.map.timescales = e.map.timescales || {}, e.map.timescales[t.id] = t.timescale)) })), t(null)) }) }, xi = ({ segment: e, bytes: t, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) => { const p = e.map && e.map.tracks || {}, m = Boolean(p.audio && p.video); let f = n.bind(null, e, "audio", "start"); const g = n.bind(null, e, "audio", "end"); let y = n.bind(null, e, "video", "start"); const _ = n.bind(null, e, "video", "end"); vi({ action: "probeTs", transmuxer: e.transmuxer, data: t, baseStartTime: e.baseStartTime, callback: n => { e.bytes = t = n.data; const p = n.result; p && (i(e, { hasAudio: p.hasAudio, hasVideo: p.hasVideo, isMuxed: m }), i = null, p.hasAudio && !m && f(p.audioStart), p.hasVideo && y(p.videoStart), f = null, y = null), (e => { if (!e.transmuxer.currentTransmux) return e.transmuxer.currentTransmux = e, void _i(e); e.transmuxer.transmuxQueue.push(e) })({ bytes: t, transmuxer: e.transmuxer, audioAppendStart: e.audioAppendStart, gopsToAlignWith: e.gopsToAlignWith, remux: m, onData: t => { t.type = "combined" === t.type ? "video" : t.type, l(e, t) }, onTrackInfo: t => { i && (m && (t.isMuxed = !0), i(e, t)) }, onAudioTimingInfo: e => { f && void 0 !== e.start && (f(e.start), f = null), g && void 0 !== e.end && g(e.end) }, onVideoTimingInfo: e => { y && void 0 !== e.start && (y(e.start), y = null), _ && void 0 !== e.end && _(e.end) }, onVideoSegmentTimingInfo: e => { s(e) }, onAudioSegmentTimingInfo: e => { a(e) }, onId3: (t, i) => { r(e, t, i) }, onCaptions: t => { o(e, [t]) }, isEndOfTimeline: d, onEndedTimeline: () => { u() }, onTransmuxerLog: c, onDone: t => { h && (t.type = "combined" === t.type ? "video" : t.type, h(null, e, t)) } }) } }) }, ki = ({ segment: e, bytes: t, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) => { let p = new Uint8Array(t); if (function (e) { return qt(e, ["moof"]).length > 0 }(p)) { e.isFmp4 = !0; const { tracks: s } = e.map, a = { isFmp4: !0, hasVideo: !!s.video, hasAudio: !!s.audio }; s.audio && s.audio.codec && "enca" !== s.audio.codec && (a.audioCodec = s.audio.codec), s.video && s.video.codec && "encv" !== s.video.codec && (a.videoCodec = s.video.codec), s.video && s.audio && (a.isMuxed = !0), i(e, a); const d = (t, i) => { l(e, { data: p, type: a.hasAudio && !a.isMuxed ? "audio" : "video" }), i && i.length && r(e, i), t && t.length && o(e, t), h(null, e, {}) }; vi({ action: "probeMp4StartTime", timescales: e.map.timescales, data: p, transmuxer: e.transmuxer, callback: ({ data: i, startTime: r }) => { t = i.buffer, e.bytes = p = i, a.hasAudio && !a.isMuxed && n(e, "audio", "start", r), a.hasVideo && n(e, "video", "start", r), vi({ action: "probeEmsgID3", data: p, transmuxer: e.transmuxer, offset: r, callback: ({ emsgData: n, id3Frames: a }) => { t = n.buffer, e.bytes = p = n, s.video && i.byteLength && e.transmuxer ? vi({ action: "pushMp4Captions", endAction: "mp4Captions", transmuxer: e.transmuxer, data: p, timescales: e.map.timescales, trackIds: [s.video.id], callback: i => { t = i.data.buffer, e.bytes = p = i.data, i.logs.forEach((function (e) { c(C(e, { stream: "mp4CaptionParser" })) })), d(i.captions, a) } }) : d(void 0, a) } }) } }) } else if (e.transmuxer) { if (void 0 === e.container && (e.container = ni(p)), "ts" !== e.container && "aac" !== e.container) return i(e, { hasAudio: !1, hasVideo: !1 }), void h(null, e, {}); xi({ segment: e, bytes: t, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) } else h(null, e, {}) }, Oi = function ({ id: e, key: t, encryptedBytes: i, decryptionWorker: n }, s) { const a = t => { if (t.data.source === e) { n.removeEventListener("message", a); const e = t.data.decrypted; s(new Uint8Array(e.bytes, e.byteOffset, e.byteLength)) } }; let r; n.addEventListener("message", a), r = t.bytes.slice ? t.bytes.slice() : new Uint32Array(Array.prototype.slice.call(t.bytes)), n.postMessage(qe({ source: e, encrypted: i, key: r, iv: t.iv }), [i.buffer, r.buffer]) }, Pi = ({ xhr: e, xhrOptions: t, decryptionWorker: i, segment: n, abortFn: s, progressFn: a, trackInfoFn: r, timingInfoFn: o, videoSegmentTimingInfoFn: d, audioSegmentTimingInfoFn: u, id3Fn: l, captionsFn: h, isEndOfTimeline: c, endedTimelineFn: p, dataFn: m, doneFn: f, onTransmuxerLog: g }) => { const y = [], _ = (({ activeXhrs: e, decryptionWorker: t, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) => { let p = 0, m = !1; return (f, g) => { if (!m) { if (f) return m = !0, Ei(e), h(f, g); if (p += 1, p === e.length) { const p = function () { if (g.encryptedBytes) return (({ decryptionWorker: e, segment: t, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) => { Oi({ id: t.requestId, key: t.key, encryptedBytes: t.encryptedBytes, decryptionWorker: e }, (e => { t.bytes = e, ki({ segment: t, bytes: t.bytes, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) })) })({ decryptionWorker: t, segment: g, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }); ki({ segment: g, bytes: g.bytes, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l, doneFn: h, onTransmuxerLog: c }) }; if (g.endOfAllRequests = Date.now(), g.map && g.map.encryptedBytes && !g.map.bytes) return Oi({ decryptionWorker: t, id: g.requestId + "-init", encryptedBytes: g.map.encryptedBytes, key: g.map.key }, (t => { g.map.bytes = t, Di(g, (t => { if (t) return Ei(e), h(t, g); p() })) })); p() } } } })({ activeXhrs: y, decryptionWorker: i, trackInfoFn: r, timingInfoFn: o, videoSegmentTimingInfoFn: d, audioSegmentTimingInfoFn: u, id3Fn: l, captionsFn: h, isEndOfTimeline: c, endedTimelineFn: p, dataFn: m, doneFn: f, onTransmuxerLog: g }); if (n.key && !n.key.bytes) { const i = [n.key]; n.map && !n.map.bytes && n.map.key && n.map.key.resolvedUri === n.key.resolvedUri && i.push(n.map.key); const s = e(C(t, { uri: n.key.resolvedUri, responseType: "arraybuffer" }), Li(n, i, _)); y.push(s) } if (n.map && !n.map.bytes) { if (n.map.key && (!n.key || n.key.resolvedUri !== n.map.key.resolvedUri)) { const i = e(C(t, { uri: n.map.key.resolvedUri, responseType: "arraybuffer" }), Li(n, [n.map.key], _)); y.push(i) } const i = C(t, { uri: n.map.resolvedUri, responseType: "arraybuffer", headers: Ee(n.map) }), s = (({ segment: e, finishProcessingFn: t }) => (i, n) => { const s = Ai(i, n); if (s) return t(s, e); const a = new Uint8Array(n.response); if (e.map.key) return e.map.encryptedBytes = a, t(null, e); e.map.bytes = a, Di(e, (function (i) { if (i) return i.xhr = n, i.status = n.status, t(i, e); t(null, e) })) })({ segment: n, finishProcessingFn: _ }), a = e(i, s); y.push(a) } const T = C(t, { uri: n.part && n.part.resolvedUri || n.resolvedUri, responseType: "arraybuffer", headers: Ee(n) }), b = e(T, (({ segment: e, finishProcessingFn: t, responseType: i }) => (n, s) => { const a = Ai(n, s); if (a) return t(a, e); const r = "arraybuffer" !== i && s.responseText ? (e => { const t = new Uint8Array(new ArrayBuffer(e.length)); for (let i = 0; i < e.length; i++)t[i] = e.charCodeAt(i); return t.buffer })(s.responseText.substring(e.lastReachedChar || 0)) : s.response; return e.stats = (e => ({ bandwidth: e.bandwidth, bytesReceived: e.bytesReceived || 0, roundTripTime: e.roundTripTime || 0 }))(s), e.key ? e.encryptedBytes = new Uint8Array(r) : e.bytes = new Uint8Array(r), t(null, e) })({ segment: n, finishProcessingFn: _, responseType: T.responseType })); b.addEventListener("progress", (({ segment: e, progressFn: t, trackInfoFn: i, timingInfoFn: n, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: r, captionsFn: o, isEndOfTimeline: d, endedTimelineFn: u, dataFn: l }) => i => { if (!i.target.aborted) return e.stats = C(e.stats, (e => { const t = e.target, i = { bandwidth: 1 / 0, bytesReceived: 0, roundTripTime: Date.now() - t.requestTime || 0 }; return i.bytesReceived = e.loaded, i.bandwidth = Math.floor(i.bytesReceived / i.roundTripTime * 8 * 1e3), i })(i)), !e.stats.firstBytesReceivedAt && e.stats.bytesReceived && (e.stats.firstBytesReceivedAt = Date.now()), t(i, e) })({ segment: n, progressFn: a, trackInfoFn: r, timingInfoFn: o, videoSegmentTimingInfoFn: d, audioSegmentTimingInfoFn: u, id3Fn: l, captionsFn: h, isEndOfTimeline: c, endedTimelineFn: p, dataFn: m })), y.push(b); const S = {}; return y.forEach((e => { e.addEventListener("loadend", (({ loadendState: e, abortFn: t }) => i => { i.target.aborted && t && !e.calledAbortFn && (t(), e.calledAbortFn = !0) })({ loadendState: S, abortFn: s })) })), () => Ei(y) }, Ci = h("CodecUtils"), Ui = (e, t) => { const i = t.attributes || {}; return e && e.mediaGroups && e.mediaGroups.AUDIO && i.AUDIO && e.mediaGroups.AUDIO[i.AUDIO] }, Ri = function (e) { const t = {}; return e.forEach((({ mediaType: e, type: i, details: n }) => { t[e] = t[e] || [], t[e].push(A(`${i}${n}`)) })), Object.keys(t).forEach((function (e) { if (t[e].length > 1) return Ci(`multiple ${e} codecs found as attributes: ${t[e].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`), void (t[e] = null); t[e] = t[e][0] })), t }, Mi = function (e) { let t = 0; return e.audio && t++, e.video && t++, t }, Bi = function (e, t) { const i = t.attributes || {}, n = Ri(function (e) { const t = e.attributes || {}; if (t.CODECS) return L(t.CODECS) }(t) || []); if (Ui(e, t) && !n.audio && !((e, t) => { if (!Ui(e, t)) return !0; const i = t.attributes || {}, n = e.mediaGroups.AUDIO[i.AUDIO]; for (const e in n) if (!n[e].uri && !n[e].playlists) return !0; return !1 })(e, t)) { const t = Ri(function (e, t) { if (!e.mediaGroups.AUDIO || !t) return null; var i = e.mediaGroups.AUDIO[t]; if (!i) return null; for (var n in i) { var s = i[n]; if (s.default && s.playlists) return L(s.playlists[0].attributes.CODECS) } return null }(e, i.AUDIO) || []); t.audio && (n.audio = t.audio) } return n }, Ni = h("PlaylistSelector"), Fi = function (e) { if (!e || !e.playlist) return; const t = e.playlist; return JSON.stringify({ id: t.id, bandwidth: e.bandwidth, width: e.width, height: e.height, codecs: t.attributes && t.attributes.CODECS || "" }) }, $i = function (e, t) { if (!e) return ""; const i = window.getComputedStyle(e); return i ? i[t] : "" }, qi = function (e, t) { const i = e.slice(); e.sort((function (e, n) { const s = t(e, n); return 0 === s ? i.indexOf(e) - i.indexOf(n) : s })) }, Gi = function (e, t) { let i, n; return e.attributes.BANDWIDTH && (i = e.attributes.BANDWIDTH), i = i || window.Number.MAX_VALUE, t.attributes.BANDWIDTH && (n = t.attributes.BANDWIDTH), n = n || window.Number.MAX_VALUE, i - n }; let Wi = function (e, t, i, n, s, a) { if (!e) return; const r = { bandwidth: t, width: i, height: n, limitRenditionByPlayerDimensions: s }; let o = e.playlists; oe.isAudioOnly(e) && (o = a.getAudioTrackPlaylists_(), r.audioOnly = !0); let d = o.map((e => { let t; const i = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.width, n = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height; return t = e.attributes && e.attributes.BANDWIDTH, t = t || window.Number.MAX_VALUE, { bandwidth: t, width: i, height: n, playlist: e } })); qi(d, ((e, t) => e.bandwidth - t.bandwidth)), d = d.filter((e => !oe.isIncompatible(e.playlist))); let u = d.filter((e => oe.isEnabled(e.playlist))); u.length || (u = d.filter((e => !oe.isDisabled(e.playlist)))); const l = u.filter((e => e.bandwidth * hi.BANDWIDTH_VARIANCE < t)); let h = l[l.length - 1]; const c = l.filter((e => e.bandwidth === h.bandwidth))[0]; if (!1 === s) { const e = c || u[0] || d[0]; if (e && e.playlist) { let t = "sortedPlaylistReps"; return c && (t = "bandwidthBestRep"), u[0] && (t = "enabledPlaylistReps"), Ni(`choosing ${Fi(e)} using ${t} with options`, r), e.playlist } return Ni("could not choose a playlist with options", r), null } const p = l.filter((e => e.width && e.height)); qi(p, ((e, t) => e.width - t.width)); const m = p.filter((e => e.width === i && e.height === n)); h = m[m.length - 1]; const f = m.filter((e => e.bandwidth === h.bandwidth))[0]; let g, y, _, T; if (f || (g = p.filter((e => e.width > i || e.height > n)), y = g.filter((e => e.width === g[0].width && e.height === g[0].height)), h = y[y.length - 1], _ = y.filter((e => e.bandwidth === h.bandwidth))[0]), a.leastPixelDiffSelector) { const e = p.map((e => (e.pixelDiff = Math.abs(e.width - i) + Math.abs(e.height - n), e))); qi(e, ((e, t) => e.pixelDiff === t.pixelDiff ? t.bandwidth - e.bandwidth : e.pixelDiff - t.pixelDiff)), T = e[0] } const b = T || _ || f || c || u[0] || d[0]; if (b && b.playlist) { let e = "sortedPlaylistReps"; return T ? e = "leastPixelDiffRep" : _ ? e = "resolutionPlusOneRep" : f ? e = "resolutionBestRep" : c ? e = "bandwidthBestRep" : u[0] && (e = "enabledPlaylistReps"), Ni(`choosing ${Fi(b)} using ${e} with options`, r), b.playlist } return Ni("could not choose a playlist with options", r), null }; const Vi = function () { const e = this.useDevicePixelRatio && window.devicePixelRatio || 1; return Wi(this.playlists.main, this.systemBandwidth, parseInt($i(this.tech_.el(), "width"), 10) * e, parseInt($i(this.tech_.el(), "height"), 10) * e, this.limitRenditionByPlayerDimensions, this.playlistController_) }, Hi = function (e, t, i) { let n, s; if (i && i.cues) for (n = i.cues.length; n--;)s = i.cues[n], s.startTime >= e && s.endTime <= t && i.removeCue(s) }; var Xi = 9e4, ji = Xi; const zi = e => "number" == typeof e && isFinite(e), Yi = 1 / 60, Qi = e => { const { startOfSegment: t, duration: i, segment: n, part: s, playlist: { mediaSequence: a, id: r, segments: o = [] }, mediaIndex: d, partIndex: u, timeline: l } = e, h = o.length - 1; let c = "mediaIndex/partIndex increment"; e.getMediaInfoForTime ? c = `getMediaInfoForTime (${e.getMediaInfoForTime})` : e.isSyncRequest && (c = "getSyncSegmentCandidate (isSyncRequest)"), e.independent && (c += ` with independent ${e.independent}`); const p = "number" == typeof u, m = e.segment.uri ? "segment" : "pre-segment", f = p ? j({ preloadSegment: n }) - 1 : 0; return `${m} [${a + d}/${a + h}]` + (p ? ` part [${u}/${f}]` : "") + ` segment start/end [${n.start} => ${n.end}]` + (p ? ` part start/end [${s.start} => ${s.end}]` : "") + ` startOfSegment [${t}]` + ` duration [${i}]` + ` timeline [${l}]` + ` selected by [${c}]` + ` playlist [${r}]` }, Ki = e => `${e}TimingInfo`, Ji = ({ timelineChangeController: e, currentTimeline: t, segmentTimeline: i, loaderType: n, audioDisabled: s }) => { if (t === i) return !1; if ("audio" === n) { const t = e.lastTimelineChange({ type: "main" }); return !t || t.to !== i } if ("main" === n && s) { const t = e.pendingTimelineChange({ type: "audio" }); return !t || t.to !== i } return !1 }, Zi = ({ segmentDuration: e, maxDuration: t }) => !!e && Math.round(e) > t + R; class en extends s.default.EventTarget { constructor(e, t = {}) { if (super(), !e) throw new TypeError("Initialization settings are required"); if ("function" != typeof e.currentTime) throw new TypeError("No currentTime getter specified"); if (!e.mediaSource) throw new TypeError("No MediaSource specified"); this.bandwidth = e.bandwidth, this.throughput = { rate: 0, count: 0 }, this.roundTrip = NaN, this.resetStats_(), this.mediaIndex = null, this.partIndex = null, this.hasPlayed_ = e.hasPlayed, this.currentTime_ = e.currentTime, this.seekable_ = e.seekable, this.seeking_ = e.seeking, this.duration_ = e.duration, this.mediaSource_ = e.mediaSource, this.vhs_ = e.vhs, this.loaderType_ = e.loaderType, this.currentMediaInfo_ = void 0, this.startingMediaInfo_ = void 0, this.segmentMetadataTrack_ = e.segmentMetadataTrack, this.goalBufferLength_ = e.goalBufferLength, this.sourceType_ = e.sourceType, this.sourceUpdater_ = e.sourceUpdater, this.inbandTextTracks_ = e.inbandTextTracks, this.state_ = "INIT", this.timelineChangeController_ = e.timelineChangeController, this.shouldSaveSegmentTimingInfo_ = !0, this.parse708captions_ = e.parse708captions, this.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset, this.captionServices_ = e.captionServices, this.exactManifestTimings = e.exactManifestTimings, this.addMetadataToTextTrack = e.addMetadataToTextTrack, this.checkBufferTimeout_ = null, this.error_ = void 0, this.currentTimeline_ = -1, this.pendingSegment_ = null, this.xhrOptions_ = null, this.pendingSegments_ = [], this.audioDisabled_ = !1, this.isPendingTimestampOffset_ = !1, this.gopBuffer_ = [], this.timeMapping_ = 0, this.safeAppend_ = !1, this.appendInitSegment_ = { audio: !0, video: !0 }, this.playlistOfLastInitSegment_ = { audio: null, video: null }, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_ = { id3: [], caption: [] }, this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = null, this.activeInitSegmentId_ = null, this.initSegments_ = {}, this.cacheEncryptionKeys_ = e.cacheEncryptionKeys, this.keyCache_ = {}, this.decrypter_ = e.decrypter, this.syncController_ = e.syncController, this.syncPoint_ = { segmentIndex: 0, time: 0 }, this.transmuxer_ = this.createTransmuxer_(), this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"), this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_), this.mediaSource_.addEventListener("sourceopen", (() => { this.isEndOfStream_() || (this.ended_ = !1) })), this.fetchAtBuffer_ = !1, this.logger_ = h(`SegmentLoader[${this.loaderType_}]`), Object.defineProperty(this, "state", { get() { return this.state_ }, set(e) { e !== this.state_ && (this.logger_(`${this.state_} -> ${e}`), this.state_ = e, this.trigger("statechange")) } }), this.sourceUpdater_.on("ready", (() => { this.hasEnoughInfoToAppend_() && this.processCallQueue_() })), "main" === this.loaderType_ && this.timelineChangeController_.on("pendingtimelinechange", (() => { this.hasEnoughInfoToAppend_() && this.processCallQueue_() })), "audio" === this.loaderType_ && this.timelineChangeController_.on("timelinechange", (() => { this.hasEnoughInfoToLoad_() && this.processLoadQueue_(), this.hasEnoughInfoToAppend_() && this.processCallQueue_() })) } createTransmuxer_() { return (e => { const t = new yi; t.currentTransmux = null, t.transmuxQueue = []; const i = t.terminate; return t.terminate = () => (t.currentTransmux = null, t.transmuxQueue.length = 0, i.call(t)), t.postMessage({ action: "init", options: e }), t })({ remux: !1, alignGopsAtEnd: this.safeAppend_, keepOriginalTimestamps: !0, parse708captions: this.parse708captions_, captionServices: this.captionServices_ }) } resetStats_() { this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0 } dispose() { this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off() } setAudio(e) { this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_()) } abort() { "WAITING" === this.state ? (this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_()) : this.pendingSegment_ && (this.pendingSegment_ = null) } abort_() { this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, window.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null } checkForAbort_(e) { return "APPENDING" !== this.state || this.pendingSegment_ ? !this.pendingSegment_ || this.pendingSegment_.requestId !== e : (this.state = "READY", !0) } error(e) { return void 0 !== e && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_ } endOfStream() { this.ended_ = !0, this.transmuxer_ && Si(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended") } buffered_() { const e = this.getMediaInfo_(); if (!this.sourceUpdater_ || !e) return U(); if ("main" === this.loaderType_) { const { hasAudio: t, hasVideo: i, isMuxed: n } = e; if (i && t && !this.audioDisabled_ && !n) return this.sourceUpdater_.buffered(); if (i) return this.sourceUpdater_.videoBuffered() } return this.sourceUpdater_.audioBuffered() } initSegmentForMap(e, t = !1) { if (!e) return null; const i = Ge(e); let n = this.initSegments_[i]; return t && !n && e.bytes && (this.initSegments_[i] = n = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: e.bytes, tracks: e.tracks, timescales: e.timescales }), n || e } segmentKey(e, t = !1) { if (!e) return null; const i = We(e); let n = this.keyCache_[i]; this.cacheEncryptionKeys_ && t && !n && e.bytes && (this.keyCache_[i] = n = { resolvedUri: e.resolvedUri, bytes: e.bytes }); const s = { resolvedUri: (n || e).resolvedUri }; return n && (s.bytes = n.bytes), s } couldBeginLoading_() { return this.playlist_ && !this.paused() } load() { if (this.monitorBuffer_(), this.playlist_) return "INIT" === this.state && this.couldBeginLoading_() ? this.init_() : void (!this.couldBeginLoading_() || "READY" !== this.state && "INIT" !== this.state || (this.state = "READY")) } init_() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } playlist(e, t = {}) { if (!e) return; const i = this.playlist_, n = this.pendingSegment_; this.playlist_ = e, this.xhrOptions_ = t, "INIT" === this.state && (e.syncInfo = { mediaSequence: e.mediaSequence, time: 0 }, "main" === this.loaderType_ && this.syncController_.setDateTimeMappingForStart(e)); let s = null; if (i && (i.id ? s = i.id : i.uri && (s = i.uri)), this.logger_(`playlist update [${s} => ${e.id || e.uri}]`), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_(); if (!i || i.uri !== e.uri) return null !== this.mediaIndex && (e.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, void this.trigger("playlistupdate"); const a = e.mediaSequence - i.mediaSequence; if (this.logger_(`live window shift [${a}]`), null !== this.mediaIndex) if (this.mediaIndex -= a, this.mediaIndex < 0) this.mediaIndex = null, this.partIndex = null; else { const e = this.playlist_.segments[this.mediaIndex]; if (this.partIndex && (!e.parts || !e.parts.length || !e.parts[this.partIndex])) { const e = this.mediaIndex; this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`), this.resetLoader(), this.mediaIndex = e } } n && (n.mediaIndex -= a, n.mediaIndex < 0 ? (n.mediaIndex = null, n.partIndex = null) : (n.mediaIndex >= 0 && (n.segment = e.segments[n.mediaIndex]), n.partIndex >= 0 && n.segment.parts && (n.part = n.segment.parts[n.partIndex]))), this.syncController_.saveExpiredSegmentInfo(i, e) } pause() { this.checkBufferTimeout_ && (window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null) } paused() { return null === this.checkBufferTimeout_ } resetEverything(e) { this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = { audio: !0, video: !0 }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && (this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }), this.transmuxer_.postMessage({ action: "reset" })) } resetLoader() { this.fetchAtBuffer_ = !1, this.resyncLoader() } resyncLoader() { this.transmuxer_ && Si(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearParsedMp4Captions" }) } remove(e, t, i = (() => { }), n = !1) { if (t === 1 / 0 && (t = this.duration_()), t <= e) return void this.logger_("skipping remove because end ${end} is <= start ${start}"); if (!this.sourceUpdater_ || !this.getMediaInfo_()) return void this.logger_("skipping remove because no source updater or starting media info"); let s = 1; const a = () => { s--, 0 === s && i() }; !n && this.audioDisabled_ || (s++, this.sourceUpdater_.removeAudio(e, t, a)), (n || "main" === this.loaderType_) && (this.gopBuffer_ = ((e, t, i, n) => { const s = Math.ceil((t - n) * ji), a = Math.ceil((i - n) * ji), r = e.slice(); let o = e.length; for (; o-- && !(e[o].pts <= a);); if (-1 === o) return r; let d = o + 1; for (; d-- && !(e[d].pts <= s);); return d = Math.max(d, 0), r.splice(d, o - d + 1), r })(this.gopBuffer_, e, t, this.timeMapping_), s++, this.sourceUpdater_.removeVideo(e, t, a)); for (const i in this.inbandTextTracks_) Hi(e, t, this.inbandTextTracks_[i]); Hi(e, t, this.segmentMetadataTrack_), a() } monitorBuffer_() { this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1) } monitorBufferTick_() { "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 500) } fillBuffer_() { if (this.sourceUpdater_.updating()) return; const e = this.chooseNextRequest_(); e && ("number" == typeof e.timestampOffset && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline })), this.loadSegment_(e)) } isEndOfStream_(e = this.mediaIndex, t = this.playlist_, i = this.partIndex) { if (!t || !this.mediaSource_) return !1; const n = "number" == typeof e && t.segments[e], s = e + 1 === t.segments.length, a = !n || !n.parts || i + 1 === n.parts.length; return t.endList && "open" === this.mediaSource_.readyState && s && a } chooseNextRequest_() { const e = this.buffered_(), t = G(e) || 0, i = W(e, this.currentTime_()), n = !this.hasPlayed_() && i >= 1, s = i >= this.goalBufferLength_(), a = this.playlist_.segments; if (!a.length || n || s) return null; this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_()); const r = { partIndex: null, mediaIndex: null, startOfSegment: null, playlist: this.playlist_, isSyncRequest: Boolean(!this.syncPoint_) }; if (r.isSyncRequest) r.mediaIndex = function (e, t, i) { t = t || []; const n = []; let s = 0; for (let a = 0; a < t.length; a++) { const r = t[a]; if (e === r.timeline && (n.push(a), s += r.duration, s > i)) return a } return 0 === n.length ? 0 : n[n.length - 1] }(this.currentTimeline_, a, t); else if (null !== this.mediaIndex) { const e = a[this.mediaIndex], i = "number" == typeof this.partIndex ? this.partIndex : -1; r.startOfSegment = e.end ? e.end : t, e.parts && e.parts[i + 1] ? (r.mediaIndex = this.mediaIndex, r.partIndex = i + 1) : r.mediaIndex = this.mediaIndex + 1 } else { const { segmentIndex: e, startTime: i, partIndex: n } = oe.getMediaInfoForTime({ exactManifestTimings: this.exactManifestTimings, playlist: this.playlist_, currentTime: this.fetchAtBuffer_ ? t : this.currentTime_(), startingPartIndex: this.syncPoint_.partIndex, startingSegmentIndex: this.syncPoint_.segmentIndex, startTime: this.syncPoint_.time }); r.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${t}` : `currentTime ${this.currentTime_()}`, r.mediaIndex = e, r.startOfSegment = i, r.partIndex = n } const o = a[r.mediaIndex]; let d = o && "number" == typeof r.partIndex && o.parts && o.parts[r.partIndex]; if (!o || "number" == typeof r.partIndex && !d) return null; "number" != typeof r.partIndex && o.parts && (r.partIndex = 0, d = o.parts[0]); const u = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments; if (!i && d && !u && !d.independent) if (0 === r.partIndex) { const e = a[r.mediaIndex - 1], t = e.parts && e.parts.length && e.parts[e.parts.length - 1]; t && t.independent && (r.mediaIndex -= 1, r.partIndex = e.parts.length - 1, r.independent = "previous segment") } else o.parts[r.partIndex - 1].independent && (r.partIndex -= 1, r.independent = "previous part"); const l = this.mediaSource_ && "ended" === this.mediaSource_.readyState; return r.mediaIndex >= a.length - 1 && l && !this.seeking_() ? null : this.generateSegmentInfo_(r) } generateSegmentInfo_(e) { const { independent: t, playlist: i, mediaIndex: n, startOfSegment: s, isSyncRequest: a, partIndex: r, forceTimestampOffset: o, getMediaInfoForTime: d } = e, u = i.segments[n], l = "number" == typeof r && u.parts[r], h = { requestId: "segment-loader-" + Math.random(), uri: l && l.resolvedUri || u.resolvedUri, mediaIndex: n, partIndex: l ? r : null, isSyncRequest: a, startOfSegment: s, playlist: i, bytes: null, encryptedBytes: null, timestampOffset: null, timeline: u.timeline, duration: l && l.duration || u.duration, segment: u, part: l, byteLength: 0, transmuxer: this.transmuxer_, getMediaInfoForTime: d, independent: t }, c = void 0 !== o ? o : this.isPendingTimestampOffset_; h.timestampOffset = this.timestampOffsetForSegment_({ segmentTimeline: u.timeline, currentTimeline: this.currentTimeline_, startOfSegment: s, buffered: this.buffered_(), overrideCheck: c }); const p = G(this.sourceUpdater_.audioBuffered()); return "number" == typeof p && (h.audioAppendStart = p - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (h.gopsToAlignWith = ((e, t, i) => { if (null == t || !e.length) return []; const n = Math.ceil((t - i + 3) * ji); let s; for (s = 0; s < e.length && !(e[s].pts > n); s++); return e.slice(s) })(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)), h } timestampOffsetForSegment_(e) { return (({ segmentTimeline: e, currentTimeline: t, startOfSegment: i, buffered: n, overrideCheck: s }) => s || e !== t ? e < t ? i : n.length ? n.end(n.length - 1) : i : null)(e) } earlyAbortWhenNeeded_(e) { if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) return; if (Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3) return; const t = this.currentTime_(), i = e.bandwidth, n = this.pendingSegment_.duration, s = oe.estimateSegmentRequestTime(n, i, this.playlist_, e.bytesReceived), a = function (e, t, i = 1) { return ((e.length ? e.end(e.length - 1) : 0) - t) / i }(this.buffered_(), t, this.vhs_.tech_.playbackRate()) - 1; if (s <= a) return; const r = function (e) { const { main: t, currentTime: i, bandwidth: n, duration: s, segmentDuration: a, timeUntilRebuffer: r, currentTimeline: o, syncController: d } = e, u = t.playlists.filter((e => !oe.isIncompatible(e))); let l = u.filter(oe.isEnabled); l.length || (l = u.filter((e => !oe.isDisabled(e)))); const h = l.filter(oe.hasAttribute.bind(null, "BANDWIDTH")).map((e => { const t = d.getSyncPoint(e, s, o, i) ? 1 : 2; return { playlist: e, rebufferingImpact: oe.estimateSegmentRequestTime(a, n, e) * t - r } })), c = h.filter((e => e.rebufferingImpact <= 0)); return qi(c, ((e, t) => Gi(t.playlist, e.playlist))), c.length ? c[0] : (qi(h, ((e, t) => e.rebufferingImpact - t.rebufferingImpact)), h[0] || null) }({ main: this.vhs_.playlists.main, currentTime: t, bandwidth: i, duration: this.duration_(), segmentDuration: n, timeUntilRebuffer: a, currentTimeline: this.currentTimeline_, syncController: this.syncController_ }); if (!r) return; const o = s - a - r.rebufferingImpact; let d = .5; a <= R && (d = 1), !r.playlist || r.playlist.uri === this.playlist_.uri || o < d || (this.bandwidth = r.playlist.attributes.BANDWIDTH * hi.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort")) } handleAbort_(e) { this.logger_(`Aborting ${Qi(e)}`), this.mediaRequestsAborted += 1 } handleProgress_(e, t) { this.earlyAbortWhenNeeded_(t.stats), this.checkForAbort_(t.requestId) || this.trigger("progress") } handleTrackInfo_(e, t) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || this.checkForIllegalMediaSwitch(t) || (t = t || {}, function (e, t) { if (!e && !t || !e && t || e && !t) return !1; if (e === t) return !0; const i = Object.keys(e).sort(), n = Object.keys(t).sort(); if (i.length !== n.length) return !1; for (let s = 0; s < i.length; s++) { const a = i[s]; if (a !== n[s]) return !1; if (e[a] !== t[a]) return !1 } return !0 }(this.currentMediaInfo_, t) || (this.appendInitSegment_ = { audio: !0, video: !0 }, this.startingMediaInfo_ = t, this.currentMediaInfo_ = t, this.logger_("trackinfo update", t), this.trigger("trackinfo")), this.checkForAbort_(e.requestId) || (this.pendingSegment_.trackInfo = t, this.hasEnoughInfoToAppend_() && this.processCallQueue_())) } handleTimingInfo_(e, t, i, n) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; const s = this.pendingSegment_, a = Ki(t); s[a] = s[a] || {}, s[a][i] = n, this.logger_(`timinginfo: ${t} - ${i} - ${n}`), this.hasEnoughInfoToAppend_() && this.processCallQueue_() } handleCaptions_(e, t) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; if (0 === t.length) return void this.logger_("SegmentLoader received no captions from a caption event"); if (!this.pendingSegment_.hasAppendedData_) return void this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, e, t)); const i = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), n = {}; t.forEach((e => { n[e.stream] = n[e.stream] || { startTime: 1 / 0, captions: [], endTime: 0 }; const t = n[e.stream]; t.startTime = Math.min(t.startTime, e.startTime + i), t.endTime = Math.max(t.endTime, e.endTime + i), t.captions.push(e) })), Object.keys(n).forEach((e => { const { startTime: t, endTime: s, captions: a } = n[e], r = this.inbandTextTracks_; this.logger_(`adding cues from ${t} -> ${s} for ${e}`), function (e, t, i) { if (!e[i]) { t.trigger({ type: "usage", name: "vhs-608" }); let n = i; /^cc708_/.test(i) && (n = "SERVICE" + i.split("_")[1]); const s = t.textTracks().getTrackById(n); if (s) e[i] = s; else { let s = i, a = i, r = !1; const o = (t.options_.vhs && t.options_.vhs.captionServices || {})[n]; o && (s = o.label, a = o.language, r = o.default), e[i] = t.addRemoteTextTrack({ kind: "captions", id: n, default: r, label: s, language: a }, !1).track } } }(r, this.vhs_.tech_, e), Hi(t, s, r[e]), function ({ inbandTextTracks: e, captionArray: t, timestampOffset: i }) { if (!t) return; const n = window.WebKitDataCue || window.VTTCue; t.forEach((t => { const s = t.stream; e[s].addCue(new n(t.startTime + i, t.endTime + i, t.text)) })) }({ captionArray: a, inbandTextTracks: r, timestampOffset: i }) })), this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearParsedMp4Captions" }) } handleId3_(e, t, i) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || (this.pendingSegment_.hasAppendedData_ ? this.addMetadataToTextTrack(i, t, this.duration_()) : this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, t, i))) } processMetadataQueue_() { this.metadataQueue_.id3.forEach((e => e())), this.metadataQueue_.caption.forEach((e => e())), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [] } processCallQueue_() { const e = this.callQueue_; this.callQueue_ = [], e.forEach((e => e())) } processLoadQueue_() { const e = this.loadQueue_; this.loadQueue_ = [], e.forEach((e => e())) } hasEnoughInfoToLoad_() { if ("audio" !== this.loaderType_) return !0; const e = this.pendingSegment_; return !(!e || this.getCurrentMediaInfo_() && Ji({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) } getCurrentMediaInfo_(e = this.pendingSegment_) { return e && e.trackInfo || this.currentMediaInfo_ } getMediaInfo_(e = this.pendingSegment_) { return this.getCurrentMediaInfo_(e) || this.startingMediaInfo_ } getPendingSegmentPlaylist() { return this.pendingSegment_ ? this.pendingSegment_.playlist : null } hasEnoughInfoToAppend_() { if (!this.sourceUpdater_.ready()) return !1; if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return !1; const e = this.pendingSegment_, t = this.getCurrentMediaInfo_(); if (!e || !t) return !1; const { hasAudio: i, hasVideo: n, isMuxed: s } = t; return !(n && !e.videoTimingInfo || i && !this.audioDisabled_ && !s && !e.audioTimingInfo || Ji({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) } handleData_(e, t) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) return void this.callQueue_.push(this.handleData_.bind(this, e, t)); const i = this.pendingSegment_; if (this.setTimeMapping_(i.timeline), this.updateMediaSecondsLoaded_(i.part || i.segment), "closed" !== this.mediaSource_.readyState) { if (e.map && (e.map = this.initSegmentForMap(e.map, !0), i.segment.map = e.map), e.key && this.segmentKey(e.key, !0), i.isFmp4 = e.isFmp4, i.timingInfo = i.timingInfo || {}, i.isFmp4) this.trigger("fmp4"), i.timingInfo.start = i[Ki(t.type)].start; else { const e = this.getCurrentMediaInfo_(), t = "main" === this.loaderType_ && e && e.hasVideo; let n; t && (n = i.videoTimingInfo.start), i.timingInfo.start = this.trueSegmentStart_({ currentStart: i.timingInfo.start, playlist: i.playlist, mediaIndex: i.mediaIndex, currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(), useVideoTimingInfo: t, firstVideoFrameTimeForData: n, videoTimingInfo: i.videoTimingInfo, audioTimingInfo: i.audioTimingInfo }) } if (this.updateAppendInitSegmentStatus(i, t.type), this.updateSourceBufferTimestampOffset_(i), i.isSyncRequest) { this.updateTimingInfoEnd_(i), this.syncController_.saveSegmentTimingInfo({ segmentInfo: i, shouldSaveTimelineMapping: "main" === this.loaderType_ }); const e = this.chooseNextRequest_(); if (e.mediaIndex !== i.mediaIndex || e.partIndex !== i.partIndex) return void this.logger_("sync segment was incorrect, not appending"); this.logger_("sync segment was correct, appending") } i.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(i, t) } } updateAppendInitSegmentStatus(e, t) { "main" !== this.loaderType_ || "number" != typeof e.timestampOffset || e.changedTimestampOffset || (this.appendInitSegment_ = { audio: !0, video: !0 }), this.playlistOfLastInitSegment_[t] !== e.playlist && (this.appendInitSegment_[t] = !0) } getInitSegmentAndUpdateState_({ type: e, initSegment: t, map: i, playlist: n }) { if (i) { const e = Ge(i); if (this.activeInitSegmentId_ === e) return null; t = this.initSegmentForMap(i, !0).bytes, this.activeInitSegmentId_ = e } return t && this.appendInitSegment_[e] ? (this.playlistOfLastInitSegment_[e] = n, this.appendInitSegment_[e] = !1, this.activeInitSegmentId_ = null, t) : null } handleQuotaExceededError_({ segmentInfo: e, type: t, bytes: i }, n) { const s = this.sourceUpdater_.audioBuffered(), a = this.sourceUpdater_.videoBuffered(); s.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + q(s).join(", ")), a.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + q(a).join(", ")); const r = s.length ? s.start(0) : 0, o = s.length ? s.end(s.length - 1) : 0, d = a.length ? a.start(0) : 0, u = a.length ? a.end(a.length - 1) : 0; if (o - r <= 1 && u - d <= 1) return this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${i.byteLength}, audio buffer: ${q(s).join(", ")}, video buffer: ${q(a).join(", ")}, `), this.error({ message: "Quota exceeded error with append of a single segment of content", excludeUntil: 1 / 0 }), void this.trigger("error"); this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, { segmentInfo: e, type: t, bytes: i })); const l = this.currentTime_() - 1; this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${l}`), this.remove(0, l, (() => { this.logger_("On QUOTA_EXCEEDED_ERR, retrying append in 1s"), this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = window.setTimeout((() => { this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), this.quotaExceededErrorRetryTimeout_ = null, this.processCallQueue_() }), 1e3) }), !0) } handleAppendError_({ segmentInfo: e, type: t, bytes: i }, n) { n && (22 !== n.code ? (this.logger_("Received non QUOTA_EXCEEDED_ERR on append", n), this.error(`${t} append of ${i.length}b failed for segment #${e.mediaIndex} in playlist ${e.playlist.id}`), this.trigger("appenderror")) : this.handleQuotaExceededError_({ segmentInfo: e, type: t, bytes: i })) } appendToSourceBuffer_({ segmentInfo: e, type: t, initSegment: i, data: n, bytes: s }) { if (!s) { const e = [n]; let t = n.byteLength; i && (e.unshift(i), t += i.byteLength), s = (e => { let t, i = 0; return e.bytes && (t = new Uint8Array(e.bytes), e.segments.forEach((e => { t.set(e, i), i += e.byteLength }))), t })({ bytes: t, segments: e }) } this.sourceUpdater_.appendBuffer({ segmentInfo: e, type: t, bytes: s }, this.handleAppendError_.bind(this, { segmentInfo: e, type: t, bytes: s })) } handleSegmentTimingInfo_(e, t, i) { if (!this.pendingSegment_ || t !== this.pendingSegment_.requestId) return; const n = this.pendingSegment_.segment, s = `${e}TimingInfo`; n[s] || (n[s] = {}), n[s].transmuxerPrependedSeconds = i.prependedContentDuration || 0, n[s].transmuxedPresentationStart = i.start.presentation, n[s].transmuxedDecodeStart = i.start.decode, n[s].transmuxedPresentationEnd = i.end.presentation, n[s].transmuxedDecodeEnd = i.end.decode, n[s].baseMediaDecodeTime = i.baseMediaDecodeTime } appendData_(e, t) { const { type: i, data: n } = t; if (!n || !n.byteLength) return; if ("audio" === i && this.audioDisabled_) return; const s = this.getInitSegmentAndUpdateState_({ type: i, initSegment: t.initSegment, playlist: e.playlist, map: e.isFmp4 ? e.segment.map : null }); this.appendToSourceBuffer_({ segmentInfo: e, type: i, initSegment: s, data: n }) } loadSegment_(e) { this.state = "WAITING", this.pendingSegment_ = e, this.trimBackBuffer_(e), "number" == typeof e.timestampOffset && this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }), this.hasEnoughInfoToLoad_() ? this.updateTransmuxerAndRequestSegment_(e) : this.loadQueue_.push((() => { const t = c({}, e, { forceTimestampOffset: !0 }); c(e, this.generateSegmentInfo_(t)), this.isPendingTimestampOffset_ = !1, this.updateTransmuxerAndRequestSegment_(e) })) } updateTransmuxerAndRequestSegment_(e) { this.shouldUpdateTransmuxerTimestampOffset_(e.timestampOffset) && (this.gopBuffer_.length = 0, e.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({ action: "reset" }), this.transmuxer_.postMessage({ action: "setTimestampOffset", timestampOffset: e.timestampOffset })); const t = this.createSimplifiedSegmentObj_(e), i = this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex), n = null !== this.mediaIndex, s = e.timeline !== this.currentTimeline_ && e.timeline > 0, a = i || n && s; this.logger_(`Requesting ${Qi(e)}`), t.map && !t.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = { video: !0, audio: !0 }), e.abortRequests = Pi({ xhr: this.vhs_.xhr, xhrOptions: this.xhrOptions_, decryptionWorker: this.decrypter_, segment: t, abortFn: this.handleAbort_.bind(this, e), progressFn: this.handleProgress_.bind(this), trackInfoFn: this.handleTrackInfo_.bind(this), timingInfoFn: this.handleTimingInfo_.bind(this), videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", e.requestId), audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", e.requestId), captionsFn: this.handleCaptions_.bind(this), isEndOfTimeline: a, endedTimelineFn: () => { this.logger_("received endedtimeline callback") }, id3Fn: this.handleId3_.bind(this), dataFn: this.handleData_.bind(this), doneFn: this.segmentRequestFinished_.bind(this), onTransmuxerLog: ({ message: t, level: i, stream: n }) => { this.logger_(`${Qi(e)} logged from transmuxer stream ${n} as a ${i}: ${t}`) } }) } trimBackBuffer_(e) { const t = ((e, t, i) => { let n = t - hi.BACK_BUFFER_LENGTH; e.length && (n = Math.max(n, e.start(0))); const s = t - i; return Math.min(s, n) })(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); t > 0 && this.remove(0, t) } createSimplifiedSegmentObj_(e) { const t = e.segment, i = e.part, n = { resolvedUri: i ? i.resolvedUri : t.resolvedUri, byterange: i ? i.byterange : t.byterange, requestId: e.requestId, transmuxer: e.transmuxer, audioAppendStart: e.audioAppendStart, gopsToAlignWith: e.gopsToAlignWith, part: e.part }, s = e.playlist.segments[e.mediaIndex - 1]; if (s && s.timeline === t.timeline && (s.videoTimingInfo ? n.baseStartTime = s.videoTimingInfo.transmuxedDecodeEnd : s.audioTimingInfo && (n.baseStartTime = s.audioTimingInfo.transmuxedDecodeEnd)), t.key) { const i = t.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]); n.key = this.segmentKey(t.key), n.key.iv = i } return t.map && (n.map = this.initSegmentForMap(t.map)), n } saveTransferStats_(e) { this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime) } saveBandwidthRelatedStats_(e, t) { this.pendingSegment_.byteLength = t.bytesReceived, e < Yi ? this.logger_(`Ignoring segment's bandwidth because its duration of ${e} is less than the min to record 0.016666666666666666`) : (this.bandwidth = t.bandwidth, this.roundTrip = t.roundTripTime) } handleTimeout_() { this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout") } segmentRequestFinished_(e, t, i) { if (this.callQueue_.length) return void this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, t, i)); if (this.saveTransferStats_(t.stats), !this.pendingSegment_) return; if (t.requestId !== this.pendingSegment_.requestId) return; if (e) { if (this.pendingSegment_ = null, this.state = "READY", e.code === Ii) return; return this.pause(), e.code === wi ? void this.handleTimeout_() : (this.mediaRequestsErrored += 1, this.error(e), void this.trigger("error")) } const n = this.pendingSegment_; this.saveBandwidthRelatedStats_(n.duration, t.stats), n.endOfAllRequests = t.endOfAllRequests, i.gopInfo && (this.gopBuffer_ = ((e, t, i) => { if (!t.length) return e; if (i) return t.slice(); const n = t[0].pts; let s = 0; for (; s < e.length && !(e[s].pts >= n); s++); return e.slice(0, s).concat(t) })(this.gopBuffer_, i.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(n) } setTimeMapping_(e) { const t = this.syncController_.mappingForTimeline(e); null !== t && (this.timeMapping_ = t) } updateMediaSecondsLoaded_(e) { "number" == typeof e.start && "number" == typeof e.end ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration } shouldUpdateTransmuxerTimestampOffset_(e) { return null !== e && ("main" === this.loaderType_ && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset()) } trueSegmentStart_({ currentStart: e, playlist: t, mediaIndex: i, firstVideoFrameTimeForData: n, currentVideoTimestampOffset: s, useVideoTimingInfo: a, videoTimingInfo: r, audioTimingInfo: o }) { if (void 0 !== e) return e; if (!a) return o.start; const d = t.segments[i - 1]; return 0 !== i && d && void 0 !== d.start && d.end === n + s ? r.start : n } waitForAppendsToComplete_(e) { const t = this.getCurrentMediaInfo_(e); if (!t) return this.error({ message: "No starting media returned, likely due to an unsupported media format.", playlistExclusionDuration: 1 / 0 }), void this.trigger("error"); const { hasAudio: i, hasVideo: n, isMuxed: s } = t, a = "main" === this.loaderType_ && n, r = !this.audioDisabled_ && i && !s; if (e.waitingOnAppends = 0, !e.hasAppendedData_) return e.timingInfo || "number" != typeof e.timestampOffset || (this.isPendingTimestampOffset_ = !0), e.timingInfo = { start: 0 }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), void this.checkAppendsDone_(e); a && e.waitingOnAppends++, r && e.waitingOnAppends++, a && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), r && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e)) } checkAppendsDone_(e) { this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, 0 === e.waitingOnAppends && this.handleAppendsDone_()) } checkForIllegalMediaSwitch(e) { const t = ((e, t, i) => "main" === e && t && i ? i.hasAudio || i.hasVideo ? t.hasVideo && !i.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !t.hasVideo && i.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null)(this.loaderType_, this.getCurrentMediaInfo_(), e); return !!t && (this.error({ message: t, playlistExclusionDuration: 1 / 0 }), this.trigger("error"), !0) } updateSourceBufferTimestampOffset_(e) { if (null === e.timestampOffset || "number" != typeof e.timingInfo.start || e.changedTimestampOffset || "main" !== this.loaderType_) return; let t = !1; e.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: e.segment.videoTimingInfo, audioTimingInfo: e.segment.audioTimingInfo, timingInfo: e.timingInfo }), e.changedTimestampOffset = !0, e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset), t = !0), e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset), t = !0), t && this.trigger("timestampoffset") } getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: e, audioTimingInfo: t, timingInfo: i }) { return this.useDtsForTimestampOffset_ ? e && "number" == typeof e.transmuxedDecodeStart ? e.transmuxedDecodeStart : t && "number" == typeof t.transmuxedDecodeStart ? t.transmuxedDecodeStart : i.start : i.start } updateTimingInfoEnd_(e) { e.timingInfo = e.timingInfo || {}; const t = this.getMediaInfo_(), i = "main" === this.loaderType_ && t && t.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo; i && (e.timingInfo.end = "number" == typeof i.end ? i.end : i.start + e.duration) } handleAppendsDone_() { if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) return this.state = "READY", void (this.paused() || this.monitorBuffer_()); const e = this.pendingSegment_; this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({ segmentInfo: e, shouldSaveTimelineMapping: "main" === this.loaderType_ }); const t = ((e, t) => { if ("hls" !== t) return null; const i = (e => { let t = 0; return ["video", "audio"].forEach((function (i) { const n = e[`${i}TimingInfo`]; if (!n) return; const { start: s, end: a } = n; let r; "bigint" == typeof s || "bigint" == typeof a ? r = window.BigInt(a) - window.BigInt(s) : "number" == typeof s && "number" == typeof a && (r = a - s), void 0 !== r && r > t && (t = r) })), "bigint" == typeof t && t < Number.MAX_SAFE_INTEGER && (t = Number(t)), t })({ audioTimingInfo: e.audioTimingInfo, videoTimingInfo: e.videoTimingInfo }); if (!i) return null; const n = e.playlist.targetDuration, s = Zi({ segmentDuration: i, maxDuration: 2 * n }), a = Zi({ segmentDuration: i, maxDuration: n }), r = `Segment with index ${e.mediaIndex} from playlist ${e.playlist.id} has a duration of ${i} when the reported duration is ${e.duration} and the target duration is ${n}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`; return s || a ? { severity: s ? "warn" : "info", message: r } : null })(e, this.sourceType_); if (t && ("warn" === t.severity ? s.default.log.warn(t.message) : this.logger_(t.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", e.isSyncRequest && (this.trigger("syncinfoupdate"), !e.hasAppendedData_)) return void this.logger_(`Throwing away un-appended sync request ${Qi(e)}`); this.logger_(`Appended ${Qi(e)}`), this.addSegmentMetadataCue_(e), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline }), "main" !== this.loaderType_ || this.audioDisabled_ || this.timelineChangeController_.lastTimelineChange({ type: "audio", from: this.currentTimeline_, to: e.timeline })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate"); const i = e.segment, n = e.part, a = i.end && this.currentTime_() - i.end > 3 * e.playlist.targetDuration, r = n && n.end && this.currentTime_() - n.end > 3 * e.playlist.partTargetDuration; if (a || r) return this.logger_(`bad ${a ? "segment" : "part"} ${Qi(e)}`), void this.resetEverything(); null !== this.mediaIndex && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_() } recordThroughput_(e) { if (e.duration < Yi) return void this.logger_(`Ignoring segment's throughput because its duration of ${e.duration} is less than the min to record 0.016666666666666666`); const t = this.throughput.rate, i = Date.now() - e.endOfAllRequests + 1, n = Math.floor(e.byteLength / i * 8 * 1e3); this.throughput.rate += (n - t) / ++this.throughput.count } addSegmentMetadataCue_(e) { if (!this.segmentMetadataTrack_) return; const t = e.segment, i = t.start, n = t.end; if (!zi(i) || !zi(n)) return; Hi(i, n, this.segmentMetadataTrack_); const s = window.WebKitDataCue || window.VTTCue, a = { custom: t.custom, dateTimeObject: t.dateTimeObject, dateTimeString: t.dateTimeString, bandwidth: e.playlist.attributes.BANDWIDTH, resolution: e.playlist.attributes.RESOLUTION, codecs: e.playlist.attributes.CODECS, byteLength: e.byteLength, uri: e.uri, timeline: e.timeline, playlist: e.playlist.id, start: i, end: n }, r = new s(i, n, JSON.stringify(a)); r.value = a, this.segmentMetadataTrack_.addCue(r) } } function tn() { } const nn = function (e) { return "string" != typeof e ? e : e.replace(/./, (e => e.toUpperCase())) }, sn = ["video", "audio"], an = (e, t) => { const i = t[`${e}Buffer`]; return i && i.updating || t.queuePending[e] }, rn = (e, t) => { if (0 === t.queue.length) return; let i = 0, n = t.queue[i]; if ("mediaSource" !== n.type) { if ("mediaSource" !== e && t.ready() && "closed" !== t.mediaSource.readyState && !an(e, t)) { if (n.type !== e) { if (i = ((e, t) => { for (let i = 0; i < t.length; i++) { const n = t[i]; if ("mediaSource" === n.type) return null; if (n.type === e) return i } return null })(e, t.queue), null === i) return; n = t.queue[i] } return t.queue.splice(i, 1), t.queuePending[e] = n, n.action(e, t), n.doneFn ? void 0 : (t.queuePending[e] = null, void rn(e, t)) } } else t.updating() || "closed" === t.mediaSource.readyState || (t.queue.shift(), n.action(t), n.doneFn && n.doneFn(), rn("audio", t), rn("video", t)) }, on = (e, t) => { const i = t[`${e}Buffer`], n = nn(e); i && (i.removeEventListener("updateend", t[`on${n}UpdateEnd_`]), i.removeEventListener("error", t[`on${n}Error_`]), t.codecs[e] = null, t[`${e}Buffer`] = null) }, dn = (e, t) => e && t && -1 !== Array.prototype.indexOf.call(e.sourceBuffers, t), un = (e, t, i) => (n, s) => { const a = s[`${n}Buffer`]; if (dn(s.mediaSource, a)) { s.logger_(`Appending segment ${t.mediaIndex}'s ${e.length} bytes to ${n}Buffer`); try { a.appendBuffer(e) } catch (e) { s.logger_(`Error with code ${e.code} ` + (22 === e.code ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${t.mediaIndex} to ${n}Buffer`), s.queuePending[n] = null, i(e) } } }, ln = (e, t) => (i, n) => { const s = n[`${i}Buffer`]; if (dn(n.mediaSource, s)) { n.logger_(`Removing ${e} to ${t} from ${i}Buffer`); try { s.remove(e, t) } catch (s) { n.logger_(`Remove ${e} to ${t} from ${i}Buffer failed`) } } }, hn = e => (t, i) => { const n = i[`${t}Buffer`]; dn(i.mediaSource, n) && (i.logger_(`Setting ${t}timestampOffset to ${e}`), n.timestampOffset = e) }, cn = e => (t, i) => { e() }, pn = e => t => { if ("open" === t.mediaSource.readyState) { t.logger_(`Calling mediaSource endOfStream(${e || ""})`); try { t.mediaSource.endOfStream(e) } catch (e) { s.default.log.warn("Failed to call media source endOfStream", e) } } }, mn = e => t => { t.logger_(`Setting mediaSource duration to ${e}`); try { t.mediaSource.duration = e } catch (e) { s.default.log.warn("Failed to set media source duration", e) } }, fn = (e, t) => i => { const n = nn(e), s = x(t); i.logger_(`Adding ${e}Buffer with codec ${t} to mediaSource`); const a = i.mediaSource.addSourceBuffer(s); a.addEventListener("updateend", i[`on${n}UpdateEnd_`]), a.addEventListener("error", i[`on${n}Error_`]), i.codecs[e] = t, i[`${e}Buffer`] = a }, gn = e => t => { const i = t[`${e}Buffer`]; if (on(e, t), dn(t.mediaSource, i)) { t.logger_(`Removing ${e}Buffer with codec ${t.codecs[e]} from mediaSource`); try { t.mediaSource.removeSourceBuffer(i) } catch (t) { s.default.log.warn(`Failed to removeSourceBuffer ${e}Buffer`, t) } } }, yn = e => (t, i) => { const n = i[`${t}Buffer`], s = x(e); dn(i.mediaSource, n) && i.codecs[t] !== e && (i.logger_(`changing ${t}Buffer codec from ${i.codecs[t]} to ${e}`), n.changeType(s), i.codecs[t] = e) }, _n = ({ type: e, sourceUpdater: t, action: i, doneFn: n, name: s }) => { t.queue.push({ type: e, action: i, doneFn: n, name: s }), rn(e, t) }, Tn = (e, t) => i => { if (t.queuePending[e]) { const i = t.queuePending[e].doneFn; t.queuePending[e] = null, i && i(t[`${e}Error_`]) } rn(e, t) }; class bn extends s.default.EventTarget { constructor(e) { super(), this.mediaSource = e, this.sourceopenListener_ = () => rn("mediaSource", this), this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_), this.logger_ = h("SourceUpdater"), this.audioTimestampOffset_ = 0, this.videoTimestampOffset_ = 0, this.queue = [], this.queuePending = { audio: null, video: null }, this.delayedAudioAppendQueue_ = [], this.videoAppendQueued_ = !1, this.codecs = {}, this.onVideoUpdateEnd_ = Tn("video", this), this.onAudioUpdateEnd_ = Tn("audio", this), this.onVideoError_ = e => { this.videoError_ = e }, this.onAudioError_ = e => { this.audioError_ = e }, this.createdSourceBuffers_ = !1, this.initializedEme_ = !1, this.triggeredReady_ = !1 } initializedEme() { this.initializedEme_ = !0, this.triggerReady() } hasCreatedSourceBuffers() { return this.createdSourceBuffers_ } hasInitializedAnyEme() { return this.initializedEme_ } ready() { return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme() } createSourceBuffers(e) { this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady()) } triggerReady() { this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready")) } addSourceBuffer(e, t) { _n({ type: "mediaSource", sourceUpdater: this, action: fn(e, t), name: "addSourceBuffer" }) } abort(e) { _n({ type: e, sourceUpdater: this, action: (e, t) => { if ("open" !== t.mediaSource.readyState) return; const i = t[`${e}Buffer`]; if (dn(t.mediaSource, i)) { t.logger_(`calling abort on ${e}Buffer`); try { i.abort() } catch (t) { s.default.log.warn(`Failed to abort on ${e}Buffer`, t) } } }, name: "abort" }) } removeSourceBuffer(e) { this.canRemoveSourceBuffer() ? _n({ type: "mediaSource", sourceUpdater: this, action: gn(e), name: "removeSourceBuffer" }) : s.default.log.error("removeSourceBuffer is not supported!") } canRemoveSourceBuffer() { return !s.default.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && "function" == typeof window.MediaSource.prototype.removeSourceBuffer } static canChangeType() { return window.SourceBuffer && window.SourceBuffer.prototype && "function" == typeof window.SourceBuffer.prototype.changeType } canChangeType() { return this.constructor.canChangeType() } changeType(e, t) { this.canChangeType() ? _n({ type: e, sourceUpdater: this, action: yn(t), name: "changeType" }) : s.default.log.error("changeType is not supported!") } addOrChangeSourceBuffers(e) { if (!e || "object" != typeof e || 0 === Object.keys(e).length) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs"); Object.keys(e).forEach((t => { const i = e[t]; if (!this.hasCreatedSourceBuffers()) return this.addSourceBuffer(t, i); this.canChangeType() && this.changeType(t, i) })) } appendBuffer(e, t) { const { segmentInfo: i, type: n, bytes: s } = e; if (this.processedAppend_ = !0, "audio" === n && this.videoBuffer && !this.videoAppendQueued_) return this.delayedAudioAppendQueue_.push([e, t]), void this.logger_(`delayed audio append of ${s.length} until video append`); if (_n({ type: n, sourceUpdater: this, action: un(s, i || { mediaIndex: -1 }, t), doneFn: t, name: "appendBuffer" }), "video" === n) { if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length) return; const e = this.delayedAudioAppendQueue_.slice(); this.logger_(`queuing delayed audio ${e.length} appendBuffers`), this.delayedAudioAppendQueue_.length = 0, e.forEach((e => { this.appendBuffer.apply(this, e) })) } } audioBuffered() { return dn(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : U() } videoBuffered() { return dn(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : U() } buffered() { const e = dn(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, t = dn(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null; return t && !e ? this.audioBuffered() : e && !t ? this.videoBuffered() : function (e, t) { let i = null, n = null, s = 0; const a = [], r = []; if (!(e && e.length && t && t.length)) return U(); let o = e.length; for (; o--;)a.push({ time: e.start(o), type: "start" }), a.push({ time: e.end(o), type: "end" }); for (o = t.length; o--;)a.push({ time: t.start(o), type: "start" }), a.push({ time: t.end(o), type: "end" }); for (a.sort((function (e, t) { return e.time - t.time })), o = 0; o < a.length; o++)"start" === a[o].type ? (s++, 2 === s && (i = a[o].time)) : "end" === a[o].type && (s--, 1 === s && (n = a[o].time)), null !== i && null !== n && (r.push([i, n]), i = null, n = null); return U(r) }(this.audioBuffered(), this.videoBuffered()) } setDuration(e, t = tn) { _n({ type: "mediaSource", sourceUpdater: this, action: mn(e), name: "duration", doneFn: t }) } endOfStream(e = null, t = tn) { "string" != typeof e && (e = void 0), _n({ type: "mediaSource", sourceUpdater: this, action: pn(e), name: "endOfStream", doneFn: t }) } removeAudio(e, t, i = tn) { this.audioBuffered().length && 0 !== this.audioBuffered().end(0) ? _n({ type: "audio", sourceUpdater: this, action: ln(e, t), doneFn: i, name: "remove" }) : i() } removeVideo(e, t, i = tn) { this.videoBuffered().length && 0 !== this.videoBuffered().end(0) ? _n({ type: "video", sourceUpdater: this, action: ln(e, t), doneFn: i, name: "remove" }) : i() } updating() { return !(!an("audio", this) && !an("video", this)) } audioTimestampOffset(e) { return void 0 !== e && this.audioBuffer && this.audioTimestampOffset_ !== e && (_n({ type: "audio", sourceUpdater: this, action: hn(e), name: "timestampOffset" }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_ } videoTimestampOffset(e) { return void 0 !== e && this.videoBuffer && this.videoTimestampOffset !== e && (_n({ type: "video", sourceUpdater: this, action: hn(e), name: "timestampOffset" }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_ } audioQueueCallback(e) { this.audioBuffer && _n({ type: "audio", sourceUpdater: this, action: cn(e), name: "callback" }) } videoQueueCallback(e) { this.videoBuffer && _n({ type: "video", sourceUpdater: this, action: cn(e), name: "callback" }) } dispose() { this.trigger("dispose"), sn.forEach((e => { this.abort(e), this.canRemoveSourceBuffer() ? this.removeSourceBuffer(e) : this[`${e}QueueCallback`]((() => on(e, this))) })), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off() } } const Sn = e => decodeURIComponent(escape(String.fromCharCode.apply(null, e))), vn = new Uint8Array("\n\n".split("").map((e => e.charCodeAt(0)))); class wn extends Error { constructor() { super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.") } } class In extends en { constructor(e, t = {}) { super(e, t), this.mediaSource_ = null, this.subtitlesTrack_ = null, this.loaderType_ = "subtitle", this.featuresNativeTextTracks_ = e.featuresNativeTextTracks, this.loadVttJs = e.loadVttJs, this.shouldSaveSegmentTimingInfo_ = !1 } createTransmuxer_() { return null } buffered_() { if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) return U(); const e = this.subtitlesTrack_.cues; return U([[e[0].startTime, e[e.length - 1].startTime]]) } initSegmentForMap(e, t = !1) { if (!e) return null; const i = Ge(e); let n = this.initSegments_[i]; if (t && !n && e.bytes) { const t = vn.byteLength + e.bytes.byteLength, s = new Uint8Array(t); s.set(e.bytes), s.set(vn, e.bytes.byteLength), this.initSegments_[i] = n = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: s } } return n || e } couldBeginLoading_() { return this.playlist_ && this.subtitlesTrack_ && !this.paused() } init_() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } track(e) { return void 0 === e || (this.subtitlesTrack_ = e, "INIT" === this.state && this.couldBeginLoading_() && this.init_()), this.subtitlesTrack_ } remove(e, t) { Hi(e, t, this.subtitlesTrack_) } fillBuffer_() { const e = this.chooseNextRequest_(); if (e) { if (null === this.syncController_.timestampOffsetForTimeline(e.timeline)) { const e = () => { this.state = "READY", this.paused() || this.monitorBuffer_() }; return this.syncController_.one("timestampoffset", e), void (this.state = "WAITING_ON_TIMELINE") } this.loadSegment_(e) } } timestampOffsetForSegment_() { return null } chooseNextRequest_() { return this.skipEmptySegments_(super.chooseNextRequest_()) } skipEmptySegments_(e) { for (; e && e.segment.empty;) { if (e.mediaIndex + 1 >= e.playlist.segments.length) { e = null; break } e = this.generateSegmentInfo_({ playlist: e.playlist, mediaIndex: e.mediaIndex + 1, startOfSegment: e.startOfSegment + e.duration, isSyncRequest: e.isSyncRequest }) } return e } stopForError(e) { this.error(e), this.state = "READY", this.pause(), this.trigger("error") } segmentRequestFinished_(e, t, i) { if (!this.subtitlesTrack_) return void (this.state = "READY"); if (this.saveTransferStats_(t.stats), !this.pendingSegment_) return this.state = "READY", void (this.mediaRequestsAborted += 1); if (e) return e.code === wi && this.handleTimeout_(), e.code === Ii ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, void this.stopForError(e); const n = this.pendingSegment_; this.saveBandwidthRelatedStats_(n.duration, t.stats), t.key && this.segmentKey(t.key, !0), this.state = "APPENDING", this.trigger("appending"); const s = n.segment; if (s.map && (s.map.bytes = t.map.bytes), n.bytes = t.bytes, "function" != typeof window.WebVTT && "function" == typeof this.loadVttJs) return this.state = "WAITING_ON_VTTJS", void this.loadVttJs().then((() => this.segmentRequestFinished_(e, t, i)), (() => this.stopForError({ message: "Error loading vtt.js" }))); s.requested = !0; try { this.parseVTTCues_(n) } catch (e) { return void this.stopForError({ message: e.message }) } if (this.updateTimeMapping_(n, this.syncController_.timelines[n.timeline], this.playlist_), n.cues.length ? n.timingInfo = { start: n.cues[0].startTime, end: n.cues[n.cues.length - 1].endTime } : n.timingInfo = { start: n.startOfSegment, end: n.startOfSegment + n.duration }, n.isSyncRequest) return this.trigger("syncinfoupdate"), this.pendingSegment_ = null, void (this.state = "READY"); n.byteLength = n.bytes.byteLength, this.mediaSecondsLoaded += s.duration, n.cues.forEach((e => { this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window.VTTCue(e.startTime, e.endTime, e.text) : e) })), function (e) { const t = e.cues; if (!t) return; const i = {}; for (let n = t.length - 1; n >= 0; n--) { const s = t[n], a = `${s.startTime}-${s.endTime}-${s.text}`; i[a] ? e.removeCue(s) : i[a] = s } }(this.subtitlesTrack_), this.handleAppendsDone_() } handleData_() { } updateTimingInfoEnd_() { } parseVTTCues_(e) { let t, i = !1; if ("function" != typeof window.WebVTT) throw new wn; "function" == typeof window.TextDecoder ? t = new window.TextDecoder("utf8") : (t = window.WebVTT.StringDecoder(), i = !0); const n = new window.WebVTT.Parser(window, window.vttjs, t); if (e.cues = [], e.timestampmap = { MPEGTS: 0, LOCAL: 0 }, n.oncue = e.cues.push.bind(e.cues), n.ontimestampmap = t => { e.timestampmap = t }, n.onparsingerror = e => { s.default.log.warn("Error encountered when parsing cues: " + e.message) }, e.segment.map) { let t = e.segment.map.bytes; i && (t = Sn(t)), n.parse(t) } let a = e.bytes; i && (a = Sn(a)), n.parse(a), n.flush() } updateTimeMapping_(e, t, i) { const n = e.segment; if (!t) return; if (!e.cues.length) return void (n.empty = !0); const s = e.timestampmap, a = s.MPEGTS / ji - s.LOCAL + t.mapping; if (e.cues.forEach((e => { e.startTime += a, e.endTime += a })), !i.syncInfo) { const t = e.cues[0].startTime, s = e.cues[e.cues.length - 1].startTime; i.syncInfo = { mediaSequence: i.mediaSequence + e.mediaIndex, time: Math.min(t, s - n.duration) } } } } const En = function (e, t) { const i = e.cues; for (let e = 0; e < i.length; e++) { const n = i[e]; if (t >= n.adStartTime && t <= n.adEndTime) return n } return null }, An = [{ name: "VOD", run: (e, t, i, n, s) => i !== 1 / 0 ? { time: 0, segmentIndex: 0, partIndex: null } : null }, { name: "ProgramDateTime", run: (e, t, i, n, s) => { if (!Object.keys(e.timelineToDatetimeMappings).length) return null; let a = null, r = null; const o = H(t); s = s || 0; for (let i = 0; i < o.length; i++) { const n = o[t.endList || 0 === s ? i : o.length - (i + 1)], d = n.segment, u = e.timelineToDatetimeMappings[d.timeline]; if (!u || !d.dateTimeObject) continue; let l = d.dateTimeObject.getTime() / 1e3 + u; if (d.parts && "number" == typeof n.partIndex) for (let e = 0; e < n.partIndex; e++)l += d.parts[e].duration; const h = Math.abs(s - l); if (null !== r && (0 === h || r < h)) break; r = h, a = { time: l, segmentIndex: n.segmentIndex, partIndex: n.partIndex } } return a } }, { name: "Segment", run: (e, t, i, n, s) => { let a = null, r = null; s = s || 0; const o = H(t); for (let e = 0; e < o.length; e++) { const i = o[t.endList || 0 === s ? e : o.length - (e + 1)], d = i.segment, u = i.part && i.part.start || d && d.start; if (d.timeline === n && void 0 !== u) { const e = Math.abs(s - u); if (null !== r && r < e) break; (!a || null === r || r >= e) && (r = e, a = { time: u, segmentIndex: i.segmentIndex, partIndex: i.partIndex }) } } return a } }, { name: "Discontinuity", run: (e, t, i, n, s) => { let a = null; if (s = s || 0, t.discontinuityStarts && t.discontinuityStarts.length) { let i = null; for (let n = 0; n < t.discontinuityStarts.length; n++) { const r = t.discontinuityStarts[n], o = t.discontinuitySequence + n + 1, d = e.discontinuities[o]; if (d) { const e = Math.abs(s - d.time); if (null !== i && i < e) break; (!a || null === i || i >= e) && (i = e, a = { time: d.time, segmentIndex: r, partIndex: null }) } } } return a } }, { name: "Playlist", run: (e, t, i, n, s) => t.syncInfo ? { time: t.syncInfo.time, segmentIndex: t.syncInfo.mediaSequence - t.mediaSequence, partIndex: null } : null }]; class Ln extends s.default.EventTarget { constructor(e = {}) { super(), this.timelines = [], this.discontinuities = [], this.timelineToDatetimeMappings = {}, this.logger_ = h("SyncController") } getSyncPoint(e, t, i, n) { const s = this.runStrategies_(e, t, i, n); return s.length ? this.selectSyncPoint_(s, { key: "time", value: n }) : null } getExpiredTime(e, t) { if (!e || !e.segments) return null; const i = this.runStrategies_(e, t, e.discontinuitySequence, 0); if (!i.length) return null; const n = this.selectSyncPoint_(i, { key: "segmentIndex", value: 0 }); return n.segmentIndex > 0 && (n.time *= -1), Math.abs(n.time + K({ defaultDuration: e.targetDuration, durationList: e.segments, startIndex: n.segmentIndex, endIndex: 0 })) } runStrategies_(e, t, i, n) { const s = []; for (let a = 0; a < An.length; a++) { const r = An[a], o = r.run(this, e, t, i, n); o && (o.strategy = r.name, s.push({ strategy: r.name, syncPoint: o })) } return s } selectSyncPoint_(e, t) { let i = e[0].syncPoint, n = Math.abs(e[0].syncPoint[t.key] - t.value), s = e[0].strategy; for (let a = 1; a < e.length; a++) { const r = Math.abs(e[a].syncPoint[t.key] - t.value); r < n && (n = r, i = e[a].syncPoint, s = e[a].strategy) } return this.logger_(`syncPoint for [${t.key}: ${t.value}] chosen with strategy [${s}]: [time:${i.time}, segmentIndex:${i.segmentIndex}` + ("number" == typeof i.partIndex ? `,partIndex:${i.partIndex}` : "") + "]"), i } saveExpiredSegmentInfo(e, t) { const i = t.mediaSequence - e.mediaSequence; if (i > 86400) s.default.log.warn(`Not saving expired segment info. Media sequence gap ${i} is too large.`); else for (let n = i - 1; n >= 0; n--) { const i = e.segments[n]; if (i && void 0 !== i.start) { t.syncInfo = { mediaSequence: e.mediaSequence + n, time: i.start }, this.logger_(`playlist refresh sync: [time:${t.syncInfo.time}, mediaSequence: ${t.syncInfo.mediaSequence}]`), this.trigger("syncinfoupdate"); break } } } setDateTimeMappingForStart(e) { if (this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject) { const t = e.segments[0], i = t.dateTimeObject.getTime() / 1e3; this.timelineToDatetimeMappings[t.timeline] = -i } } saveSegmentTimingInfo({ segmentInfo: e, shouldSaveTimelineMapping: t }) { const i = this.calculateSegmentTimeMapping_(e, e.timingInfo, t), n = e.segment; i && (this.saveDiscontinuitySyncInfo_(e), e.playlist.syncInfo || (e.playlist.syncInfo = { mediaSequence: e.playlist.mediaSequence + e.mediaIndex, time: n.start })); const s = n.dateTimeObject; n.discontinuity && t && s && (this.timelineToDatetimeMappings[n.timeline] = -s.getTime() / 1e3) } timestampOffsetForTimeline(e) { return void 0 === this.timelines[e] ? null : this.timelines[e].time } mappingForTimeline(e) { return void 0 === this.timelines[e] ? null : this.timelines[e].mapping } calculateSegmentTimeMapping_(e, t, i) { const n = e.segment, s = e.part; let a, r, o = this.timelines[e.timeline]; if ("number" == typeof e.timestampOffset) o = { time: e.startOfSegment, mapping: e.startOfSegment - t.start }, i && (this.timelines[e.timeline] = o, this.trigger("timestampoffset"), this.logger_(`time mapping for timeline ${e.timeline}: [time: ${o.time}] [mapping: ${o.mapping}]`)), a = e.startOfSegment, r = t.end + o.mapping; else { if (!o) return !1; a = t.start + o.mapping, r = t.end + o.mapping } return s && (s.start = a, s.end = r), (!n.start || a < n.start) && (n.start = a), n.end = r, !0 } saveDiscontinuitySyncInfo_(e) { const t = e.playlist, i = e.segment; if (i.discontinuity) this.discontinuities[i.timeline] = { time: i.start, accuracy: 0 }; else if (t.discontinuityStarts && t.discontinuityStarts.length) for (let n = 0; n < t.discontinuityStarts.length; n++) { const s = t.discontinuityStarts[n], a = t.discontinuitySequence + n + 1, r = s - e.mediaIndex, o = Math.abs(r); if (!this.discontinuities[a] || this.discontinuities[a].accuracy > o) { let n; n = r < 0 ? i.start - K({ defaultDuration: t.targetDuration, durationList: t.segments, startIndex: e.mediaIndex, endIndex: s }) : i.end + K({ defaultDuration: t.targetDuration, durationList: t.segments, startIndex: e.mediaIndex + 1, endIndex: s }), this.discontinuities[a] = { time: n, accuracy: o } } } } dispose() { this.trigger("dispose"), this.off() } } class Dn extends s.default.EventTarget { constructor() { super(), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {} } clearPendingTimelineChange(e) { this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange") } pendingTimelineChange({ type: e, from: t, to: i }) { return "number" == typeof t && "number" == typeof i && (this.pendingTimelineChanges_[e] = { type: e, from: t, to: i }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[e] } lastTimelineChange({ type: e, from: t, to: i }) { return "number" == typeof t && "number" == typeof i && (this.lastTimelineChanges_[e] = { type: e, from: t, to: i }, delete this.pendingTimelineChanges_[e], this.trigger("timelinechange")), this.lastTimelineChanges_[e] } dispose() { this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off() } } const xn = mi(fi((function () {
    var e = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { if (!this.listeners[e]) return !1; var i = this.listeners[e].indexOf(t); return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(i, 1), i > -1 }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var i = t.length, n = 0; n < i; ++n)t[n].call(this, arguments[1]); else for (var s = Array.prototype.slice.call(arguments, 1), a = t.length, r = 0; r < a; ++r)t[r].apply(this, s) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (e) { this.on("data", (function (t) { e.push(t) })) }, e }();
/*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */let t = null; class i { constructor(e) { let i, n, s; t || (t = function () { const e = [[[], [], [], [], []], [[], [], [], [], []]], t = e[0], i = e[1], n = t[4], s = i[4]; let a, r, o; const d = [], u = []; let l, h, c, p, m, f; for (a = 0; a < 256; a++)u[(d[a] = a << 1 ^ 283 * (a >> 7)) ^ a] = a; for (r = o = 0; !n[r]; r ^= l || 1, o = u[o] || 1)for (p = o ^ o << 1 ^ o << 2 ^ o << 3 ^ o << 4, p = p >> 8 ^ 255 & p ^ 99, n[r] = p, s[p] = r, c = d[h = d[l = d[r]]], f = 16843009 * c ^ 65537 * h ^ 257 * l ^ 16843008 * r, m = 257 * d[p] ^ 16843008 * p, a = 0; a < 4; a++)t[a][r] = m = m << 24 ^ m >>> 8, i[a][p] = f = f << 24 ^ f >>> 8; for (a = 0; a < 5; a++)t[a] = t[a].slice(0), i[a] = i[a].slice(0); return e }()), this._tables = [[t[0][0].slice(), t[0][1].slice(), t[0][2].slice(), t[0][3].slice(), t[0][4].slice()], [t[1][0].slice(), t[1][1].slice(), t[1][2].slice(), t[1][3].slice(), t[1][4].slice()]]; const a = this._tables[0][4], r = this._tables[1], o = e.length; let d = 1; if (4 !== o && 6 !== o && 8 !== o) throw new Error("Invalid aes key size"); const u = e.slice(0), l = []; for (this._key = [u, l], i = o; i < 4 * o + 28; i++)s = u[i - 1], (i % o == 0 || 8 === o && i % o == 4) && (s = a[s >>> 24] << 24 ^ a[s >> 16 & 255] << 16 ^ a[s >> 8 & 255] << 8 ^ a[255 & s], i % o == 0 && (s = s << 8 ^ s >>> 24 ^ d << 24, d = d << 1 ^ 283 * (d >> 7))), u[i] = u[i - o] ^ s; for (n = 0; i; n++, i--)s = u[3 & n ? i : i - 4], l[n] = i <= 4 || n < 4 ? s : r[0][a[s >>> 24]] ^ r[1][a[s >> 16 & 255]] ^ r[2][a[s >> 8 & 255]] ^ r[3][a[255 & s]] } decrypt(e, t, i, n, s, a) { const r = this._key[1]; let o, d, u, l = e ^ r[0], h = n ^ r[1], c = i ^ r[2], p = t ^ r[3]; const m = r.length / 4 - 2; let f, g = 4; const y = this._tables[1], _ = y[0], T = y[1], b = y[2], S = y[3], v = y[4]; for (f = 0; f < m; f++)o = _[l >>> 24] ^ T[h >> 16 & 255] ^ b[c >> 8 & 255] ^ S[255 & p] ^ r[g], d = _[h >>> 24] ^ T[c >> 16 & 255] ^ b[p >> 8 & 255] ^ S[255 & l] ^ r[g + 1], u = _[c >>> 24] ^ T[p >> 16 & 255] ^ b[l >> 8 & 255] ^ S[255 & h] ^ r[g + 2], p = _[p >>> 24] ^ T[l >> 16 & 255] ^ b[h >> 8 & 255] ^ S[255 & c] ^ r[g + 3], g += 4, l = o, h = d, c = u; for (f = 0; f < 4; f++)s[(3 & -f) + a] = v[l >>> 24] << 24 ^ v[h >> 16 & 255] << 16 ^ v[c >> 8 & 255] << 8 ^ v[255 & p] ^ r[g++], o = l, l = h, h = c, c = p, p = o } } class n extends e { constructor() { super(e), this.jobs = [], this.delay = 1, this.timeout_ = null } processJob_() { this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null } push(e) { this.jobs.push(e), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay)) } } const s = function (e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 }; class a {
      constructor(e, t, i, r) {
        const o = a.STEP, d = new Int32Array(e.buffer), u = new Uint8Array(e.byteLength); let l = 0; for (this.asyncStream_ = new n, this.asyncStream_.push(this.decryptChunk_(d.subarray(l, l + o), t, i, u)), l = o; l < d.length; l += o)i = new Uint32Array([s(d[l - 4]), s(d[l - 3]), s(d[l - 2]), s(d[l - 1])]), this.asyncStream_.push(this.decryptChunk_(d.subarray(l, l + o), t, i, u)); this.asyncStream_.push((function () {
          var e;
/*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */r(null, (e = u).subarray(0, e.byteLength - e[e.byteLength - 1]))
        }))
      } static get STEP() { return 32e3 } decryptChunk_(e, t, n, a) { return function () { const r = function (e, t, n) { const a = new Int32Array(e.buffer, e.byteOffset, e.byteLength >> 2), r = new i(Array.prototype.slice.call(t)), o = new Uint8Array(e.byteLength), d = new Int32Array(o.buffer); let u, l, h, c, p, m, f, g, y; for (u = n[0], l = n[1], h = n[2], c = n[3], y = 0; y < a.length; y += 4)p = s(a[y]), m = s(a[y + 1]), f = s(a[y + 2]), g = s(a[y + 3]), r.decrypt(p, m, f, g, d, y), d[y] = s(d[y] ^ u), d[y + 1] = s(d[y + 1] ^ l), d[y + 2] = s(d[y + 2] ^ h), d[y + 3] = s(d[y + 3] ^ c), u = p, l = m, h = f, c = g; return o }(e, t, n); a.set(r, e.byteOffset) } }
    } var r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, o = ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : {}).BigInt || Number; o("0x1"), o("0x100"), o("0x10000"), o("0x1000000"), o("0x100000000"), o("0x10000000000"), o("0x1000000000000"), o("0x100000000000000"), o("0x10000000000000000"), function () { var e = new Uint16Array([65484]), t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength); 255 === t[0] || t[0] }(); self.onmessage = function (e) { const t = e.data, i = new Uint8Array(t.encrypted.bytes, t.encrypted.byteOffset, t.encrypted.byteLength), n = new Uint32Array(t.key.bytes, t.key.byteOffset, t.key.byteLength / 4), s = new Uint32Array(t.iv.bytes, t.iv.byteOffset, t.iv.byteLength / 4); new a(i, n, s, (function (e, i) { self.postMessage(function (e) { const t = {}; return Object.keys(e).forEach((i => { const n = e[i]; var s; s = n, ("function" === ArrayBuffer.isView ? ArrayBuffer.isView(s) : s && s.buffer instanceof ArrayBuffer) ? t[i] = { bytes: n.buffer, byteOffset: n.byteOffset, byteLength: n.byteLength } : t[i] = n })), t }({ source: t.source, decrypted: i }), [i.buffer]) })) }
  }))); var kn = pi(xn); const On = e => { let t = e.default ? "main" : "alternative"; return e.characteristics && e.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (t = "main-desc"), t }, Pn = (e, t) => { e.abort(), e.pause(), t && t.activePlaylistLoader && (t.activePlaylistLoader.pause(), t.activePlaylistLoader = null) }, Cn = (e, t) => { t.activePlaylistLoader = e, e.load() }, Un = { AUDIO: (e, t) => () => { const { segmentLoaders: { [e]: i }, mediaTypes: { [e]: n }, excludePlaylist: a } = t; Pn(i, n); const r = n.activeTrack(), o = n.activeGroup(), d = (o.filter((e => e.default))[0] || o[0]).id, u = n.tracks[d]; if (r !== u) { s.default.log.warn("Problem encountered loading the alternate audio track.Switching back to default."); for (const e in n.tracks) n.tracks[e].enabled = n.tracks[e] === u; n.onTrackChanged() } else a({ error: { message: "Problem encountered loading the default audio track." } }) }, SUBTITLES: (e, t) => () => { const { segmentLoaders: { [e]: i }, mediaTypes: { [e]: n } } = t; s.default.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track."), Pn(i, n); const a = n.activeTrack(); a && (a.mode = "disabled"), n.onTrackChanged() } }, Rn = { AUDIO: (e, t, i) => { if (!t) return; const { tech: n, requestOptions: s, segmentLoaders: { [e]: a } } = i; t.on("loadedmetadata", (() => { const e = t.media(); a.playlist(e, s), (!n.paused() || e.endList && "none" !== n.preload()) && a.load() })), t.on("loadedplaylist", (() => { a.playlist(t.media(), s), n.paused() || a.load() })), t.on("error", Un[e](e, i)) }, SUBTITLES: (e, t, i) => { const { tech: n, requestOptions: s, segmentLoaders: { [e]: a }, mediaTypes: { [e]: r } } = i; t.on("loadedmetadata", (() => { const e = t.media(); a.playlist(e, s), a.track(r.activeTrack()), (!n.paused() || e.endList && "none" !== n.preload()) && a.load() })), t.on("loadedplaylist", (() => { a.playlist(t.media(), s), n.paused() || a.load() })), t.on("error", Un[e](e, i)) } }, Mn = { AUDIO: (e, t) => { const { vhs: i, sourceType: n, segmentLoaders: { [e]: a }, requestOptions: r, main: { mediaGroups: o }, mediaTypes: { [e]: { groups: d, tracks: u, logger_: l } }, mainPlaylistLoader: h } = t, c = re(h.main); o[e] && 0 !== Object.keys(o[e]).length || (o[e] = { main: { default: { default: !0 } } }, c && (o[e].main.default.playlists = h.main.playlists)); for (const a in o[e]) { d[a] || (d[a] = []); for (const p in o[e][a]) { let m, f = o[e][a][p]; if (c ? (l(`AUDIO group '${a}' label '${p}' is a main playlist`), f.isMainPlaylist = !0, m = null) : m = "vhs-json" === n && f.playlists ? new Se(f.playlists[0], i, r) : f.resolvedUri ? new Se(f.resolvedUri, i, r) : f.playlists && "dash" === n ? new li(f.playlists[0], i, r, h) : null, f = C({ id: p, playlistLoader: m }, f), Rn[e](e, f.playlistLoader, t), d[a].push(f), void 0 === u[p]) { const e = new s.default.AudioTrack({ id: p, kind: On(f), enabled: !1, language: f.language, default: f.default, label: p }); u[p] = e } } } a.on("error", Un[e](e, t)) }, SUBTITLES: (e, t) => { const { tech: i, vhs: n, sourceType: s, segmentLoaders: { [e]: a }, requestOptions: r, main: { mediaGroups: o }, mediaTypes: { [e]: { groups: d, tracks: u } }, mainPlaylistLoader: l } = t; for (const a in o[e]) { d[a] || (d[a] = []); for (const h in o[e][a]) { if (!n.options_.useForcedSubtitles && o[e][a][h].forced) continue; let c, p = o[e][a][h]; if ("hls" === s) c = new Se(p.resolvedUri, n, r); else if ("dash" === s) { if (!p.playlists.filter((e => e.excludeUntil !== 1 / 0)).length) return; c = new li(p.playlists[0], n, r, l) } else "vhs-json" === s && (c = new Se(p.playlists ? p.playlists[0] : p.resolvedUri, n, r)); if (p = C({ id: h, playlistLoader: c }, p), Rn[e](e, p.playlistLoader, t), d[a].push(p), void 0 === u[h]) { const e = i.addRemoteTextTrack({ id: h, kind: "subtitles", default: p.default && p.autoselect, language: p.language, label: h }, !1).track; u[h] = e } } } a.on("error", Un[e](e, t)) }, "CLOSED-CAPTIONS": (e, t) => { const { tech: i, main: { mediaGroups: n }, mediaTypes: { [e]: { groups: s, tracks: a } } } = t; for (const t in n[e]) { s[t] || (s[t] = []); for (const r in n[e][t]) { const o = n[e][t][r]; if (!/^(?:CC|SERVICE)/.test(o.instreamId)) continue; const d = i.options_.vhs && i.options_.vhs.captionServices || {}; let u = { label: r, language: o.language, instreamId: o.instreamId, default: o.default && o.autoselect }; if (d[u.instreamId] && (u = C(u, d[u.instreamId])), void 0 === u.default && delete u.default, s[t].push(C({ id: r }, o)), void 0 === a[r]) { const e = i.addRemoteTextTrack({ id: u.instreamId, kind: "captions", default: u.default, language: u.language, label: u.label }, !1).track; a[r] = e } } } } }, Bn = (e, t) => { for (let i = 0; i < e.length; i++) { if (se(t, e[i])) return !0; if (e[i].playlists && Bn(e[i].playlists, t)) return !0 } return !1 }, Nn = { AUDIO: (e, t) => () => { const { mediaTypes: { [e]: { tracks: i } } } = t; for (const e in i) if (i[e].enabled) return i[e]; return null }, SUBTITLES: (e, t) => () => { const { mediaTypes: { [e]: { tracks: i } } } = t; for (const e in i) if ("showing" === i[e].mode || "hidden" === i[e].mode) return i[e]; return null } }; let Fn; const $n = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"], qn = function (e) { return this.audioSegmentLoader_[e] + this.mainSegmentLoader_[e] }; class Gn extends s.default.EventTarget { constructor(e) { super(); const { src: t, withCredentials: i, tech: n, bandwidth: s, externVhs: a, useCueTags: r, playlistExclusionDuration: o, enableLowInitialPlaylist: d, sourceType: u, cacheEncryptionKeys: l, bufferBasedABR: c, leastPixelDiffSelector: p, captionServices: m } = e; if (!t) throw new Error("A non-empty playlist URL or JSON manifest string is required"); let { maxPlaylistRetries: f } = e; null == f && (f = 1 / 0), Fn = a, this.bufferBasedABR = Boolean(c), this.leastPixelDiffSelector = Boolean(p), this.withCredentials = i, this.tech_ = n, this.vhs_ = n.vhs, this.sourceType_ = u, this.useCueTags_ = r, this.playlistExclusionDuration = o, this.maxPlaylistRetries = f, this.enableLowInitialPlaylist = d, this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"), this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), this.requestOptions_ = { withCredentials: i, maxPlaylistRetries: f, timeout: null }, this.on("error", this.pauseLoading), this.mediaTypes_ = (() => { const e = {}; return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((t => { e[t] = { groups: {}, tracks: {}, activePlaylistLoader: null, activeGroup: tn, activeTrack: tn, getActiveGroup: tn, onGroupChanged: tn, onTrackChanged: tn, lastTrack_: null, logger_: h(`MediaGroups[${t}]`) } })), e })(), this.mediaSource = new window.MediaSource, this.handleDurationChange_ = this.handleDurationChange_.bind(this), this.handleSourceOpen_ = this.handleSourceOpen_.bind(this), this.handleSourceEnded_ = this.handleSourceEnded_.bind(this), this.mediaSource.addEventListener("durationchange", this.handleDurationChange_), this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_), this.seekable_ = U(), this.hasPlayed_ = !1, this.syncController_ = new Ln(e), this.segmentMetadataTrack_ = n.addRemoteTextTrack({ kind: "metadata", label: "segment-metadata" }, !1).track, this.decrypter_ = new kn, this.sourceUpdater_ = new bn(this.mediaSource), this.inbandTextTracks_ = {}, this.timelineChangeController_ = new Dn; const g = { vhs: this.vhs_, parse708captions: e.parse708captions, useDtsForTimestampOffset: e.useDtsForTimestampOffset, captionServices: m, mediaSource: this.mediaSource, currentTime: this.tech_.currentTime.bind(this.tech_), seekable: () => this.seekable(), seeking: () => this.tech_.seeking(), duration: () => this.duration(), hasPlayed: () => this.hasPlayed_, goalBufferLength: () => this.goalBufferLength(), bandwidth: s, syncController: this.syncController_, decrypter: this.decrypter_, sourceType: this.sourceType_, inbandTextTracks: this.inbandTextTracks_, cacheEncryptionKeys: l, sourceUpdater: this.sourceUpdater_, timelineChangeController: this.timelineChangeController_, exactManifestTimings: e.exactManifestTimings, addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this) }; this.mainPlaylistLoader_ = "dash" === this.sourceType_ ? new li(t, this.vhs_, C(this.requestOptions_, { addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this) })) : new Se(t, this.vhs_, this.requestOptions_), this.setupMainPlaylistLoaderListeners_(), this.mainSegmentLoader_ = new en(C(g, { segmentMetadataTrack: this.segmentMetadataTrack_, loaderType: "main" }), e), this.audioSegmentLoader_ = new en(C(g, { loaderType: "audio" }), e), this.subtitleSegmentLoader_ = new In(C(g, { loaderType: "vtt", featuresNativeTextTracks: this.tech_.featuresNativeTextTracks, loadVttJs: () => new Promise(((e, t) => { function i() { n.off("vttjserror", s), e() } function s() { n.off("vttjsloaded", i), t() } n.one("vttjsloaded", i), n.one("vttjserror", s), n.addWebVttScript_() })) }), e), this.setupSegmentLoaderListeners_(), this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", (() => this.startABRTimer_())), this.tech_.on("pause", (() => this.stopABRTimer_())), this.tech_.on("play", (() => this.startABRTimer_()))), $n.forEach((e => { this[e + "_"] = qn.bind(this, e) })), this.logger_ = h("pc"), this.triggeredFmp4Usage = !1, "none" === this.tech_.preload() ? (this.loadOnPlay_ = () => { this.loadOnPlay_ = null, this.mainPlaylistLoader_.load() }, this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(), this.timeToLoadedData__ = -1, this.mainAppendsToLoadedData__ = -1, this.audioAppendsToLoadedData__ = -1; const y = "none" === this.tech_.preload() ? "play" : "loadstart"; this.tech_.one(y, (() => { const e = Date.now(); this.tech_.one("loadeddata", (() => { this.timeToLoadedData__ = Date.now() - e, this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends, this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends })) })) } mainAppendsToLoadedData_() { return this.mainAppendsToLoadedData__ } audioAppendsToLoadedData_() { return this.audioAppendsToLoadedData__ } appendsToLoadedData_() { const e = this.mainAppendsToLoadedData_(), t = this.audioAppendsToLoadedData_(); return -1 === e || -1 === t ? -1 : e + t } timeToLoadedData_() { return this.timeToLoadedData__ } checkABR_(e = "abr") { const t = this.selectPlaylist(); t && this.shouldSwitchToMedia_(t) && this.switchMedia_(t, e) } switchMedia_(e, t, i) { const n = this.media(), s = n && (n.id || n.uri), a = e.id || e.uri; s && s !== a && (this.logger_(`switch media ${s} -> ${a} from ${t}`), this.tech_.trigger({ type: "usage", name: `vhs-rendition-change-${t}` })), this.mainPlaylistLoader_.media(e, i) } startABRTimer_() { this.stopABRTimer_(), this.abrTimer_ = window.setInterval((() => this.checkABR_()), 250) } stopABRTimer_() { this.tech_.scrubbing && this.tech_.scrubbing() || (window.clearInterval(this.abrTimer_), this.abrTimer_ = null) } getAudioTrackPlaylists_() { const e = this.main(), t = e && e.playlists || []; if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO) return t; const i = e.mediaGroups.AUDIO, n = Object.keys(i); let s; if (Object.keys(this.mediaTypes_.AUDIO.groups).length) s = this.mediaTypes_.AUDIO.activeTrack(); else { const e = i.main || n.length && i[n[0]]; for (const t in e) if (e[t].default) { s = { label: t }; break } } if (!s) return t; const a = []; for (const t in i) if (i[t][s.label]) { const n = i[t][s.label]; if (n.playlists && n.playlists.length) a.push.apply(a, n.playlists); else if (n.uri) a.push(n); else if (e.playlists.length) for (let i = 0; i < e.playlists.length; i++) { const n = e.playlists[i]; n.attributes && n.attributes.AUDIO && n.attributes.AUDIO === t && a.push(n) } } return a.length ? a : t } setupMainPlaylistLoaderListeners_() { this.mainPlaylistLoader_.on("loadedmetadata", (() => { const e = this.mainPlaylistLoader_.media(), t = 1.5 * e.targetDuration * 1e3; ne(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, e.endList && "none" !== this.tech_.preload() && (this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load()), (e => { ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((t => { Mn[t](t, e) })); const { mediaTypes: t, mainPlaylistLoader: i, tech: n, vhs: s, segmentLoaders: { AUDIO: a, main: r } } = e;["AUDIO", "SUBTITLES"].forEach((i => { t[i].activeGroup = ((e, t) => i => { const { mainPlaylistLoader: n, mediaTypes: { [e]: { groups: s } } } = t, a = n.media(); if (!a) return null; let r = null; a.attributes[e] && (r = s[a.attributes[e]]); const o = Object.keys(s); if (!r) if ("AUDIO" === e && o.length > 1 && re(t.main)) for (let e = 0; e < o.length; e++) { const t = s[o[e]]; if (Bn(t, a)) { r = t; break } } else s.main ? r = s.main : 1 === o.length && (r = s[o[0]]); return void 0 === i ? r : null !== i && r && r.filter((e => e.id === i.id))[0] || null })(i, e), t[i].activeTrack = Nn[i](i, e), t[i].onGroupChanged = ((e, t) => () => { const { segmentLoaders: { [e]: i, main: n }, mediaTypes: { [e]: s } } = t, a = s.activeTrack(), r = s.getActiveGroup(), o = s.activePlaylistLoader, d = s.lastGroup_; r && d && r.id === d.id || (s.lastGroup_ = r, s.lastTrack_ = a, Pn(i, s), r && !r.isMainPlaylist && (r.playlistLoader ? (i.resyncLoader(), Cn(r.playlistLoader, s)) : o && n.resetEverything())) })(i, e), t[i].onGroupChanging = ((e, t) => () => { const { segmentLoaders: { [e]: i }, mediaTypes: { [e]: n } } = t; n.lastGroup_ = null, i.abort(), i.pause() })(i, e), t[i].onTrackChanged = ((e, t) => () => { const { mainPlaylistLoader: i, segmentLoaders: { [e]: n, main: s }, mediaTypes: { [e]: a } } = t, r = a.activeTrack(), o = a.getActiveGroup(), d = a.activePlaylistLoader, u = a.lastTrack_; if ((!u || !r || u.id !== r.id) && (a.lastGroup_ = o, a.lastTrack_ = r, Pn(n, a), o)) { if (o.isMainPlaylist) { if (!r || !u || r.id === u.id) return; const e = t.vhs.playlistController_, n = e.selectPlaylist(); if (e.media() === n) return; return a.logger_(`track change. Switching main audio from ${u.id} to ${r.id}`), i.pause(), s.resetEverything(), void e.fastQualityChange_(n) } if ("AUDIO" === e) { if (!o.playlistLoader) return s.setAudio(!0), void s.resetEverything(); n.setAudio(!0), s.setAudio(!1) } d !== o.playlistLoader ? (n.track && n.track(r), n.resetEverything(), Cn(o.playlistLoader, a)) : Cn(o.playlistLoader, a) } })(i, e), t[i].getActiveGroup = ((e, { mediaTypes: t }) => () => { const i = t[e].activeTrack(); return i ? t[e].activeGroup(i) : null })(i, e) })); const o = t.AUDIO.activeGroup(); if (o) { const e = (o.filter((e => e.default))[0] || o[0]).id; t.AUDIO.tracks[e].enabled = !0, t.AUDIO.onGroupChanged(), t.AUDIO.onTrackChanged(), t.AUDIO.getActiveGroup().playlistLoader ? (r.setAudio(!1), a.setAudio(!0)) : r.setAudio(!0) } i.on("mediachange", (() => { ["AUDIO", "SUBTITLES"].forEach((e => t[e].onGroupChanged())) })), i.on("mediachanging", (() => { ["AUDIO", "SUBTITLES"].forEach((e => t[e].onGroupChanging())) })); const d = () => { t.AUDIO.onTrackChanged(), n.trigger({ type: "usage", name: "vhs-audio-change" }) }; n.audioTracks().addEventListener("change", d), n.remoteTextTracks().addEventListener("change", t.SUBTITLES.onTrackChanged), s.on("dispose", (() => { n.audioTracks().removeEventListener("change", d), n.remoteTextTracks().removeEventListener("change", t.SUBTITLES.onTrackChanged) })), n.clearTracks("audio"); for (const e in t.AUDIO.tracks) n.audioTracks().addTrack(t.AUDIO.tracks[e]) })({ sourceType: this.sourceType_, segmentLoaders: { AUDIO: this.audioSegmentLoader_, SUBTITLES: this.subtitleSegmentLoader_, main: this.mainSegmentLoader_ }, tech: this.tech_, requestOptions: this.requestOptions_, mainPlaylistLoader: this.mainPlaylistLoader_, vhs: this.vhs_, main: this.main(), mediaTypes: this.mediaTypes_, excludePlaylist: this.excludePlaylist.bind(this) }), this.triggerPresenceUsage_(this.main(), e), this.setupFirstPlay(), !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", (() => { this.trigger("selectedinitialmedia") })) })), this.mainPlaylistLoader_.on("loadedplaylist", (() => { this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_); let e = this.mainPlaylistLoader_.media(); if (!e) { let t; if (this.excludeUnsupportedVariants_(), this.enableLowInitialPlaylist && (t = this.selectInitialPlaylist()), t || (t = this.selectPlaylist()), !t || !this.shouldSwitchToMedia_(t)) return; if (this.initialMedia_ = t, this.switchMedia_(this.initialMedia_, "initial"), "vhs-json" !== this.sourceType_ || !this.initialMedia_.segments) return; e = this.initialMedia_ } this.handleUpdatedMediaPlaylist(e) })), this.mainPlaylistLoader_.on("error", (() => { const e = this.mainPlaylistLoader_.error; this.excludePlaylist({ playlistToExclude: e.playlist, error: e }) })), this.mainPlaylistLoader_.on("mediachanging", (() => { this.mainSegmentLoader_.abort(), this.mainSegmentLoader_.pause() })), this.mainPlaylistLoader_.on("mediachange", (() => { const e = this.mainPlaylistLoader_.media(), t = 1.5 * e.targetDuration * 1e3; ne(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, this.mainPlaylistLoader_.load(), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load(), this.tech_.trigger({ type: "mediachange", bubbles: !0 }) })), this.mainPlaylistLoader_.on("playlistunchanged", (() => { const e = this.mainPlaylistLoader_.media(); "playlist-unchanged" !== e.lastExcludeReason_ && this.stuckAtPlaylistEnd_(e) && (this.excludePlaylist({ error: { message: "Playlist no longer updating.", reason: "playlist-unchanged" } }), this.tech_.trigger("playliststuck")) })), this.mainPlaylistLoader_.on("renditiondisabled", (() => { this.tech_.trigger({ type: "usage", name: "vhs-rendition-disabled" }) })), this.mainPlaylistLoader_.on("renditionenabled", (() => { this.tech_.trigger({ type: "usage", name: "vhs-rendition-enabled" }) })) } handleUpdatedMediaPlaylist(e) { this.useCueTags_ && this.updateAdCues_(e), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load()) } triggerPresenceUsage_(e, t) { const i = e.mediaGroups || {}; let n = !0; const s = Object.keys(i.AUDIO); for (const e in i.AUDIO) for (const t in i.AUDIO[e]) i.AUDIO[e][t].uri || (n = !1); n && this.tech_.trigger({ type: "usage", name: "vhs-demuxed" }), Object.keys(i.SUBTITLES).length && this.tech_.trigger({ type: "usage", name: "vhs-webvtt" }), Fn.Playlist.isAes(t) && this.tech_.trigger({ type: "usage", name: "vhs-aes" }), s.length && Object.keys(i.AUDIO[s[0]]).length > 1 && this.tech_.trigger({ type: "usage", name: "vhs-alternate-audio" }), this.useCueTags_ && this.tech_.trigger({ type: "usage", name: "vhs-playlist-cue-tags" }) } shouldSwitchToMedia_(e) { const t = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_, i = this.tech_.currentTime(), n = this.bufferLowWaterLine(), a = this.bufferHighWaterLine(); return function ({ currentPlaylist: e, buffered: t, currentTime: i, nextPlaylist: n, bufferLowWaterLine: a, bufferHighWaterLine: r, duration: o, bufferBasedABR: d, log: u }) { if (!n) return s.default.log.warn("We received no playlist to switch to. Please check your stream."), !1; const l = `allowing switch ${e && e.id || "null"} -> ${n.id}`; if (!e) return u(`${l} as current playlist is not set`), !0; if (n.id === e.id) return !1; const h = Boolean(N(t, i).length); if (!e.endList) return h || "number" != typeof e.partTargetDuration ? (u(`${l} as current playlist is live`), !0) : (u(`not ${l} as current playlist is live llhls, but currentTime isn't in buffered.`), !1); const c = W(t, i), p = d ? hi.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : hi.MAX_BUFFER_LOW_WATER_LINE; if (o < p) return u(`${l} as duration < max low water line (${o} < ${p})`), !0; const m = n.attributes.BANDWIDTH, f = e.attributes.BANDWIDTH; if (m < f && (!d || c < r)) { let e = `${l} as next bandwidth < current bandwidth (${m} < ${f})`; return d && (e += ` and forwardBuffer < bufferHighWaterLine (${c} < ${r})`), u(e), !0 } if ((!d || m > f) && c >= a) { let e = `${l} as forwardBuffer >= bufferLowWaterLine (${c} >= ${a})`; return d && (e += ` and next bandwidth > current bandwidth (${m} > ${f})`), u(e), !0 } return u(`not ${l} as no switching criteria met`), !1 }({ buffered: this.tech_.buffered(), currentTime: i, currentPlaylist: t, nextPlaylist: e, bufferLowWaterLine: n, bufferHighWaterLine: a, duration: this.duration(), bufferBasedABR: this.bufferBasedABR, log: this.logger_ }) } setupSegmentLoaderListeners_() { this.mainSegmentLoader_.on("bandwidthupdate", (() => { this.checkABR_("bandwidthupdate"), this.tech_.trigger("bandwidthupdate") })), this.mainSegmentLoader_.on("timeout", (() => { this.bufferBasedABR && this.mainSegmentLoader_.load() })), this.bufferBasedABR || this.mainSegmentLoader_.on("progress", (() => { this.trigger("progress") })), this.mainSegmentLoader_.on("error", (() => { const e = this.mainSegmentLoader_.error(); this.excludePlaylist({ playlistToExclude: e.playlist, error: e }) })), this.mainSegmentLoader_.on("appenderror", (() => { this.error = this.mainSegmentLoader_.error_, this.trigger("error") })), this.mainSegmentLoader_.on("syncinfoupdate", (() => { this.onSyncInfoUpdate_() })), this.mainSegmentLoader_.on("timestampoffset", (() => { this.tech_.trigger({ type: "usage", name: "vhs-timestamp-offset" }) })), this.audioSegmentLoader_.on("syncinfoupdate", (() => { this.onSyncInfoUpdate_() })), this.audioSegmentLoader_.on("appenderror", (() => { this.error = this.audioSegmentLoader_.error_, this.trigger("error") })), this.mainSegmentLoader_.on("ended", (() => { this.logger_("main segment loader ended"), this.onEndOfStream() })), this.mainSegmentLoader_.on("earlyabort", (e => { this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]), this.excludePlaylist({ error: { message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering." }, playlistExclusionDuration: 120 })) })); const e = () => { if (!this.sourceUpdater_.hasCreatedSourceBuffers()) return this.tryToCreateSourceBuffers_(); const e = this.getCodecsOrExclude_(); e && this.sourceUpdater_.addOrChangeSourceBuffers(e) }; this.mainSegmentLoader_.on("trackinfo", e), this.audioSegmentLoader_.on("trackinfo", e), this.mainSegmentLoader_.on("fmp4", (() => { this.triggeredFmp4Usage || (this.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), this.triggeredFmp4Usage = !0) })), this.audioSegmentLoader_.on("fmp4", (() => { this.triggeredFmp4Usage || (this.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), this.triggeredFmp4Usage = !0) })), this.audioSegmentLoader_.on("ended", (() => { this.logger_("audioSegmentLoader ended"), this.onEndOfStream() })) } mediaSecondsLoaded_() { return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded) } load() { this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load() } fastQualityChange_(e = this.selectPlaylist()) { e !== this.mainPlaylistLoader_.media() ? (this.switchMedia_(e, "fast-quality"), this.mainSegmentLoader_.resetEverything((() => { this.tech_.setCurrentTime(this.tech_.currentTime()) }))) : this.logger_("skipping fastQualityChange because new media is same as old") } play() { if (this.setupFirstPlay()) return; this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load(); const e = this.tech_.seekable(); return this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0) ? this.tech_.setCurrentTime(e.end(e.length - 1)) : void 0 } setupFirstPlay() { const e = this.mainPlaylistLoader_.media(); if (!e || this.tech_.paused() || this.hasPlayed_) return !1; if (!e.endList || e.start) { const t = this.seekable(); if (!t.length) return !1; const i = t.end(0); let n = i; if (e.start) { const s = e.start.timeOffset; n = s < 0 ? Math.max(i + s, t.start(0)) : Math.min(i, s) } this.trigger("firstplay"), this.tech_.setCurrentTime(n) } return this.hasPlayed_ = !0, this.load(), !0 } handleSourceOpen_() { if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) { const e = this.tech_.play(); void 0 !== e && "function" == typeof e.then && e.then(null, (e => { })) } this.trigger("sourceopen") } handleSourceEnded_() { if (!this.inbandTextTracks_.metadataTrack_) return; const e = this.inbandTextTracks_.metadataTrack_.cues; if (!e || !e.length) return; const t = this.duration(); e[e.length - 1].endTime = isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t } handleDurationChange_() { this.tech_.trigger("durationchange") } onEndOfStream() { let e = this.mainSegmentLoader_.ended_; if (this.mediaTypes_.AUDIO.activePlaylistLoader) { const t = this.mainSegmentLoader_.getCurrentMediaInfo_(); e = !t || t.hasVideo ? e && this.audioSegmentLoader_.ended_ : this.audioSegmentLoader_.ended_ } e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream()) } stuckAtPlaylistEnd_(e) { if (!this.seekable().length) return !1; const t = this.syncController_.getExpiredTime(e, this.duration()); if (null === t) return !1; const i = Fn.Playlist.playlistEnd(e, t), n = this.tech_.currentTime(), s = this.tech_.buffered(); if (!s.length) return i - n <= M; const a = s.end(s.length - 1); return a - n <= M && i - a <= M } excludePlaylist({ playlistToExclude: e = this.mainPlaylistLoader_.media(), error: t = {}, playlistExclusionDuration: i }) { if (e = e || this.mainPlaylistLoader_.media(), i = i || t.playlistExclusionDuration || this.playlistExclusionDuration, !e) return this.error = t, void ("open" !== this.mediaSource.readyState ? this.trigger("error") : this.sourceUpdater_.endOfStream("network")); e.playlistErrors_++; const n = this.mainPlaylistLoader_.main.playlists, a = n.filter(te), r = 1 === a.length && a[0] === e; if (1 === n.length && i !== 1 / 0) return s.default.log.warn(`Problem encountered with playlist ${e.id}. Trying again since it is the only playlist.`), this.tech_.trigger("retryplaylist"), this.mainPlaylistLoader_.load(r); if (r) { let t = !1; n.forEach((i => { if (i === e) return; const n = i.excludeUntil; void 0 !== n && n !== 1 / 0 && (t = !0, delete i.excludeUntil) })), t && (s.default.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist")) } let o; o = e.playlistErrors_ > this.maxPlaylistRetries ? 1 / 0 : Date.now() + 1e3 * i, e.excludeUntil = o, t.reason && (e.lastExcludeReason_ = t.reason), this.tech_.trigger("excludeplaylist"), this.tech_.trigger({ type: "usage", name: "vhs-rendition-excluded" }); const d = this.selectPlaylist(); if (!d) return this.error = "Playback cannot continue. No available working or supported playlists.", void this.trigger("error"); const u = t.internal ? this.logger_ : s.default.log.warn, l = t.message ? " " + t.message : ""; u(`${t.internal ? "Internal problem" : "Problem"} encountered with playlist ${e.id}.${l} Switching to playlist ${d.id}.`), d.attributes.AUDIO !== e.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), d.attributes.SUBTITLES !== e.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]); const h = d.targetDuration / 2 * 1e3 || 5e3, c = "number" == typeof d.lastRequest && Date.now() - d.lastRequest <= h; return this.switchMedia_(d, "exclude", r || c) } pauseLoading() { this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_() } delegateLoaders_(e, t) { const i = [], n = "all" === e; (n || "main" === e) && i.push(this.mainPlaylistLoader_); const s = []; (n || "audio" === e) && s.push("AUDIO"), (n || "subtitle" === e) && (s.push("CLOSED-CAPTIONS"), s.push("SUBTITLES")), s.forEach((e => { const t = this.mediaTypes_[e] && this.mediaTypes_[e].activePlaylistLoader; t && i.push(t) })), ["main", "audio", "subtitle"].forEach((t => { const n = this[`${t}SegmentLoader_`]; !n || e !== t && "all" !== e || i.push(n) })), i.forEach((e => t.forEach((t => { "function" == typeof e[t] && e[t]() })))) } setCurrentTime(e) { const t = N(this.tech_.buffered(), e); return this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media() && this.mainPlaylistLoader_.media().segments ? t && t.length ? e : (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), void this.load()) : 0 } duration() { if (!this.mainPlaylistLoader_) return 0; const e = this.mainPlaylistLoader_.media(); return e ? e.endList ? this.mediaSource ? this.mediaSource.duration : Fn.Playlist.duration(e) : 1 / 0 : 0 } seekable() { return this.seekable_ } onSyncInfoUpdate_() { let e; if (!this.mainPlaylistLoader_) return; let t = this.mainPlaylistLoader_.media(); if (!t) return; let i = this.syncController_.getExpiredTime(t, this.duration()); if (null === i) return; const n = this.mainPlaylistLoader_.main, s = Fn.Playlist.seekable(t, i, Fn.Playlist.liveEdgeDelay(n, t)); if (0 === s.length) return; if (this.mediaTypes_.AUDIO.activePlaylistLoader) { if (t = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), i = this.syncController_.getExpiredTime(t, this.duration()), null === i) return; if (e = Fn.Playlist.seekable(t, i, Fn.Playlist.liveEdgeDelay(n, t)), 0 === e.length) return } let a, r; this.seekable_ && this.seekable_.length && (a = this.seekable_.end(0), r = this.seekable_.start(0)), e ? e.start(0) > s.end(0) || s.start(0) > e.end(0) ? this.seekable_ = s : this.seekable_ = U([[e.start(0) > s.start(0) ? e.start(0) : s.start(0), e.end(0) < s.end(0) ? e.end(0) : s.end(0)]]) : this.seekable_ = s, this.seekable_ && this.seekable_.length && this.seekable_.end(0) === a && this.seekable_.start(0) === r || (this.logger_(`seekable updated [${$(this.seekable_)}]`), this.tech_.trigger("seekablechanged")) } updateDuration(e) { if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), "open" !== this.mediaSource.readyState) return this.updateDuration_ = this.updateDuration.bind(this, e), void this.mediaSource.addEventListener("sourceopen", this.updateDuration_); if (e) { const e = this.seekable(); if (!e.length) return; return void ((isNaN(this.mediaSource.duration) || this.mediaSource.duration < e.end(e.length - 1)) && this.sourceUpdater_.setDuration(e.end(e.length - 1))) } const t = this.tech_.buffered(); let i = Fn.Playlist.duration(this.mainPlaylistLoader_.media()); t.length > 0 && (i = Math.max(i, t.end(t.length - 1))), this.mediaSource.duration !== i && this.sourceUpdater_.setDuration(i) } dispose() { this.trigger("dispose"), this.decrypter_.terminate(), this.mainPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach((e => { const t = this.mediaTypes_[e].groups; for (const e in t) t[e].forEach((e => { e.playlistLoader && e.playlistLoader.dispose() })) })), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off() } main() { return this.mainPlaylistLoader_.main } media() { return this.mainPlaylistLoader_.media() || this.initialMedia_ } areMediaTypesKnown_() { const e = !!this.mediaTypes_.AUDIO.activePlaylistLoader, t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), i = !e || !!this.audioSegmentLoader_.getCurrentMediaInfo_(); return !(!t || !i) } getCodecsOrExclude_() { const e = { main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {}, audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {} }, t = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media(); e.video = e.main; const i = Bi(this.main(), t), n = {}, s = !!this.mediaTypes_.AUDIO.activePlaylistLoader; if (e.main.hasVideo && (n.video = i.video || e.main.videoCodec || "avc1.4d400d"), e.main.isMuxed && (n.video += `,${i.audio || e.main.audioCodec || P}`), (e.main.hasAudio && !e.main.isMuxed || e.audio.hasAudio || s) && (n.audio = i.audio || e.main.audioCodec || e.audio.audioCodec || P, e.audio.isFmp4 = e.main.hasAudio && !e.main.isMuxed ? e.main.isFmp4 : e.audio.isFmp4), !n.audio && !n.video) return void this.excludePlaylist({ playlistToExclude: t, error: { message: "Could not determine codecs for playlist." }, playlistExclusionDuration: 1 / 0 }); const a = {}; let r; if (["video", "audio"].forEach((function (t) { if (n.hasOwnProperty(t) && (i = e[t].isFmp4, s = n[t], !(i ? k(s) : O(s)))) { const i = e[t].isFmp4 ? "browser" : "muxer"; a[i] = a[i] || [], a[i].push(n[t]), "audio" === t && (r = i) } var i, s })), s && r && t.attributes.AUDIO) { const e = t.attributes.AUDIO; this.main().playlists.forEach((i => { (i.attributes && i.attributes.AUDIO) === e && i !== t && (i.excludeUntil = 1 / 0) })), this.logger_(`excluding audio group ${e} as ${r} does not support codec(s): "${n.audio}"`) } if (!Object.keys(a).length) { if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) { const e = []; if (["video", "audio"].forEach((t => { const i = (L(this.sourceUpdater_.codecs[t] || "")[0] || {}).type, s = (L(n[t] || "")[0] || {}).type; i && s && i.toLowerCase() !== s.toLowerCase() && e.push(`"${this.sourceUpdater_.codecs[t]}" -> "${n[t]}"`) })), e.length) return void this.excludePlaylist({ playlistToExclude: t, error: { message: `Codec switching not supported: ${e.join(", ")}.`, internal: !0 }, playlistExclusionDuration: 1 / 0 }) } return n } { const e = Object.keys(a).reduce(((e, t) => (e && (e += ", "), e + `${t} does not support codec(s): "${a[t].join(",")}"`)), "") + "."; this.excludePlaylist({ playlistToExclude: t, error: { internal: !0, message: e }, playlistExclusionDuration: 1 / 0 }) } } tryToCreateSourceBuffers_() { if ("open" !== this.mediaSource.readyState || this.sourceUpdater_.hasCreatedSourceBuffers()) return; if (!this.areMediaTypesKnown_()) return; const e = this.getCodecsOrExclude_(); if (!e) return; this.sourceUpdater_.createSourceBuffers(e); const t = [e.video, e.audio].filter(Boolean).join(","); this.excludeIncompatibleVariants_(t) } excludeUnsupportedVariants_() { const e = this.main().playlists, t = []; Object.keys(e).forEach((i => { const n = e[i]; if (-1 !== t.indexOf(n.id)) return; t.push(n.id); const s = Bi(this.main, n), a = []; !s.audio || O(s.audio) || k(s.audio) || a.push(`audio codec ${s.audio}`), !s.video || O(s.video) || k(s.video) || a.push(`video codec ${s.video}`), s.text && "stpp.ttml.im1t" === s.text && a.push(`text codec ${s.text}`), a.length && (n.excludeUntil = 1 / 0, this.logger_(`excluding ${n.id} for unsupported: ${a.join(", ")}`)) })) } excludeIncompatibleVariants_(e) { const t = [], i = this.main().playlists, n = Ri(L(e)), s = Mi(n), a = n.video && L(n.video)[0] || null, r = n.audio && L(n.audio)[0] || null; Object.keys(i).forEach((e => { const n = i[e]; if (-1 !== t.indexOf(n.id) || n.excludeUntil === 1 / 0) return; t.push(n.id); const o = [], d = Bi(this.mainPlaylistLoader_.main, n), u = Mi(d); if (d.audio || d.video) { if (u !== s && o.push(`codec count "${u}" !== "${s}"`), !this.sourceUpdater_.canChangeType()) { const e = d.video && L(d.video)[0] || null, t = d.audio && L(d.audio)[0] || null; e && a && e.type.toLowerCase() !== a.type.toLowerCase() && o.push(`video codec "${e.type}" !== "${a.type}"`), t && r && t.type.toLowerCase() !== r.type.toLowerCase() && o.push(`audio codec "${t.type}" !== "${r.type}"`) } o.length && (n.excludeUntil = 1 / 0, this.logger_(`excluding ${n.id}: ${o.join(" && ")}`)) } })) } updateAdCues_(e) { let t = 0; const i = this.seekable(); i.length && (t = i.start(0)), function (e, t, i = 0) { if (!e.segments) return; let n, s = i; for (let i = 0; i < e.segments.length; i++) { const a = e.segments[i]; if (n || (n = En(t, s + a.duration / 2)), n) { if ("cueIn" in a) { n.endTime = s, n.adEndTime = s, s += a.duration, n = null; continue } if (s < n.endTime) { s += a.duration; continue } n.endTime += a.duration } else if ("cueOut" in a && (n = new window.VTTCue(s, s + a.duration, a.cueOut), n.adStartTime = s, n.adEndTime = s + parseFloat(a.cueOut), t.addCue(n)), "cueOutCont" in a) { const [e, i] = a.cueOutCont.split("/").map(parseFloat); n = new window.VTTCue(s, s + a.duration, ""), n.adStartTime = s - e, n.adEndTime = n.adStartTime + i, t.addCue(n) } s += a.duration } }(e, this.cueTagsTrack_, t) } goalBufferLength() { const e = this.tech_.currentTime(), t = hi.GOAL_BUFFER_LENGTH, i = hi.GOAL_BUFFER_LENGTH_RATE, n = Math.max(t, hi.MAX_GOAL_BUFFER_LENGTH); return Math.min(t + e * i, n) } bufferLowWaterLine() { const e = this.tech_.currentTime(), t = hi.BUFFER_LOW_WATER_LINE, i = hi.BUFFER_LOW_WATER_LINE_RATE, n = Math.max(t, hi.MAX_BUFFER_LOW_WATER_LINE), s = Math.max(t, hi.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE); return Math.min(t + e * i, this.bufferBasedABR ? s : n) } bufferHighWaterLine() { return hi.BUFFER_HIGH_WATER_LINE } addMetadataToTextTrack(e, t, i) { const n = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset(); ((e, t, i) => { e.metadataTrack_ || (e.metadataTrack_ = i.addRemoteTextTrack({ kind: "metadata", label: "Timed Metadata" }, !1).track, e.metadataTrack_.inBandMetadataTrackDispatchType = t) })(this.inbandTextTracks_, e, this.tech_), (({ inbandTextTracks: e, metadataArray: t, timestampOffset: i, videoDuration: n }) => { if (!t) return; const a = window.WebKitDataCue || window.VTTCue, r = e.metadataTrack_; if (!r) return; if (t.forEach((e => { const t = e.cueTime + i; !("number" != typeof t || window.isNaN(t) || t < 0) && t < 1 / 0 && e.frames && e.frames.length && e.frames.forEach((e => { const i = new a(t, t, e.value || e.url || e.data || ""); i.frame = e, i.value = e, function (e) { Object.defineProperties(e.frame, { id: { get: () => (s.default.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), e.value.key) }, value: { get: () => (s.default.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), e.value.data) }, privateData: { get: () => (s.default.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), e.value.data) } }) }(i), r.addCue(i) })) })), !r.cues || !r.cues.length) return; const o = r.cues, d = []; for (let e = 0; e < o.length; e++)o[e] && d.push(o[e]); const u = d.reduce(((e, t) => { const i = e[t.startTime] || []; return i.push(t), e[t.startTime] = i, e }), {}), l = Object.keys(u).sort(((e, t) => Number(e) - Number(t))); l.forEach(((e, t) => { const i = u[e], s = Number(l[t + 1]) || n; i.forEach((e => { e.endTime = s })) })) })({ inbandTextTracks: this.inbandTextTracks_, metadataArray: t, timestampOffset: n, videoDuration: i }) } } class Wn { constructor(e, t, i) { const { playlistController_: n } = e, s = n.fastQualityChange_.bind(n); if (t.attributes) { const e = t.attributes.RESOLUTION; this.width = e && e.width, this.height = e && e.height, this.bandwidth = t.attributes.BANDWIDTH, this.frameRate = t.attributes["FRAME-RATE"] } var a, r, o; this.codecs = Bi(n.main(), t), this.playlist = t, this.id = i, this.enabled = (a = e.playlists, r = t.id, o = s, e => { const t = a.main.playlists[r], i = ee(t), n = te(t); return void 0 === e ? n : (e ? delete t.disabled : t.disabled = !0, e === n || i || (o(), e ? a.trigger("renditionenabled") : a.trigger("renditiondisabled")), e) }) } } const Vn = ["seeking", "seeked", "pause", "playing", "error"]; class Hn { constructor(e) { this.playlistController_ = e.playlistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = h("PlaybackWatcher"), this.logger_("initialize"); const t = () => this.monitorCurrentTime_(), i = () => this.monitorCurrentTime_(), n = () => this.techWaiting_(), s = () => this.resetTimeUpdate_(), a = this.playlistController_, r = ["main", "subtitle", "audio"], o = {}; r.forEach((e => { o[e] = { reset: () => this.resetSegmentDownloads_(e), updateend: () => this.checkSegmentDownloads_(e) }, a[`${e}SegmentLoader_`].on("appendsdone", o[e].updateend), a[`${e}SegmentLoader_`].on("playlistupdate", o[e].reset), this.tech_.on(["seeked", "seeking"], o[e].reset) })); const d = e => { ["main", "audio"].forEach((t => { a[`${t}SegmentLoader_`][e]("appended", this.seekingAppendCheck_) })) }; this.seekingAppendCheck_ = () => { this.fixesBadSeeks_() && (this.consecutiveUpdates = 0, this.lastRecordedTime = this.tech_.currentTime(), d("off")) }, this.clearSeekingAppendCheck_ = () => d("off"), this.watchForBadSeeking_ = () => { this.clearSeekingAppendCheck_(), d("on") }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", n), this.tech_.on(Vn, s), this.tech_.on("canplay", i), this.tech_.one("play", t), this.dispose = () => { this.clearSeekingAppendCheck_(), this.logger_("dispose"), this.tech_.off("waiting", n), this.tech_.off(Vn, s), this.tech_.off("canplay", i), this.tech_.off("play", t), this.tech_.off("seeking", this.watchForBadSeeking_), this.tech_.off("seeked", this.clearSeekingAppendCheck_), r.forEach((e => { a[`${e}SegmentLoader_`].off("appendsdone", o[e].updateend), a[`${e}SegmentLoader_`].off("playlistupdate", o[e].reset), this.tech_.off(["seeked", "seeking"], o[e].reset) })), this.checkCurrentTimeTimeout_ && window.clearTimeout(this.checkCurrentTimeTimeout_), this.resetTimeUpdate_() } } monitorCurrentTime_() { this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && window.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250) } resetSegmentDownloads_(e) { const t = this.playlistController_[`${e}SegmentLoader_`]; this[`${e}StalledDownloads_`] > 0 && this.logger_(`resetting possible stalled download count for ${e} loader`), this[`${e}StalledDownloads_`] = 0, this[`${e}Buffered_`] = t.buffered_() } checkSegmentDownloads_(e) { const t = this.playlistController_, i = t[`${e}SegmentLoader_`], n = i.buffered_(), s = function (e, t) { if (e === t) return !1; if (!e && t || !t && e) return !0; if (e.length !== t.length) return !0; for (let i = 0; i < e.length; i++)if (e.start(i) !== t.start(i) || e.end(i) !== t.end(i)) return !0; return !1 }(this[`${e}Buffered_`], n); this[`${e}Buffered_`] = n, s ? this.resetSegmentDownloads_(e) : (this[`${e}StalledDownloads_`]++, this.logger_(`found #${this[`${e}StalledDownloads_`]} ${e} appends that did not increase buffer (possible stalled download)`, { playlistId: i.playlist_ && i.playlist_.id, buffered: q(n) }), this[`${e}StalledDownloads_`] < 10 || (this.logger_(`${e} loader stalled download exclusion`), this.resetSegmentDownloads_(e), this.tech_.trigger({ type: "usage", name: `vhs-${e}-download-exclusion` }), "subtitle" !== e && t.excludePlaylist({ error: { message: `Excessive ${e} segment downloading detected.` }, playlistExclusionDuration: 1 / 0 }))) } checkCurrentTime_() { if (this.tech_.paused() || this.tech_.seeking()) return; const e = this.tech_.currentTime(), t = this.tech_.buffered(); if (this.lastRecordedTime === e && (!t.length || e + M >= t.end(t.length - 1))) return this.techWaiting_(); this.consecutiveUpdates >= 5 && e === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : e === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = e) } resetTimeUpdate_() { this.consecutiveUpdates = 0 } fixesBadSeeks_() { if (!this.tech_.seeking()) return !1; const e = this.seekable(), t = this.tech_.currentTime(); let i; if (this.afterSeekableWindow_(e, t, this.media(), this.allowSeeksWithinUnsafeLiveWindow) && (i = e.end(e.length - 1)), this.beforeSeekableWindow_(e, t)) { const t = e.start(0); i = t + (t === e.end(0) ? 0 : M) } if (void 0 !== i) return this.logger_(`Trying to seek outside of seekable at time ${t} with seekable range ${$(e)}. Seeking to ${i}.`), this.tech_.setCurrentTime(i), !0; const n = this.playlistController_.sourceUpdater_, s = this.tech_.buffered(), a = n.audioBuffer ? n.audioBuffered() : null, r = n.videoBuffer ? n.videoBuffered() : null, o = this.media(), d = o.partTargetDuration ? o.partTargetDuration : 2 * (o.targetDuration - R), u = [a, r]; for (let e = 0; e < u.length; e++)if (u[e] && W(u[e], t) < d) return !1; const l = F(s, t); return 0 !== l.length && (i = l.start(0) + M, this.logger_(`Buffered region starts (${l.start(0)})  just beyond seek point (${t}). Seeking to ${i}.`), this.tech_.setCurrentTime(i), !0) } waiting_() { if (this.techWaiting_()) return; const e = this.tech_.currentTime(), t = this.tech_.buffered(), i = N(t, e); return i.length && e + 3 <= i.end(0) ? (this.resetTimeUpdate_(), this.tech_.setCurrentTime(e), this.logger_(`Stopped at ${e} while inside a buffered region [${i.start(0)} -> ${i.end(0)}]. Attempting to resume playback by seeking to the current time.`), void this.tech_.trigger({ type: "usage", name: "vhs-unknown-waiting" })) : void 0 } techWaiting_() { const e = this.seekable(), t = this.tech_.currentTime(); if (this.tech_.seeking()) return !0; if (this.beforeSeekableWindow_(e, t)) { const i = e.end(e.length - 1); return this.logger_(`Fell out of live window at time ${t}. Seeking to live point (seekable end) ${i}`), this.resetTimeUpdate_(), this.tech_.setCurrentTime(i), this.tech_.trigger({ type: "usage", name: "vhs-live-resync" }), !0 } const i = this.tech_.vhs.playlistController_.sourceUpdater_, n = this.tech_.buffered(); if (this.videoUnderflow_({ audioBuffered: i.audioBuffered(), videoBuffered: i.videoBuffered(), currentTime: t })) return this.resetTimeUpdate_(), this.tech_.setCurrentTime(t), this.tech_.trigger({ type: "usage", name: "vhs-video-underflow" }), !0; const s = F(n, t); return s.length > 0 && (this.logger_(`Stopped at ${t} and seeking to ${s.start(0)}`), this.resetTimeUpdate_(), this.skipTheGap_(t), !0) } afterSeekableWindow_(e, t, i, n = !1) { if (!e.length) return !1; let s = e.end(e.length - 1) + M; const a = !i.endList, r = "number" == typeof i.partTargetDuration; return a && (r || n) && (s = e.end(e.length - 1) + 3 * i.targetDuration), t > s } beforeSeekableWindow_(e, t) { return !!(e.length && e.start(0) > 0 && t < e.start(0) - this.liveRangeSafeTimeDelta) } videoUnderflow_({ videoBuffered: e, audioBuffered: t, currentTime: i }) { if (!e) return; let n; if (e.length && t.length) { const s = N(e, i - 3), a = N(e, i), r = N(t, i); r.length && !a.length && s.length && (n = { start: s.end(0), end: r.end(0) }) } else F(e, i).length || (n = this.gapFromVideoUnderflow_(e, i)); return !!n && (this.logger_(`Encountered a gap in video from ${n.start} to ${n.end}. Seeking to current time ${i}`), !0) } skipTheGap_(e) { const t = this.tech_.buffered(), i = this.tech_.currentTime(), n = F(t, i); this.resetTimeUpdate_(), 0 !== n.length && i === e && (this.logger_("skipTheGap_:", "currentTime:", i, "scheduled currentTime:", e, "nextRange start:", n.start(0)), this.tech_.setCurrentTime(n.start(0) + R), this.tech_.trigger({ type: "usage", name: "vhs-gap-skip" })) } gapFromVideoUnderflow_(e, t) { const i = function (e) { if (e.length < 2) return U(); const t = []; for (let i = 1; i < e.length; i++) { const n = e.end(i - 1), s = e.start(i); t.push([n, s]) } return U(t) }(e); for (let e = 0; e < i.length; e++) { const n = i.start(e), s = i.end(e); if (t - n < 4 && t - n > 2) return { start: n, end: s } } return null } } const Xn = { errorInterval: 30, getSource(e) { return e(this.tech({ IWillNotUseThisInPlugins: !0 }).currentSource_ || this.currentSource()) } }, jn = function (e, t) { let i = 0, n = 0; const a = C(Xn, t); e.ready((() => { e.trigger({ type: "usage", name: "vhs-error-reload-initialized" }) })); const r = function () { n && e.currentTime(n) }, o = function (t) { null != t && (n = e.duration() !== 1 / 0 && e.currentTime() || 0, e.one("loadedmetadata", r), e.src(t), e.trigger({ type: "usage", name: "vhs-error-reload" }), e.play()) }, d = function () { if (Date.now() - i < 1e3 * a.errorInterval) e.trigger({ type: "usage", name: "vhs-error-reload-canceled" }); else { if (a.getSource && "function" == typeof a.getSource) return i = Date.now(), a.getSource.call(e, o); s.default.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!") } }, u = function () { e.off("loadedmetadata", r), e.off("error", d), e.off("dispose", u) }; e.on("error", d), e.on("dispose", u), e.reloadSourceOnError = function (t) { u(), jn(e, t) } }; var zn = "3.4.0"; const Yn = { PlaylistLoader: Se, Playlist: oe, utils: He, STANDARD_PLAYLIST_SELECTOR: Vi, INITIAL_PLAYLIST_SELECTOR: function () { const e = this.playlists.main.playlists.filter(oe.isEnabled); return qi(e, ((e, t) => Gi(e, t))), e.filter((e => !!Bi(this.playlists.main, e).video))[0] || null }, lastBandwidthSelector: Vi, movingAverageBandwidthSelector: function (e) { let t = -1, i = -1; if (e < 0 || e > 1) throw new Error("Moving average bandwidth decay must be between 0 and 1."); return function () { const n = this.useDevicePixelRatio && window.devicePixelRatio || 1; return t < 0 && (t = this.systemBandwidth, i = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== i && (t = e * this.systemBandwidth + (1 - e) * t, i = this.systemBandwidth), Wi(this.playlists.main, t, parseInt($i(this.tech_.el(), "width"), 10) * n, parseInt($i(this.tech_.el(), "height"), 10) * n, this.limitRenditionByPlayerDimensions, this.playlistController_) } }, comparePlaylistBandwidth: Gi, comparePlaylistResolution: function (e, t) { let i, n; return e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (i = e.attributes.RESOLUTION.width), i = i || window.Number.MAX_VALUE, t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (n = t.attributes.RESOLUTION.width), n = n || window.Number.MAX_VALUE, i === n && e.attributes.BANDWIDTH && t.attributes.BANDWIDTH ? e.attributes.BANDWIDTH - t.attributes.BANDWIDTH : i - n }, xhr: Ie() }; Object.keys(hi).forEach((e => { Object.defineProperty(Yn, e, { get: () => (s.default.log.warn(`using Vhs.${e} is UNSAFE be sure you know what you are doing`), hi[e]), set(t) { s.default.log.warn(`using Vhs.${e} is UNSAFE be sure you know what you are doing`), "number" != typeof t || t < 0 ? s.default.log.warn(`value of Vhs.${e} must be greater than or equal to 0`) : hi[e] = t } }) })); const Qn = "tm_videojs-vhs", Kn = function (e, t) { const i = t.media(); let n = -1; for (let t = 0; t < e.length; t++)if (e[t].id === i.id) { n = t; break } e.selectedIndex_ = n, e.trigger({ selectedIndex: n, type: "change" }) }; Yn.canPlaySource = function () { return s.default.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.") }; const Jn = (e, t, i) => { if (!e) return e; let n = {}; t && t.attributes && t.attributes.CODECS && (n = Ri(L(t.attributes.CODECS))), i && i.attributes && i.attributes.CODECS && (n.audio = i.attributes.CODECS); const s = x(n.video), a = x(n.audio), r = {}; for (const i in e) r[i] = {}, a && (r[i].audioContentType = a), s && (r[i].videoContentType = s), t.contentProtection && t.contentProtection[i] && t.contentProtection[i].pssh && (r[i].pssh = t.contentProtection[i].pssh), "string" == typeof e[i] && (r[i].url = e[i]); return C(e, r) }, Zn = (e, t) => e.reduce(((e, i) => { if (!i.contentProtection) return e; const n = t.reduce(((e, t) => { const n = i.contentProtection[t]; return n && n.pssh && (e[t] = { pssh: n.pssh }), e }), {}); return Object.keys(n).length && e.push(n), e }), []), es = ({ player: e, sourceKeySystems: t, audioMedia: i, mainPlaylists: n }) => { if (!e.eme.initializeMediaKeys) return Promise.resolve(); const s = i ? n.concat([i]) : n, a = Zn(s, Object.keys(t)), r = [], o = []; return a.forEach((t => { o.push(new Promise(((t, i) => { e.tech_.one("keysessioncreated", t) }))), r.push(new Promise(((i, n) => { e.eme.initializeMediaKeys({ keySystems: t }, (e => { e ? n(e) : i() })) }))) })), Promise.race([Promise.all(r), Promise.race(o)]) }, ts = ({ player: e, sourceKeySystems: t, media: i, audioMedia: n }) => { const a = Jn(t, i, n); return !(!a || (e.currentSource().keySystems = a, a && !e.eme && (s.default.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), 1))) }, is = () => { if (!window.localStorage) return null; const e = window.localStorage.getItem(Qn); if (!e) return null; try { return JSON.parse(e) } catch (e) { return null } }, ns = e => 0 === e.toLowerCase().indexOf("data:application/vnd.tm_videojs.vhs+json,") ? JSON.parse(e.substring(e.indexOf(",") + 1)) : e, ss = (e, t) => { e._requestCallbackSet || (e._requestCallbackSet = new Set), e._requestCallbackSet.add(t) }, as = (e, t) => { e._responseCallbackSet || (e._responseCallbackSet = new Set), e._responseCallbackSet.add(t) }, rs = (e, t) => { e._requestCallbackSet && (e._requestCallbackSet.delete(t), e._requestCallbackSet.size || delete e._requestCallbackSet) }, os = (e, t) => { e._responseCallbackSet && (e._responseCallbackSet.delete(t), e._responseCallbackSet.size || delete e._responseCallbackSet) }; Yn.supportsNativeHls = function () { if (!document || !document.createElement) return !1; const e = document.createElement("video"); return !!s.default.getTech("Html5").isSupported() && ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some((function (t) { return /maybe|probably/i.test(e.canPlayType(t)) })) }(), Yn.supportsNativeDash = !!(document && document.createElement && s.default.getTech("Html5").isSupported()) && /maybe|probably/i.test(document.createElement("video").canPlayType("application/dash+xml")), Yn.supportsTypeNatively = e => "hls" === e ? Yn.supportsNativeHls : "dash" === e && Yn.supportsNativeDash, Yn.isSupported = function () { return s.default.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.") }, Yn.xhr.onRequest = function (e) { ss(Yn.xhr, e) }, Yn.xhr.onResponse = function (e) { as(Yn.xhr, e) }, Yn.xhr.offRequest = function (e) { rs(Yn.xhr, e) }, Yn.xhr.offResponse = function (e) { os(Yn.xhr, e) }; const ds = s.default.getComponent("Component"); class us extends ds { constructor(e, t, i) { if (super(t, i.vhs), "number" == typeof i.initialBandwidth && (this.options_.bandwidth = i.initialBandwidth), this.logger_ = h("VhsHandler"), t.options_ && t.options_.playerId) { const e = s.default.getPlayer(t.options_.playerId); this.player_ = e } if (this.tech_ = t, this.source_ = e, this.stats = {}, this.ignoreNextSeekingEvent_ = !1, this.setOptions_(), this.options_.overrideNative && t.overrideNativeAudioTracks && t.overrideNativeVideoTracks) t.overrideNativeAudioTracks(!0), t.overrideNativeVideoTracks(!0); else if (this.options_.overrideNative && (t.featuresNativeVideoTracks || t.featuresNativeAudioTracks)) throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB"); this.on(document, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (e => { const t = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; t && t.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_() })), this.on(this.tech_, "seeking", (function () { this.ignoreNextSeekingEvent_ ? this.ignoreNextSeekingEvent_ = !1 : this.setCurrentTime(this.tech_.currentTime()) })), this.on(this.tech_, "error", (function () { this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading() })), this.on(this.tech_, "play", this.play) } setOptions_() { if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.useBandwidthFromLocalStorage = void 0 !== this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, this.options_.llhls = !1 !== this.options_.llhls, this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1, "number" != typeof this.options_.playlistExclusionDuration && (this.options_.playlistExclusionDuration = 300), "number" != typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage) { const e = is(); e && e.bandwidth && (this.options_.bandwidth = e.bandwidth, this.tech_.trigger({ type: "usage", name: "vhs-bandwidth-from-local-storage" })), e && e.throughput && (this.options_.throughput = e.throughput, this.tech_.trigger({ type: "usage", name: "vhs-throughput-from-local-storage" })) } "number" != typeof this.options_.bandwidth && (this.options_.bandwidth = hi.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === hi.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((e => { void 0 !== this.source_[e] && (this.options_[e] = this.source_[e]) })), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio } src(e, t) { if (!e) return; this.setOptions_(), this.options_.src = ns(this.source_.src), this.options_.tech = this.tech_, this.options_.externVhs = Yn, this.options_.sourceType = ke(t), this.options_.seekTo = e => { this.tech_.setCurrentTime(e) }, this.playlistController_ = new Gn(this.options_); const i = C({ liveRangeSafeTimeDelta: M }, this.options_, { seekable: () => this.seekable(), media: () => this.playlistController_.media(), playlistController: this.playlistController_ }); this.playbackWatcher_ = new Hn(i), this.playlistController_.on("error", (() => { const e = s.default.players[this.tech_.options_.playerId]; let t = this.playlistController_.error; "object" != typeof t || t.code ? "string" == typeof t && (t = { message: t, code: 3 }) : t.code = 3, e.error(t) })); const n = this.options_.bufferBasedABR ? Yn.movingAverageBandwidthSelector(.55) : Yn.STANDARD_PLAYLIST_SELECTOR; this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : n.bind(this), this.playlistController_.selectInitialPlaylist = Yn.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.playlistController_.mainPlaylistLoader_, this.mediaSource = this.playlistController_.mediaSource, Object.defineProperties(this, { selectPlaylist: { get() { return this.playlistController_.selectPlaylist }, set(e) { this.playlistController_.selectPlaylist = e.bind(this) } }, throughput: { get() { return this.playlistController_.mainSegmentLoader_.throughput.rate }, set(e) { this.playlistController_.mainSegmentLoader_.throughput.rate = e, this.playlistController_.mainSegmentLoader_.throughput.count = 1 } }, bandwidth: { get() { let e = this.playlistController_.mainSegmentLoader_.bandwidth; const t = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection, i = 1e7; if (this.options_.useNetworkInformationApi && t) { const n = 1e3 * t.downlink * 1e3; e = n >= i && e >= i ? Math.max(e, n) : n } return e }, set(e) { this.playlistController_.mainSegmentLoader_.bandwidth = e, this.playlistController_.mainSegmentLoader_.throughput = { rate: 0, count: 0 } } }, systemBandwidth: { get() { const e = 1 / (this.bandwidth || 1); let t; return t = this.throughput > 0 ? 1 / this.throughput : 0, Math.floor(1 / (e + t)) }, set() { s.default.log.error('The "systemBandwidth" property is read-only') } } }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, { bandwidth: { get: () => this.bandwidth || 0, enumerable: !0 }, mediaRequests: { get: () => this.playlistController_.mediaRequests_() || 0, enumerable: !0 }, mediaRequestsAborted: { get: () => this.playlistController_.mediaRequestsAborted_() || 0, enumerable: !0 }, mediaRequestsTimedout: { get: () => this.playlistController_.mediaRequestsTimedout_() || 0, enumerable: !0 }, mediaRequestsErrored: { get: () => this.playlistController_.mediaRequestsErrored_() || 0, enumerable: !0 }, mediaTransferDuration: { get: () => this.playlistController_.mediaTransferDuration_() || 0, enumerable: !0 }, mediaBytesTransferred: { get: () => this.playlistController_.mediaBytesTransferred_() || 0, enumerable: !0 }, mediaSecondsLoaded: { get: () => this.playlistController_.mediaSecondsLoaded_() || 0, enumerable: !0 }, mediaAppends: { get: () => this.playlistController_.mediaAppends_() || 0, enumerable: !0 }, mainAppendsToLoadedData: { get: () => this.playlistController_.mainAppendsToLoadedData_() || 0, enumerable: !0 }, audioAppendsToLoadedData: { get: () => this.playlistController_.audioAppendsToLoadedData_() || 0, enumerable: !0 }, appendsToLoadedData: { get: () => this.playlistController_.appendsToLoadedData_() || 0, enumerable: !0 }, timeToLoadedData: { get: () => this.playlistController_.timeToLoadedData_() || 0, enumerable: !0 }, buffered: { get: () => q(this.tech_.buffered()), enumerable: !0 }, currentTime: { get: () => this.tech_.currentTime(), enumerable: !0 }, currentSource: { get: () => this.tech_.currentSource_, enumerable: !0 }, currentTech: { get: () => this.tech_.name_, enumerable: !0 }, duration: { get: () => this.tech_.duration(), enumerable: !0 }, main: { get: () => this.playlists.main, enumerable: !0 }, playerDimensions: { get: () => this.tech_.currentDimensions(), enumerable: !0 }, seekable: { get: () => q(this.tech_.seekable()), enumerable: !0 }, timestamp: { get: () => Date.now(), enumerable: !0 }, videoPlaybackQuality: { get: () => this.tech_.getVideoPlaybackQuality(), enumerable: !0 } }), this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)), this.tech_.on("bandwidthupdate", (() => { this.options_.useBandwidthFromLocalStorage && (e => { if (!window.localStorage) return !1; let t = is(); t = t ? C(t, e) : e; try { window.localStorage.setItem(Qn, JSON.stringify(t)) } catch (e) { return !1 } })({ bandwidth: this.bandwidth, throughput: Math.round(this.throughput) }) })), this.playlistController_.on("selectedinitialmedia", (() => { var e; (e = this).representations = () => { const t = e.playlistController_.main(), i = re(t) ? e.playlistController_.getAudioTrackPlaylists_() : t.playlists; return i ? i.filter((e => !ee(e))).map(((t, i) => new Wn(e, t, t.id))) : [] } })), this.playlistController_.sourceUpdater_.on("createdsourcebuffers", (() => { this.setupEme_() })), this.on(this.playlistController_, "progress", (function () { this.tech_.trigger("progress") })), this.on(this.playlistController_, "firstplay", (function () { this.ignoreNextSeekingEvent_ = !0 })), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = window.URL.createObjectURL(this.playlistController_.mediaSource), this.tech_.src(this.mediaSourceUrl_)) } createKeySessions_() { const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader; this.logger_("waiting for EME key session creation"), es({ player: this.player_, sourceKeySystems: this.source_.keySystems, audioMedia: e && e.media(), mainPlaylists: this.playlists.main.playlists }).then((() => { this.logger_("created EME key session"), this.playlistController_.sourceUpdater_.initializedEme() })).catch((e => { this.logger_("error while creating EME key session", e), this.player_.error({ message: "Failed to initialize media keys for EME", code: 3 }) })) } handleWaitingForKey_() { this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_() } setupEme_() { const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader, t = ts({ player: this.player_, sourceKeySystems: this.source_.keySystems, media: this.playlists.media(), audioMedia: e && e.media() }); this.player_.tech_.on("keystatuschange", (e => { if ("output-restricted" !== e.status) return; const t = this.playlistController_.main(); if (!t || !t.playlists) return; const i = []; t.playlists.forEach((e => { e && e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height >= 720 && (!e.excludeUntil || e.excludeUntil < 1 / 0) && (e.excludeUntil = 1 / 0, i.push(e)) })), i.length && (s.default.log.warn('DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.', ...i), this.playlistController_.fastQualityChange_()) })), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), t ? this.createKeySessions_() : this.playlistController_.sourceUpdater_.initializedEme() } setupQualityLevels_() { const e = s.default.players[this.tech_.options_.playerId]; e && e.qualityLevels && !this.qualityLevels_ && (this.qualityLevels_ = e.qualityLevels(), this.playlistController_.on("selectedinitialmedia", (() => { var e, t; e = this.qualityLevels_, (t = this).representations().forEach((t => { e.addQualityLevel(t) })), Kn(e, t.playlists) })), this.playlists.on("mediachange", (() => { Kn(this.qualityLevels_, this.playlists) }))) } static version() { return { "@tm_videojs/http-streaming": zn, "mux.js": "6.3.0", "mpd-parser": "1.1.1", "m3u8-parser": "6.2.0", "aes-decrypter": "4.0.1" } } version() { return this.constructor.version() } canChangeType() { return bn.canChangeType() } play() { this.playlistController_.play() } setCurrentTime(e) { this.playlistController_.setCurrentTime(e) } duration() { return this.playlistController_.duration() } seekable() { return this.playlistController_.seekable() } dispose() { this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.playlistController_ && this.playlistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.mediaSourceUrl_ && window.URL.revokeObjectURL && (window.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), super.dispose() } convertToProgramTime(e, t) { return (({ playlist: e, time: t, callback: i }) => { if (!i) throw new Error("getProgramTime: callback must be provided"); if (!e || void 0 === t) return i({ message: "getProgramTime: playlist and time must be provided" }); const n = ((e, t) => { if (!t || !t.segments || 0 === t.segments.length) return null; let i, n = 0; for (let s = 0; s < t.segments.length && (i = t.segments[s], n = i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationEnd : n + i.duration, !(e <= n)); s++); const s = t.segments[t.segments.length - 1]; if (s.videoTimingInfo && s.videoTimingInfo.transmuxedPresentationEnd < e) return null; if (e > n) { if (e > n + .25 * s.duration) return null; i = s } return { segment: i, estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : n - i.duration, type: i.videoTimingInfo ? "accurate" : "estimate" } })(t, e); if (!n) return i({ message: "valid programTime was not found" }); if ("estimate" === n.type) return i({ message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again", seekTime: n.estimatedStart }); const s = { mediaSeconds: t }, a = ((e, t) => { if (!t.dateTimeObject) return null; const i = t.videoTimingInfo.transmuxerPrependedSeconds, n = e - (t.videoTimingInfo.transmuxedPresentationStart + i); return new Date(t.dateTimeObject.getTime() + 1e3 * n) })(t, n.segment); return a && (s.programDateTime = a.toISOString()), i(null, s) })({ playlist: this.playlistController_.media(), time: e, callback: t }) } seekToProgramTime(e, t, i = !0, n = 2) { return Xe({ programTime: e, playlist: this.playlistController_.media(), retryCount: n, pauseAfterSeek: i, seekTo: this.options_.seekTo, tech: this.options_.tech, callback: t }) } setupXhrHooks_() { this.xhr.onRequest = e => { ss(this.xhr, e) }, this.xhr.onResponse = e => { as(this.xhr, e) }, this.xhr.offRequest = e => { rs(this.xhr, e) }, this.xhr.offResponse = e => { os(this.xhr, e) }, this.player_.trigger("xhr-hooks-ready") } } const ls = { name: "tm_videojs-http-streaming", VERSION: zn, canHandleSource(e, t = {}) { const i = C(s.default.options, t); return ls.canPlayType(e.type, i) }, handleSource(e, t, i = {}) { const n = C(s.default.options, i); return t.vhs = new us(e, t, n), t.vhs.xhr = Ie(), t.vhs.setupXhrHooks_(), t.vhs.src(e.src, e.type), t.vhs }, canPlayType(e, t) { const i = ke(e); if (!i) return ""; const n = ls.getOverrideNative(t); return !Yn.supportsTypeNatively(i) || n ? "maybe" : "" }, getOverrideNative(e = {}) { const { vhs: t = {} } = e, i = !(s.default.browser.IS_ANY_SAFARI || s.default.browser.IS_IOS), { overrideNative: n = i } = t; return n } }; k("avc1.4d400d,mp4a.40.2") && s.default.getTech("Html5").registerSourceHandler(ls, 0), s.default.VhsHandler = us, s.default.VhsSourceHandler = ls, s.default.Vhs = Yn, s.default.use || s.default.registerComponent("Vhs", Yn), s.default.options.vhs = s.default.options.vhs || {}, s.default.getPlugin && s.default.getPlugin("reloadSourceOnError") || s.default.registerPlugin("reloadSourceOnError", (function (e) { jn(this, e) })), e.LOCAL_STORAGE_KEY = Qn, e.Vhs = Yn, e.VhsHandler = us, e.VhsSourceHandler = ls, e.emeKeySystems = Jn, e.expandDataUri = ns, e.getAllPsshKeySystemsOptions = Zn, e.setupEmeOptions = ts, e.simpleTypeFromSourceType = ke, e.waitForKeySessionCreation = es, Object.defineProperty(e, "__esModule", { value: !0 })
}));

/*! @name tm_videojs-hls-quality-selector @version 2.0.0 @license MIT */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("video.js")) : "function" == typeof define && define.amd ? define(["video.js"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).videojsHlsQualitySelector = e(t.tm_videojs) }(this, (function (t) { "use strict"; function e(t) { return t && "object" == typeof t && "default" in t ? t : { default: t } } var i = e(t); const l = i.default.getComponent("MenuButton"), s = i.default.getComponent("Menu"), n = i.default.getComponent("Component"), o = i.default.dom; class u extends l { constructor(t) { super(t, { title: t.localize("Quality"), name: "QualityButton" }) } createItems() { return [] } createMenu() { const t = new s(this.player_, { menuButton: this }); if (this.hideThreshold_ = 0, this.options_.title) { const i = o.createEl("li", { className: "vjs-menu-title", innerHTML: (e = this.options_.title, "string" != typeof e ? e : e.charAt(0).toUpperCase() + e.slice(1)), tabIndex: -1 }), l = new n(this.player_, { el: i }); this.hideThreshold_ += 1, t.addItem(l) } var e; if (this.items = this.createItems(), this.items) for (let e = 0; e < this.items.length; e++)t.addItem(this.items[e]); return t } } const a = i.default.getComponent("MenuItem"); class r extends a { constructor(t, e, i, l) { super(t, { label: e.label, selectable: !0, selected: e.selected || !1 }), this.item = e, this.qualityButton = i, this.plugin = l } handleClick() { for (let t = 0; t < this.qualityButton.items.length; ++t)this.qualityButton.items[t].selected(!1); this.plugin.setQuality(this.item.value), this.selected(!0) } } const h = i.default.getPlugin("plugin"), c = {}; class d extends h { constructor(t, e) { super(t), this.options = i.default.obj.merge(c, e), this.player.ready((() => { this.player.qualityLevels && (this.player.addClass("vjs-hls-quality-selector"), this.createQualityButton(), this.bindPlayerEvents()) })) } bindPlayerEvents() { this.player.qualityLevels().on("addqualitylevel", this.onAddQualityLevel.bind(this)) } createQualityButton() { const t = this.player; this._qualityButton = new u(t); const e = t.controlBar.children().length - 2, i = t.controlBar.addChild(this._qualityButton, { componentClass: "qualitySelector" }, this.options.placementIndex || e); if (i.addClass("vjs-quality-selector"), this.options.displayCurrentQuality) this.setButtonInnerText(t.localize("Auto")); else { const t = ` ${this.options.vjsIconClass || "vjs-icon-hd"}`; i.menuButton_.$(".vjs-icon-placeholder").className += t } i.removeClass("vjs-hidden") } setButtonInnerText(t) { this._qualityButton.menuButton_.$(".vjs-icon-placeholder").innerHTML = t } getQualityMenuItem(t) { const e = this.player; return new r(e, t, this._qualityButton, this) } onAddQualityLevel() { const t = this.player.qualityLevels().levels_ || [], e = []; for (let i = 0; i < t.length; ++i) { const { width: l, height: s } = t[i], n = l > s ? s : l; if (n && !e.filter((t => t.item && t.item.value === n)).length) { const t = this.getQualityMenuItem.call(this, { label: n + "p", value: n }); e.push(t) } } e.sort(((t, e) => "object" != typeof t || "object" != typeof e || t.item.value < e.item.value ? -1 : t.item.value > e.item.value ? 1 : 0)), e.push(this.getQualityMenuItem.call(this, { label: this.player.localize("Auto"), value: "auto", selected: !0 })), this._qualityButton && (this._qualityButton.createItems = () => e, this._qualityButton.update()) } setQuality(t) { const e = this.player.qualityLevels(); this._currentQuality = t, this.options.displayCurrentQuality && this.setButtonInnerText("auto" === t ? this.player.localize("Auto") : `${t}p`); for (let i = 0; i < e.length; ++i) { const { width: l, height: s } = e[i], n = l > s ? s : l; e[i].enabled = n === t || "auto" === t } this._qualityButton.unpressButton() } getCurrentQuality() { return this._currentQuality || "auto" } } return d.VERSION = "2.0.0", i.default.registerPlugin("hlsQualitySelector", d), d }));
